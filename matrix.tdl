;;; -*- Mode: TDL; Package: LKB -*-
;;;
;;;  HPSG Grammar Matrix Version 0.9
;;;
;;;  Copyright (c) 2002-2004
;;;    Emily M. Bender, Dan Flickinger, Stephan Oepen
;;;    see licence.txt for conditions
;;;
;;;  Projects using the Grammar Matrix should reference
;;;  http://www.delph-in.net/matrix, the version used
;;;  and Bender, Flickiner, & Oepen 2002.
;;;
;;;  Based on:
;;;
;;;  LinGO Grammar: fundamentals.tdl 
;;;  Copyright Daniel Flickinger 1994-2001
;;;  Initial development Rob Malouf, 3-Nov-1994
;;;
;;;  JACY Grammar: fundamentals.tdl, mrsbasic.tdl
;;;  Developed by Melanie Siegel, Emily M. Bender

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;
;;  Top-level feature geometry
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Types for Sign, Word, Phrase, and Lex-Entry

sign-min := avm &
  [ STEM list ].

basic-sign := sign-min &
  [ KEY-ARG bool ].

sign := basic-sign &
  [ SYNSEM synsem,
    ARGS list,
    INFLECTED bool ].

; C-CONT encodes the semantic contribution of the rule (phrasal
; or lexical).

phrase-or-lexrule := sign &
  [ SYNSEM canonical-synsem &
	   [ LOCAL.CONT.HOOK #hook],
    C-CONT mrs-min & [ HOOK #hook] ].

word-or-lexrule-min := sign-min.

; ALTS allow lexical entries to block lexical rule application
; ARG-ST is the argument structure list.  It appears only on
; lexical items (words or lexical rules), not on phrases.

word-or-lexrule := word-or-lexrule-min & sign &
  [ ALTS alts-min,
    ARG-ST list ].

alts-min := avm.
alts := alts-min &
  [ PASSIVE bool ].
no-alts := alts-min.

; Not all words have lex-synsem - e.g. lexical PPs like "tomorrow" are
; phr-synsem since they can be post-nominal modifiers.

word := word-or-lexrule.

lex-item := word-or-lexrule.

;; Not all phrases have SYNSEM phr-synsem, since we need to allow the
;; head-comp rules to build signs which are still [ SYNSEM lex-synsem
;; ], for constructions like "twenty-two" and "five fifteen p.m.".  So
;; most phrases will assign the type phr-synsem to the value of
;; SYNSEM, but not all.

phrase := phrase-or-lexrule.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Affixation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

non-affix-bearing := word-or-lexrule &
  [ INFLECTED +,
    SYNSEM.LKEYS.KEYREL.WLINK cons ].

; Rule

rule := sign &
  [ RULE-NAME string ].

; LABEL-NAME and META used for labeling nodes in parse trees

tree-node-label := *top* &
  [ NODE sign ].

label := sign &
  [ LABEL-NAME string ].

; For complex node labels, like S/NP
meta := sign &
  [ META-PREFIX string,
    META-SUFFIX string ]. 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SYNSEM values

; ERB 2004-05-10 DEF-OPT and OPT are used in the analysis of
; optional complements (null instantiation).  DEF-OPT allows words
; to lexically specify how their arguments will be interpreted
; in case of null instantiation.  This solution may be superceded
; by a Sem-I based alternative.

synsem-min := avm &
  [ OPT bool,
    DEF-OPT bool,
    LOCAL mod-local,
    NON-LOCAL non-local-min ].

; The feature LIGHT is used to model phenomena which distinguish
; shorter words from longer ones, or constituents which are lexical
; or nearly so from larger phrases.  It is inspired by the work 
; of Abeille and Godard (e.g., 2003).

lex-or-phrase-synsem := synsem-min &
  [ LIGHT luk ].

synsem := synsem-min.

expressed-synsem := synsem.

canonical-synsem := expressed-synsem &
  [ MODIFIED xmod ].

lex-synsem := canonical-synsem & lex-or-phrase-synsem &
  [ LOCAL local-min,
    LIGHT +,
    LKEYS lexkeys ].

phr-synsem := canonical-synsem & lex-or-phrase-synsem &
  [ LOCAL local-min,
    LIGHT - ].

non-canonical := synsem &
  [ LOCAL.CONT.HOOK.INDEX event-or-ref-index ].

expressed-non-canonical := non-canonical & expressed-synsem.

gap := expressed-non-canonical &
  [ LOCAL #local,
    NON-LOCAL [ REL 0-dlist,
		QUE 0-dlist,
		SLASH 1-dlist &
		    [ LIST < #local > ] ] ].

unexpressed := synsem-min &
  [ NON-LOCAL [ SLASH 0-dlist,
		REL 0-dlist,
		QUE 0-dlist ] ].

unexpressed-reg := unexpressed & non-canonical.

anti-synsem := unexpressed &
"A contrasting type to ordinary synsems (expressed
and unexpressed) which is sometimes useful.  No longer
explicitly used in the Matrix.".

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LOCAL & NON-LOCAL values

mod-local := avm.

local-min := mod-local &
  [ CAT cat-min,
    CONT mrs-min,
    AGR individual ].

local := local-min &
  [ CTXT ctxt-min ].

; Types for distinguishing scopal v. intersective modifiers.
; (These types are used in the MOD value of modifiers, and 
; referenced by the scopal/intersective head-adjunct rules.)

scopal-mod := local.
intersective-mod := local.

non-local-min := avm.

non-local := non-local-min &
  [ SLASH 0-1-dlist,
    QUE 0-1-dlist,
    REL 0-1-dlist ].

non-local-none := non-local &
  [ SLASH 0-dlist & [ LIST < > ],
    QUE 0-dlist,
    REL 0-dlist ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  CAT values

cat-min := avm.

; ERB 2004-05-05 Following ERG, add a feature HC-LIGHT which indicates
; whether a head-comp phrase projected from a head is treated as light
; or heavy.  That is, whether or not a phrase consisting of heads and
; complements is light or heavy is taken to be a lexical property of
; the head.

; MC stands for 'Main clause', and is used to distinguish phenomena
; which can only occur in main (+) or subordinate clauses (-).  The
; value of MC is luk, allowing for a third possibility of na, for
; not applicable.

cat := cat-min &
  [ HEAD head-min,
    VAL valence-min,
    MC luk,
    HC-LIGHT luk,
    POSTHEAD bool ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  HEAD 

head-min := avm.

; It is expected that head will have many more features, but it
; is not yet clear which are relevant crosslinguistically.  In
; the English grammar, HEAD features include CASE, PRD, AUX, INV,
; TAM, and VFORM.  (Re: TAM --- it is sometimes useful to have the
; semantic information encoded in EVENT.E accessible via the head
; path.)

head := head-min &
  [ MOD list,
    KEYS keys_min ].

; (ERB 2004-08-19) We had previously shied away from defining head
; types because even head types that are expected to occur across
; all languages are probably grouped differently in the head subhierarchy
; for different languages.  There are plenty of things which we
; think will be the same across languages, however.  Thus the current
; strategy is to allow for all possible groupings of head types,
; and expect most of the disjunctive types to be ignored in most
; languages.  Perhaps one day the LKB will be modified so that 
; users can declare certain types to suppress in the hierarchy
; displays.

; One recent LKB addition which will be helpful here is the
; type addendum statements (':+').  Head types often bear
; features, but none are declared for any of these Matrix head
; types, since we don't yet know of any universal ones.  With
; the new ':+' notation, you can add constraints (including feature
; declarations) to existing types.  We encourage you to use this
; when adding information to Matrix types, but not to types defined
; solely within your grammar.  For example:

; CASE on nouns:

; noun :+ 
; [ CASE case ]. 

; VFORM on verbs and complementizers

; +vc :+
; [ FORM form].

; We expect that particular grammars will need to add new head
; types, and may find that the new types should inherit from
; existing disjunctions.  If you do this, we encourage you to 
; make use of type addendum statements (':+') to add a comment
; to the existing disjunction, e.g.:

; co-verb := +jv.
; +jv :+
; "Adjectives, verbs, and co-verbs.".

; Anticipated future developments include Lisp commands for
; generating the appropriate type addenda and/or additional
; types when you want to add a new head type.

; Our basic inventory of head types will consist of 
; verb (v), noun (n), adjective (j), adverb (r), adposition (p), 
; complementizer (c), determiner (d), number-name (m), 
; and conjunction (o). The letters in parentheses indicate
; the abbreviation for each part of speech used in the disjunctive
; types.  Each disjunctive type is also associated with
; a documentation string explaining the disjuncts.  

; With all the disjuntive types, we need 510 types to encode this.
; The parent types are in a separate file called head-types.tdl, with
; just the leaves here.

conj := +mo & +do & +co & +po & +ro & +jo & +vo & +no.
num := +mo & +dm & +cm & +pm & +rm & +jm & +vm & +nm.
det := +do & +dm & +cd & +pd & +rd & +jd & +vd & +nd.
comp := +co & +cm & +cd & +pc & +rc & +jc & +vc & +nc.
adp := +po & +pm & +pd & +pc & +rp & +jp & +vp & +np.
adv := +ro & +rm & +rd & +rc & +rp & +jr & +vr & +nr.
adj := +jo & +jm & +jd & +jc & +jp & +jr & +vj & +nj.
verb := +vo & +vm & +vd & +vc & +vp & +vr & +vj & +nv.
noun := +no & +nm & +nd & +nc & +np & +nr & +nj & +nv.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VAL 


valence-min := avm.

valence := valence-min &
  [ SUBJ list,
    SPR list,
    COMPS list,
    SPEC list,
    --KEYCOMP avm ].

keys_min := avm.
keys := keys_min &
  [ KEY predsort,
    ALTKEY predsort ].

; One of a grammatically salient inventory of semantic sorts, such as
; 'animate' or 'time'

semsort :< sort.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CONT values
;
;   HOOK                   : Externally visible attributes of a sign
;   RELS diff-list         ; List of semantic relations
;   HCONS diff-list        ; Scope constraints: list of qeq's

mrs-min := avm.

mrs := mrs-min &
  [ HOOK hook,
    RELS diff-list,
    HCONS diff-list,
    MSG basic_message ].

; HOOK values include
;    LTOP                  ; Local top handle
;    INDEX                 ; The salient nominal instance or event
;    XARG                  ; The external (controlled) argument of a phrase

hook := avm &
  [ LTOP handle,
    INDEX individual,
    XARG individual ].

; MRSs are divided into psoas (with a distinguished event) and
; nom-objs (with a distinguished index).  We use a polymorphic
; attribute name INDEX for both of these, to simplify manipulation of
; these objects; for example, modifying PPs assign as their ARG's
; value the INDEX of the phrase they modify, whether it's an N-bar
; (with a ref-ind value) or a VP (with an event value).  Similarly
; useful for coordination.

psoa := mrs &
  [ HOOK.INDEX event ].

nom-obj := mrs &
  [ HOOK.INDEX index ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LKEYS attributes, providing pointers to semantic relations and complement
; predsorts in lexical types:
;  KEYREL relation         ; Pointer to main relation in RELS
;  ALTKEYREL relation      ; Pointer to an alternate relation in RELS
;  --COMPKEY predsort      ; Pointer to the first complement's KEY predsort
;  --OCOMPKEY predsort     ; Pointer to the oblique complement's KEY predsort

lexkeys := avm &
  [ KEYREL relation,
    ALTKEYREL relation,
    --COMPKEY predsort,
    --OCOMPKEY predsort ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  CTXT values 

ctxt-min := avm.

ctxt := ctxt-min &
  [ ACTIVATED bool,
    PRESUP diff-list ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Basic semantic types

; The message represents the semantic type of a clause (cf. Ginzburg &
; Sag 2000).  All clauses have messages.  Elements that take clauses
; as semantic arguments should end up with the LBL of the clause as
; the value of ARGn, L/R-HNDL, etc.  The MARG (message argument) of a 
; message is a handle that qeqs the LBL of the main verb in the clause.
; This leaves room for quantifiers to scope at each clause without
; allowing scope ambiguity between quanitifers and messages, as it is
; not clear what that would mean.

basic_message := relation.
message := basic_message &
  [ PRED message_m_rel,
    MARG handle ].

no-msg := basic_message.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Message preds

message_m_rel := predsort.
command_m_rel := message_m_rel.
prop-or-ques_m_rel := message_m_rel.          ;for COMPS of e.g. 'know'
proposition_m_rel := prop-or-ques_m_rel.
abstr-ques_m_rel := prop-or-ques_m_rel.       
question_m_rel := abstr-ques_m_rel.



; Subtype of int_rel for tag questions and structures in other languages
; with equivalent pragmatics.
ne_m_rel := abstr-ques_m_rel.                 

; Constrains handle of scopable argument HARG relative to one 
; outscoped LARG handle (the "H" is mnemonic for either "higher" or
; "hole" argument, while the "L" is mnemonic for either "lower" or 
; "label" argument.

qeq := avm &
  [ HARG handle,
    LARG handle ].        

semarg := avm &
"INSTLOC is used by generator to index input.  Changed from
value instloc to value string in July 2004.  The grammar
should never need to make reference to it beyond this."
  [ INSTLOC string ].

handle := semarg.
individual := semarg &
  [ SORT semsort ].

; The INDEX value of a nom-obj is an index (expletive or
; referential).
; ERB 2004-05-10 Add a feature DEF which encodes definiteness
; for (in)definite null instantiation, and possibly other uses.
; The null instantiation use might get superceded by a Sem-I based
; solution.

index := individual &
	 [ DEF bool ].

; This is the type of the index of the phrase modified by predicative
; PPs, which can either modify a ref-ind nominal or an event VP.

event-or-ref-index := individual.

; Expletives get distinguished index type so they can be
; selected semantically.  In English, this type has subtypes
; for it and there.  Most languages have at most one expletive,
; so those aren't included here.

expl-ind := index.
ref-ind := index & event-or-ref-index &
  [ PNG png ].

; Types encoding agreement information, analyzed as a part of the
; index, following Pollard & Sag 1994.  Which subtypes and features
; are appropriate seems highly language dependent.  The agreement
; system of English doesn't justify a full cross-classification of
; number and gender, so the features of png are PN and GENDER in the
; English grammar.  (See Flickinger 2000.) Sag & Wasow 1999 declare
; GENDER as a feature of the png type 3sg.

png := avm.

; Create subtypes of tense, aspect and mood as appropriate.

tense := sort.
aspect := sort.
mood := sort.

tam := avm &
  [ TENSE tense,
    ASPECT aspect,
    MOOD mood ]. 

event := event-or-ref-index &
  [ E tam ].

; Coordinated phrases have conjoined indices as their INDEX
; values.  These are meant to be interpreted as pointers to 
; the set of indices the conjunction conjoins.

conj-index := event-or-ref-index.
conj-event := conj-index & event.
conj-ref-ind := conj-index & ref-ind.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Basic relation types

; Relations are classified according to the types of arguments they take.  All
; relations have a handle.  In addition, quantifier relations have a bound
; variable and a restriction, nominal relations have an instance, and event
; relations have an event.  Furthermore, nominal relations and event relations
; can have additional roles, depending on their meaning.

; WLINK links semantic relation to input string elements, more or less.
; This becomes useful whenever a grammar is used in some application.

relation := avm &
  [ LBL handle,
    WLINK list,
    PRED predsort ].

; Abstract relation subtypes.  We recommend not positing a type
; for each lexical relation, but rather using the feature PRED
; to distinguish different lexical relations of the same type.
; Relation types are modified in one of two circumstances:
;
; (i) A feature needs to be introduced that is relevant for some
; relations and not others, or
;
; (ii) Something in the grammar needs to make reference to a family
; of relations that are not otherwise distinguished by a type.

arg0-relation := relation &
  [ ARG0 individual ].

arg1-relation := arg0-relation &
  [ ARG1 semarg ].

arg12-relation := arg1-relation &
  [ ARG2 semarg ].

arg123-relation := arg12-relation &
  [ ARG3 semarg ].

arg1234-relation := arg123-relation &
  [ ARG4 semarg ].

event-relation := arg0-relation &
  [ ARG0 event ].

arg1-ev-relation := arg1-relation & event-relation.
arg12-ev-relation := arg1-ev-relation & arg12-relation.
arg123-ev-relation := arg12-ev-relation & arg123-relation.
arg1234-ev-relation := arg123-ev-relation & arg1234-relation.

; Noun relations

noun-relation := arg0-relation &
  [ ARG0 ref-ind ].

; Relational nouns like 'picture' or 'claim' take an additional semantic 
; argument
noun-arg1-relation := noun-relation & arg1-relation.

named-relation := noun-relation &
  [ PRED named_rel,
    CARG string ].

; coordinating and subordinating conjunctions

subord-or-conj-relation := relation &
  [ L-HNDL handle,
    R-HNDL handle ].

conjunction-relation := subord-or-conj-relation &
  [ C-ARG conj-index,
    L-INDEX individual,
    R-INDEX individual ].

; NB: "if_then_rel" is now a PRED value of subord-relation.
subord-relation := subord-or-conj-relation.

; quantifier relation

quant-relation := arg0-relation &
  [ ARG0 ref-ind,
    RSTR handle,
    BODY handle ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; predsorts

norm_rel := predsort.
named_rel := norm_rel.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Head types

; Values for head features such as CASE, VFORM, ...

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Sorts for atomic values

; person, number and gender

; clause mode

; voice

; mood

; pronoun type

; Three-valued sort evoking Polish logician Jan Lukasiewicz

luk := sort.

; These types allow the statement of constraints (e.g., in 
; subcategorization) of the form:  If you care, you must have
; the value + (-), but you don't have to care.  Useful for keeping
; down the number of constructions and subcategorization types.

na-or-+ := luk.
na-or-- := luk.
+-or-- := luk.

na := na-or-+ & na-or--.
bool := luk.
+ := bool & na-or-+ & +-or--.
- := bool & na-or-- & +-or--.

; Three-valued sort for distinguishing unmodified signs from both
; left-modified and right-modified signs PERIPH indicates whether this
; modifier is left- or right-peripheral in its phrase - e.g., "the IBM
; temporary employees" but "*the IBM five employees"

xmod := sort &
  [ PERIPH luk ].
notmod-or-rmod := xmod.
notmod-or-lmod := xmod.
notmod := notmod-or-rmod & notmod-or-lmod.

hasmod := xmod.
lmod := hasmod & notmod-or-lmod.
rmod := hasmod & notmod-or-rmod.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Basic types

sort := *top*.
predsort := sort.
atom := predsort.
avm := *top*.
list := avm.

cons := list &
  [ FIRST *top*,
    REST *top* ].

0-1-list := list.
1-list := 0-1-list & cons &
  [ REST null ].
null := 0-1-list.
1-plus-list := cons &
  [ REST cons ].

diff-list := avm &
  [ LIST list,
    LAST list ].

0-1-dlist := diff-list &
  [ LIST 0-1-list ].
0-dlist := 0-1-dlist &
  [ LIST #list,
    LAST #list ].

; ADD DOC -- don't use for lists which are constructive.
; might be good now -- circular structure check?
; dpf will look into it. -- remove null?

1-dlist := 0-1-dlist &
  [ LIST 1-list &
	 [ REST #rest ],
    LAST #rest ].


; This type shows the basic form for diff-list appends.
; It is not meant to be used as a supertype.  Actual instances
; of diff-list append will involve different features in different
; relationships to each other & the feature geometry.

dl-append := avm & [APPARG1 [LIST #first,       
                             LAST #between],
                    APPARG2 [LIST #between,
                             LAST #last],
                    RESULT  [LIST #first,
                             LAST #last]].

integer := atom.

; NB: strings should be enclosed in double quotes, e.g., [PRED "named_rel"].

string := atom.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Some useful kinds of lists

; A list of optional arguments.

olist := list.

ocons := olist & cons &
  [ FIRST unexpressed & [ OPT + ],
    REST  olist ].

onull := olist & null.

; The LinGO grammar also makes use of a prolist -- or list
; of synsems of type pro-ss. 


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Lexical rules

; Grammars should be monotonic in their construction of semantic
; representations.  That is, as the tree is built, no relations should
; ever be thrown away.  This has implications for the way lexical rules
; are written.  If two forms are related to each other, and one has
; more semantic relations than the other, it has to be the output. 
; We are interested in cases where this constraint is or appears to
; be problematic.

lex-rule := phrase-or-lexrule & word-or-lexrule &
  [ NEEDS-AFFIX bool,
    SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
			     LAST #last ],
			HCONS [ LIST #hfirst,
				LAST #hlast ] ],
    DTR #dtr & word-or-lexrule &
	[ SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
		  	             LAST #middle ],
			      HCONS [ LIST #hfirst,
				      LAST #hmiddle ] ],
	  ALTS #alts ],
    C-CONT [ RELS [ LIST #middle,
		    LAST #last ],
	     HCONS [ LIST #hmiddle,
		     LAST #hlast ]],
    ALTS #alts,
    ARGS < #dtr > ].

; Lexical rules vary on two dimensions: whether they are lexeme-to-lexeme
; or lexeme-to-word and whether or not they involve spelling changes.
; Accordingly, we define four subtypes of lex-rule, which have
; four cross-classified glb subtypes:

; Note that the lexeme/word distinction is represented via a feature
; [INFLECTED bool] rather than as a type.  We find this more convenient,
; as it allows certain words to be [INFLECTED +] from the start without
; having to twist the hierarchy too much (especially if one makes use
; of defaults).

; Lexeme-to-word rules are hypothesized to monotonically add synsem
; information.

lexeme-to-word-rule := lex-rule &
  [ INFLECTED +,
    KEY-ARG #keyarg,   
    SYNSEM #synsem,
    DTR [ INFLECTED -,
          KEY-ARG #keyarg,   
          SYNSEM #synsem ],
    C-CONT.RELS <! !> ].

; Lexeme-to-lexeme rules can make more radical changes to the SYNSEM value.
; (ERB 2004-02-11) This used to inherit from "lexeme" but now there is no
; such type.  What was its purpose?

lexeme-to-lexeme-rule := lex-rule & 
  [ INFLECTED #infl,
    SYNSEM.LOCAL.CAT.MC #mc,
    DTR [ INFLECTED #infl,
          SYNSEM.LOCAL.CAT.MC #mc ] ].

; Spelling changing rules.  The LKB identifies these rules based
; on the NEEDS-AFFIX value. 

inflecting-lex-rule := lex-rule &
  [ NEEDS-AFFIX + ].

; Spelling-preserving rules copy up the STEM (orthography) of
; the daughter.

constant-lex-rule := lex-rule &
  [ STEM #stem,
    DTR [ STEM #stem ]].

; Cross-classified glb types

const-ltol-rule := lexeme-to-lexeme-rule & constant-lex-rule.
infl-ltol-rule := lexeme-to-lexeme-rule & inflecting-lex-rule.
const-ltow-rule := lexeme-to-word-rule & constant-lex-rule.
infl-ltow-rule := lexeme-to-word-rule & inflecting-lex-rule.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Phrase structure rules

; Headed phrases must obey the Head Feature Principle and the Revised
; Marking Principle.  They do not all obey the NLFP with respect to
; QUE, but it appears that all CLAUSE phrases account for QUE on
; mother and non-head-dtr.  Hence moved the QUE coreference to
; NON-CLAUSE.  Headed phrases also identify the value of AGR on mother
; and head daughter, unlike e.g. the coordination schemata which
; identify HEAD but not AGR.

headed-phrase := phrase & 
  [ SYNSEM.LOCAL [ CAT.HEAD head & #head,
                   AGR #agr ],
    HEAD-DTR.SYNSEM.LOCAL local &
		 [ CAT.HEAD #head,
                   AGR #agr ] ].

non-headed-phrase := phrase.

; Most but not all phrases have SYNSEM phr-synsem; head-complement
; constructions have their SYNSEM type determined by the head-dtr.

phrasal := phrase &
  [ SYNSEM phr-synsem ].

; Head/nexus phrases pass up the REL and QUE values of the head daughter
; (which has amalgamated the REL and QUE values of its arguments as in
; Sag 1997) to the mother.  

head-nexus-rel-phrase := headed-phrase &
  [ SYNSEM.NON-LOCAL.REL #rel,
    HEAD-DTR.SYNSEM.NON-LOCAL.REL #rel ].

head-nexus-que-phrase := headed-phrase &
  [ SYNSEM.NON-LOCAL.QUE #que,
    HEAD-DTR.SYNSEM.NON-LOCAL.QUE #que ].

head-nexus-phrase := head-nexus-rel-phrase & head-nexus-que-phrase.

; In a head/local dependent phrase, the SLASH feature of the mother is
; token-identical to that of the head daughter, which has already amalgamated
; the SLASH values of its arguments.  See discussion of head-nexus-phrase for
; treatment of REL and QUE.

head-valence-phrase := head-nexus-phrase &
  [ SYNSEM.NON-LOCAL.SLASH #slash,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash ].

; All phrases are either unary or binary.

basic-unary-phrase := phrase &
  [ STEM #stem,
    SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
        		       LAST #last ],
			HCONS [ LIST #scfirst,
				LAST #sclast ] ],
    C-CONT [ RELS [ LIST #middle,
		    LAST #last ],
	     HCONS [ LIST #scmiddle,
		     LAST #sclast ] ],
    ARGS < sign & [ STEM #stem,
                    SYNSEM.LOCAL local &
				 [ CONT [ RELS [ LIST #first,
						 LAST #middle ],
					  HCONS [ LIST #scfirst,
						  LAST #scmiddle ] ] ] ] > ].

unary-phrase := basic-unary-phrase &
  [ INFLECTED +,
    ARGS < [ INFLECTED + ] > ].

basic-binary-phrase := phrase &
  [ SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
			       LAST #last ],
			HCONS [ LIST #scfirst,
				LAST #sclast ] ],
    C-CONT [ RELS [ LIST #middle2,
		    LAST #last ],
	     HCONS [ LIST #scmiddle2,
		     LAST #sclast ] ],
    ARGS < sign & [ SYNSEM.LOCAL local &
				 [ CONT [ RELS [ LIST #first,
						 LAST #middle1 ],
					  HCONS [ LIST #scfirst,
						  LAST #scmiddle1 ] ] ] ],
	   sign & [ SYNSEM.LOCAL local &
				 [ CONT [ RELS [ LIST #middle1,
						 LAST #middle2 ],
					  HCONS [ LIST #scmiddle1,
						  LAST #scmiddle2 ] ] ] ] > ].

binary-phrase := basic-binary-phrase &
  [ INFLECTED +,
    ARGS < [ INFLECTED + ],
           [ INFLECTED + ] > ].

basic-binary-headed-phrase := headed-phrase & basic-binary-phrase &
  [ NON-HEAD-DTR sign ].

binary-headed-phrase := basic-binary-headed-phrase & binary-phrase.

; For more effecient parsing, designate one argument or the other
; as the KEY-ARG: that which should be unified with first.

binary-rule-left-to-right := rule &
  [ ARGS < [ KEY-ARG + ] , [ KEY-ARG bool ] > ].

binary-rule-right-to-left := rule &
  [ ARGS < [ KEY-ARG bool ], [ KEY-ARG + ] > ].

head-only := unary-phrase & headed-phrase &
  [ HEAD-DTR #head,
    ARGS < #head > ].

head-initial := binary-headed-phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head,
    ARGS < #head, #non-head > ].

basic-head-final := basic-binary-headed-phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head,
    ARGS < #non-head, #head > ].

head-final := basic-head-final & binary-headed-phrase.

; C-CONT is the semantic contribution of the phrase itself.  The hook 
; of the phrase is identified with the hook of C-CONT (which is possibly
; but not necessarily identified with the hook of one of the daughters.
; The rels of the phrase result from appending the rels of C-CONT and the
; rels of the daughters.

; Head-compositional phrases identify the syntactic head daughter as the
; semantic head.

head-compositional := headed-phrase &
  [ C-CONT.HOOK #hook,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #hook ].

; Clauses have message types as values, non-clauses have the value no-msg.
; Constrain the HEAD value of clause to verb or whatever type is
; appropriate.  Clauses have empty QUE values.
; Later versions of the Matrix might have clause v. non-clause as
; an independent dimension from headed v. non-headed phrase, as in
; Ginzburg & Sag 2000.  The phrase types are meant to cross-classify
; with the clause types to give e.g., decl-head-subj from decl-clause
; and head-subj-phrase.  

; ERB 2004-08-26 Remove [MC na], which is probably specific
; to some analysis for English.

non-clause := head-nexus-phrase &
  [ SYNSEM.LOCAL [ CONT.MSG no-msg ] ].

clause := phrasal &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS olist,
	     NON-LOCAL.QUE 0-dlist ] ].

; The following subtypes of clause will need more constraints,
; as appropriate:

; Relative clauses are propositions, but depending on the analysis
; of the construction, the message may actually come from the daughter.

relative-clause := clause.
  
; This type does not constrain the length of the C-CONT..RELS
; in order to allow for clause types which insert two messages
; (e.g., interrogatives, which need to add both a question_m_rel
; and the embedded proposition_m_rel), or which some other
; constructional content in addition to the message.

; The MARG isn't related to anything in this type.  There are
; two canonical possibilities: either the MARG qeqs the LTOP of
; the head daughter, or it is equal to the LBL of another message
; (again, the case of interrogatives, if there is one construction
; which introduces both messages).

basic-non-rel-clause := headed-phrase & clause &
  [ SYNSEM [ LOCAL.CONT.MSG #msg &
                            [ LBL #mhand ],
             NON-LOCAL.REL 0-dlist ],
    HEAD-DTR.SYNSEM [ LOCAL.CONT.HOOK [ INDEX #ind ],
		      NON-LOCAL [ QUE 0-dlist,
				  REL 0-dlist ] ],
    C-CONT [ HOOK [ LTOP #mhand,
                    INDEX #ind ],
	     RELS.LIST < #msg, ... >] ].

; For non-interrogative non-rel clauses, hook up 
; MARG to head daughter's LTOP.  Subtypes will need
; to constrain length of HCONS and RELS.

non-rel-clause := basic-non-rel-clause &
   [ SYNSEM.LOCAL.CONT.MSG.MARG #marg,
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
     C-CONT.HCONS.LIST.FIRST qeq & [ HARG #marg,
				     LARG #ltop ]].

; ERB 2004-05-18 Make these inherit from non-rel-clause instead
; of just clause, so that something does the work of putting
; the message on the RELS list.

interrogative-clause := basic-non-rel-clause &
  [ SYNSEM.LOCAL.CONT.MSG.PRED question_m_rel ].

declarative-clause := non-rel-clause &
  [ SYNSEM.LOCAL.CONT.MSG.PRED proposition_m_rel ].

imperative-clause := non-rel-clause &
  [ SYNSEM.LOCAL.CONT.MSG.PRED command_m_rel ].

; ERB 2004-08-26 The analysis of relative clauses in the ERG
; requires that the relative clause construction (a kind of
; "head" filler phrase) not actually be a subtype of 
; headed-phrase.  This is because the HEAD.MOD value of
; the mother and the would-be head daughter differ.
; Thus basic-filler-phrase does not inherit form headed-phrase.
; We provide a subtype, basic-head-filler-phrase, below, which does.

basic-filler-phrase := binary-phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ COMPS < >,
                                 SPR < > ],
			   POSTHEAD + ] ],
	     NON-LOCAL.SLASH 0-dlist ],
    ARGS < [ SYNSEM [ LOCAL #slash & local &
			    [ CAT.VAL [ SUBJ olist,
					COMPS olist,
					SPR olist ],
			      CTXT.ACTIVATED + ],
		      NON-LOCAL.SLASH 0-dlist ] ],
	   [ SYNSEM [ LOCAL.CAT [ VAL.COMPS olist ],
		      NON-LOCAL [ SLASH 1-dlist &
					[ LIST [ FIRST #slash,
						 REST < > & #last ],
					  LAST #last ],
				  QUE 0-dlist,
				  REL 0-dlist ] ] ] > ].

basic-head-filler-phrase := basic-filler-phrase & headed-phrase.

; These phrase types should all inherit from head-final or head-initial,
; as appropriate, replacing binary-headed-phrase.

; Don't assume that all comps are realized before the subject
; in all languages.  Remove COMPS olist from this one.  In languages
; which do realize all COMPS before the SUBJ, the head-subj-phrase
; should allow [COMPS olist] on the head daughter but constrain
; the mother to be [COMPS < >].

; ERB 2004-05-24 In anticipation of this type being cross-classified
; with decl-clause in at least some languages, it does not inherit
; from head-compositional, nor constrain the length of its C-CONT.RELS
; and C-CONT.HCONS lists.  Subtypes of this type in specific grammars
; should inherit from either a clause-type or from head-compositional,
; and ensure that the length of these lists is specified appropriately.

; ERB 2004-08-26 Remove [MC na] on head daughter; probably specific
; to some analysis for English.

basic-head-subj-phrase := head-valence-phrase & binary-headed-phrase &
  [ SYNSEM.LOCAL.CAT [ POSTHEAD +,
                       VAL [ SUBJ < >,
			     COMPS #comps,
                             SPR #spr ] ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < #synsem >,
				      COMPS #comps,	
                                      SPR #spr ],
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem &
		 [ LOCAL [ CAT [ VAL [ SUBJ olist,
				       COMPS olist,
				       SPR olist ] ] ],
		   NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
			       REL 0-dlist,
			       QUE 0-dlist ] ] ].

; ERB 2004-08-26 Remove [MC na] on both daughters; probably specific
; to some analysis for English.  

basic-head-spec-phrase := head-valence-phrase & non-clause & phrasal &
			  binary-headed-phrase &
  [ INFLECTED +,
    SYNSEM [ LOCAL.CAT [ VAL [ SUBJ #subj,
                               COMPS #spcomps,
                               SPR #spr,
                               SPEC #spec ],
                         POSTHEAD #ph ],
             MODIFIED #modif ],
    HEAD-DTR [ INFLECTED +,
               SYNSEM [ LOCAL [ CAT [ HEAD #head,
                                      VAL [ SUBJ #subj,
                                            COMPS olist & #comps,
                                            SPR < #synsem & 
                                                  canonical-synsem . #spr >,
                                            SPEC #spec ],
                                      POSTHEAD #ph ],
                                CONT.HOOK #hdhook ],
                        MODIFIED #hmodif ] ],
    NON-HEAD-DTR.SYNSEM #synsem &
	 [ LOCAL [ CAT [ VAL [ SPEC < [ LOCAL [ CAT [ HEAD #head,
                                                      VAL.COMPS #comps ],
                                                CONT.HOOK #hdhook ],
                                        MODIFIED #hmodif ] >,
                               COMPS #spcomps ] ],
                   CONT.HOOK #hook ],
           MODIFIED #modif ],
    C-CONT [ HOOK #hook,
             RELS <! !>,
	     HCONS <! !> ] ].

; Value of LIGHT comes from head-daughter's specification in HC-LIGHT.

basic-head-comp-phrase := head-valence-phrase & head-compositional &
			  binary-headed-phrase &
  [ SYNSEM canonical-synsem &
	   [ LOCAL.CAT [ MC #mc,
                         VAL [ SUBJ #subj,
                               COMPS #comps,
                               SPR #spr ],
                         POSTHEAD #ph ],
             LIGHT #light ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ MC #mc,
                                  VAL [ SUBJ #subj,
                                        COMPS < #synsem . #comps >,
                                        SPR #spr ],
				  HC-LIGHT #light,
                                  POSTHEAD #ph ]], 
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem,
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

; Skip an optional complement as long as there is still another obligatory
; complement on the list.  Two subtypes allow for one or two optional
; complements before an obligatory one.

; ERB 2004-05-10 Moving towards discharing all optional complements,
; so we no longer require that there are other expressed arguments
; before suppressing something with unexpressed.
; Still requiring [ HEAD-DTR..INDEX event ] as we might not
; want to go around discharging all optional complements of nouns.
; We'll probably want to make this a language-specific choice, eventually.
; Need to decide what to do about LIGHT here.  
; The feature DEF-OPT allows the head to specify whether the optional
; complement is interpreted as definite (+), indefinite (-), or
; either (underspecified).  basic-head-opt-comp-phrase copies this
; information into the index of the unexpressed argument.

basic-head-opt-comp-phrase := head-valence-phrase & head-only &
                              head-compositional &
  [ INFLECTED #infl,
    SYNSEM canonical-synsem &
	   [ LOCAL.CAT [ VAL [ SUBJ #subj,
			       COMPS #comps,
                               SPR #spr,
                               SPEC #spec ],
                         MC #mc,
                         POSTHEAD #ph ],
             MODIFIED #mod ],
    HEAD-DTR [ INFLECTED #infl & +,
             SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ #subj,
					  COMPS < unexpressed &
						  [ OPT +,
						    DEF-OPT #def,
						    LOCAL.CONT.HOOK.INDEX.DEF #def ] . #comps >,
					  SPR #spr,
                                        SPEC #spec ],
				    MC #mc,
				    POSTHEAD #ph ],
			      CONT.HOOK.INDEX event ],
                      MODIFIED #mod ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

; ERB 2004-05-10 For languages that allow "pro-drop" of subjects.
; (Languages that also allow "pro-drop" of other arguments will
; use this rule in addition to the head-opt-comp-phrase.)  Hypothesizing
; that null instantiation of subjects is always definite null instantiation.
; This rule is constrained to apply after all complements are discharged.

; ERB 2004-06-08 In anticipation of this type being cross-classified
; with decl-clause in at least some languages, it does not inherit
; from head-compositional, nor constrain the length of its C-CONT.RELS
; and C-CONT.HCONS lists.  Subtypes of this type in specific grammars
; should inherit from either a clause-type or from head-compositional,
; and ensure that the length of these lists is specified appropriately.

basic-head-opt-subj-phrase := head-valence-phrase & head-only &
  [ INFLECTED #infl,
    SYNSEM canonical-synsem &
	      [ LOCAL.CAT [ VAL [ SUBJ < >,
				  COMPS #comps,
				  SPR #spr,
				  SPEC #spec ],
			    MC #mc,
			    POSTHEAD #ph ],
		MODIFIED #mod ],
    HEAD-DTR [ INFLECTED #infl & +,
		SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ < unexpressed-reg &
						    [ OPT +,
						      LOCAL.CONT.HOOK.INDEX.DEF + ] >,
					     COMPS #comps & < >,
					     SPR #spr,
					     SPEC #spec ],
				       MC #mc,
				       POSTHEAD #ph ],
				 CONT.HOOK.INDEX event ],
			 MODIFIED #mod ] ] ].

; Unary rules for extraction

basic-extracted-arg-phrase := head-valence-phrase & head-only &
  [ SYNSEM.LIGHT - ].

basic-extracted-comp-phrase := basic-extracted-arg-phrase & 
                               head-compositional &
  [ SYNSEM canonical-synsem &
	   [ LOCAL.CAT [ VAL [ SUBJ #subj,
                               SPR #spr,
                               COMPS #comps ],
                         MC #mc ] ],
    HEAD-DTR [ SYNSEM 
	       [ LOCAL.CAT [ VAL [ SUBJ #subj,
                                   SPR #spr,
                                   COMPS < gap &
                                           [ NON-LOCAL.SLASH #slash ]
                                           . #comps > ],
                             MC #mc ],
		 NON-LOCAL.SLASH #slash ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

; ERB 2004-08-26 Remove [MC -] on mother; probably specific
; to analysis of subject extraction for English.

basic-extracted-subj-phrase := basic-extracted-arg-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < >,
			   SPR < >,
			   COMPS < > ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ VAL [ SUBJ < gap &
					       [ LOCAL #local & local &
						       [ CONT.HOOK.INDEX 
                                                                ref-ind ] ] >,
        				COMPS olist ],
				  MC na ],
		      NON-LOCAL.SLASH.LIST < #local > ] ].

; ERB 2004-05-05 Allow modifiers to attach to things with
; non-empty comps lists.  The head-mod-phrase will pass up
; the COMPS requirement, whatever it was.

head-mod-phrase := head-nexus-phrase &
  [ SYNSEM [ LOCAL.CAT.VAL [ SUBJ #subj,
                             SPR #spr,
                             COMPS #comps ],
             MODIFIED hasmod ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT.VAL [ SUBJ #subj,
                                      SPR #spr,
                                      COMPS #comps ],
                      NON-LOCAL [ REL 0-dlist ] ] ].

basic-extracted-adj-phrase := head-mod-phrase & head-only & phrasal.

extracted-adj-phrase := basic-extracted-adj-phrase &
  [ SYNSEM [ LOCAL.CAT [ POSTHEAD #ph,
                         MC #mc ],
	     NON-LOCAL.SLASH 1-dlist &
		   <! [ CAT [ POSTHEAD +,
                              HEAD [ MOD < [ LOCAL intersective-mod &
                                                   [ CAT [ HEAD #head,
                                                           VAL #val,
                                                           POSTHEAD #ph,
                                                           MC #mc ],
                                                     CONT.HOOK #hook,
                                                     CTXT #ctxt ] ] > ],
                              VAL [ SUBJ olist,
                                    COMPS olist,
                                    SPR olist ] ] ] !> ],
    HEAD-DTR.SYNSEM canonical-synsem &
	   [ LOCAL local &
		   [ CAT [ HEAD #head,
                           VAL #val & [ SUBJ < synsem-min &
                                               [ NON-LOCAL.SLASH 0-dlist ] > ],
			   POSTHEAD #ph,
                           MC #mc ],
                     CONT.HOOK #hook,
                     CTXT #ctxt ],
             NON-LOCAL.SLASH 0-dlist,
	     MODIFIED notmod ],
    C-CONT [ HOOK #hook,
	     HCONS <! !> ] ].

; ERB 2004-05-10 Bug fix: non-head daughter's MOD..LIGHT value should
; be matched to head-daughters LIGHT value.

basic-head-mod-phrase-simple := head-mod-phrase & binary-headed-phrase &
  [ SYNSEM [ LOCAL.CAT.MC #mc,
	     NON-LOCAL [ SLASH [ LIST #first,
				 LAST #last ],
			 REL 0-dlist ] ],
    HEAD-DTR.SYNSEM 
           [ LOCAL [ CAT [ HEAD #head,
                           VAL #val,
                           POSTHEAD #ph,
                           MC #hmc ],
                     AGR #agr,
                     CONT.HOOK #hdhook ],
             NON-LOCAL #nonloc &
                   [ SLASH [ LIST #middle,
                             LAST #last ] ],
	     LIGHT #light,
             MODIFIED #modif ],
    NON-HEAD-DTR.SYNSEM 
           [ LOCAL.CAT [ HEAD [ MOD < [ LOCAL local & 
                                              [ CAT [ HEAD #head,
                                                      VAL #val,
                                                      POSTHEAD #ph,
                                                      MC #hmc ],
                                                AGR #agr,
                                                CONT.HOOK #hdhook ],
                                        NON-LOCAL #nonloc,
					LIGHT #light,
                                        MODIFIED #modif ] > ],
                         VAL [ COMPS olist,
                               SPR olist ],
                         MC #mc ],
             NON-LOCAL [ SLASH [ LIST #first,
                                 LAST #middle ],
                         QUE 0-dlist & [ LIST null ] ] ],
    C-CONT.RELS <! !> ].

head-mod-phrase-simple := basic-head-mod-phrase-simple &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #htop,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #htop ] >].

adj-head-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM [ LOCAL.CAT.POSTHEAD #ph,
	     MODIFIED lmod & [ PERIPH #periph ],
             LIGHT #light ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT.POSTHEAD #ph,
                      LIGHT #light ],
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT [ VAL.COMPS < > ],
			  NON-LOCAL [ SLASH 0-dlist,
				      REL 0-dlist ],
                          MODIFIED.PERIPH #periph ] ].

head-adj-phrase := basic-head-mod-phrase-simple & head-initial & phrasal &
  [ SYNSEM [ LOCAL.CAT.POSTHEAD +,
	     MODIFIED rmod ],
    HEAD-DTR.SYNSEM.MODIFIED notmod-or-rmod,
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT.POSTHEAD +,
			  NON-LOCAL.QUE 0-dlist ] ].

; We split head-adj-phrase and adj-head-phrase into two each,
; one for intersective modifiers and one for scopal modifiers, in order to
; get desired results for recursive modification as in "apparently difficult
; problem" (cf. Kasper '98).  This split is also used in generation, where
; we delay construction of intersective modification, but not scopal.

scopal-mod-phrase := head-mod-phrase-simple &
  [ NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL scopal-mod ] >,
                                CONT.HOOK #hook ],
    C-CONT [ HOOK #hook,
             HCONS <! !> ] ].

; ERB 2004-05-18 I'm guessing that MSG no-msg on the head
; daughter here is going to turn out too restrictive for other
; languages.  

isect-mod-phrase := head-mod-phrase-simple & head-compositional &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT [ HOOK.LTOP #hand,
                                 MSG no-msg ],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL intersective-mod ] >,
				CONT.HOOK.LTOP #hand ],
    C-CONT.HCONS <! !> ].

adj-head-scop-phrase := adj-head-phrase & scopal-mod-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.POSTHEAD - ].
head-adj-scop-phrase := head-adj-phrase & scopal-mod-phrase &
  [ NON-HEAD-DTR.SYNSEM.NON-LOCAL.REL 0-dlist ].
adj-head-int-phrase := adj-head-phrase & isect-mod-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ POSTHEAD - ] ].
head-adj-int-phrase := head-adj-phrase & isect-mod-phrase.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;
;;  Lexical types
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Lexical entries will be cross-classified along many dimensions,
; including:
;
; -- Whether or not they introduce non-empty non-local feature values
; -- Amalgamation of non-local features
; -- Whether or not they are fully inflected as listed
;     in the lexicon.
; -- Part of speech (and associated semantic generalizations)
; -- Subcategorization
; -- Values for the HOOK features
;
; On the first three dimensions, the vast majority of words will
; actually follow the general pattern.  In order to facilitate the
; definition of types (in particular grammars) for those cases that
; don't, the constraints are stated on separate types.  Additional
; types can be created as required by inheriting from all of the types
; that are still relevant.  This is clearly an area to investigate
; the use of defaults, as we learn more about best practice concerning
; their use.
;
; Note that we don't treat these dimensions as entirely independent
; of each other, but rather hope to strike a balance between flexibility
; and redundancy. 
;
; We are currently avoiding any development within the Matrix of the
; subhierarchy under head (see notes at the definition of type head
; above), believing that the exact geometry of that hierarchy to be
; somewhat language dependent.  Thus, even the types for the part of
; speech dimension will not specify head values, and will need to be
; specialized in particular grammars to do so.  Furthermore, the
; subcategorization types will specify only the number of syntactic
; arguments and their linking to the semantic relations.

; Update: 2004-08-26 We have devised a means of adding in a subhierarchy
; under head without prejudging the disjunctive types needed.  Therefore,
; the part of speech types will not specify HEAD values.  Nonetheless,
; the HEAD values of arguments are left underspecified, as that does
; vary across languages.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; HOOK feature values

; LKEYS.KEYREL is a short-cut to the relation that is going to
; contribute the LTOP and INDEX for the word, such that linking
; types and lexical entries don't have to refer to a specific position
; on the RELS list.

norm-hook-lex-item := lex-item &
  [ SYNSEM [ LOCAL.CONT [ HOOK [ LTOP #ltop,
                                 INDEX #index ],
                          RELS.LIST.FIRST #keyrel ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop,
                                      ARG0 #index ] ] ].

; Furthermore, most lexical items contribute only one relation, and
; have empty HCONS values.

single-rel-lex-item := lex-item &
  [ SYNSEM.LOCAL.CONT.RELS <! relation !> ].

no-hcons-lex-item := lex-item & 
  [ SYNSEM.LOCAL.CONT.HCONS <! !> ].

norm-sem-lex-item := norm-hook-lex-item & single-rel-lex-item & no-hcons-lex-item.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; inflected v. uninflected

uninflected-lexeme := lex-item &
  [ INFLECTED - ].

fully-inflected-lexeme := lex-item &
  [ INFLECTED + ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Non-local features: Values and amalgamation

; Not all of the non-local features will necessarily be useful in
; all languages.  SLASH is for `topicalization' style long distance
; dependencies.  REL and QUE are used in the analysis of pied piping
; in relative clauses and questions respectively, and also to signal
; the presence of a question element in in-situ questions so that
; clausal constructions with question semantics can require the presence
; of a question word.

; basic_zero_arg lexical items have empty ARG-ST lists.  They may
; introduce a non-empty value for one of the non-local features.

basic-zero-arg := lex-item &
  [ ARG-ST < > ].

zero-arg-nonslash := lex-item &
  [ SYNSEM.NON-LOCAL.SLASH 0-dlist ].

zero-arg-nonrel : = lex-item &
  [ SYNSEM.NON-LOCAL.REL 0-dlist ].

zero-arg-nonque : = lex-item &
  [ SYNSEM.NON-LOCAL.QUE 0-dlist ].

; Non-argument taking items which introduce no non-local values.

norm-zero-arg := zero-arg-nonslash & zero-arg-nonrel & zero-arg-nonque.

; Items introducing a rel value.

zero-arg-rel := zero-arg-nonslash & zero-arg-nonque.

; Items introducing a que value.
; ERB 2004-05-24 Bug fix: This was inheriting from zero-arg-nonque
; instead of zero-arg-nonrel.

zero-arg-que := zero-arg-nonslash & zero-arg-nonrel.

; Items introducing a slash value, e.g., resumptive pronouns in French.

zero-arg-slash := zero-arg-nonrel & zero-arg-nonque.

; These non-zero argument types only amalgamate the non-local
; feature values of their complements.  They do not introduce any
; non-local values of their own, nor do they bind off any non-local
; feature values.  This assumes that the bottom of most long-distance
; dependencies is handles by a rule that constrains an argument (either
; on the ARG-ST list or a valence list) to be a synsem of type gap.
; Elements like English tough adjectives which bind off a slash value
; will need a new type that doesn't amalgamate that slash value.
; Elements which both introduce REL or QUE values and take one or
; more arguments will require appropriate new types as well, which
; amalgamate everything but add a value in addition.

basic-one-arg := lex-item &
  [ ARG-ST < [ NON-LOCAL [ SLASH #slash,
			   REL #rel,
			   QUE #que ] ] >,
    SYNSEM.NON-LOCAL [ SLASH #slash,
		       REL #rel,
		       QUE #que ] ].

basic-two-arg := lex-item &
  [ ARG-ST < [ NON-LOCAL [ SLASH [ LIST #smiddle,
				   LAST #slast ],
			   REL [ LIST #rmiddle,
				 LAST #rlast ],
			   QUE [ LIST #qmiddle,
				 LAST #qlast ] ] ],
	     [ NON-LOCAL [ SLASH [ LIST #sfirst,
				   LAST #smiddle ],
			   REL [ LIST #rfirst,
				 LAST #rmiddle ],
			   QUE [ LIST #qfirst,
				 LAST #qmiddle ] ] ] >,
    SYNSEM.NON-LOCAL [ SLASH [ LIST #sfirst,
			       LAST #slast ],
		       REL [ LIST #rfirst,
			     LAST #rlast ],
		       QUE [ LIST #qfirst,
			     LAST #qlast ] ] ].

basic-three-arg := lex-item &
  [ ARG-ST < [ NON-LOCAL [ SLASH [ LIST #smiddle2,
				   LAST #slast ],
			   REL [ LIST #rmiddle2,
				 LAST #rlast ],
			   QUE [ LIST #qmiddle2,
				 LAST #qlast ] ] ],
	     [ NON-LOCAL [ SLASH [ LIST #sfirst,
				   LAST #smiddle1 ],
			   REL [ LIST #rfirst,
				 LAST #rmiddle1 ],
			   QUE [ LIST #qfirst,
				 LAST #qmiddle1 ] ] ],
	     [ NON-LOCAL [ SLASH [ LIST #smiddle1,
				   LAST #smiddle2 ],
			   REL [ LIST #rmiddle1,
				 LAST #rmiddle2 ],
			   QUE [ LIST #qmiddle1,
				 LAST #qmiddle2 ] ] ] >,
    SYNSEM.NON-LOCAL [ SLASH [ LIST #sfirst,
			       LAST #slast ],
		       REL [ LIST #rfirst,
			     LAST #rlast ],
		       QUE [ LIST #qfirst,
			     LAST #qlast ] ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subcategorization/linking

; These types specify the number of syntactic arguments, a relation
; type, and the relationship between the syntactic arguments and the
; relation type.  They inherit from the amalgamation types above,
; since we believe that the need for cross-classification across these
; two dimensions is minimal.  That is, words which do something other
; than simply amalgamate the non-local feature values of their
; arguments probably have quirky subcategorization frames as well.

; It is expected that further types will need to be defined in 
; every particular grammar, but these types should cover the vast
; majority of open-class lexical items, and assist with some closed-class
; items as well.

; As explained above, we are leaving the HEAD values of the syntactic
; arguments underspecified as there are cross-linguistic differences
; in the part of speech of arguments in otherwise similar
; subcategorization types: English transitive verbs select two NPs.
; Japanese transitives select two PPs, as the case particles are
; treated as postpositions.

; We will, however, specify the semantic type of arguments, since it
; is relevant to the semantic constraints associated with each lexical
; item.  Clausal-argument taking elements identify the LTOP of their
; complement with an ARGn position, rather than the INDEX.  (Even
; though handles are involved here, we do identification rather than a
; relationship mediated by HCONS because the messages already leave
; enough room for quantifiers to scope at the top of the embedded
; clause, and scope ambiguities between quantifiers and messages would
; be meaningless.)  Subordinating conjunctions will have even more
; to say semantically.

; We are also leaving underspecified the mapping from ARG-ST to
; valence features.  The phrase structure rules assume one particular
; inventory of valence features (SPR, SUBJ, COMPS), but the exact
; deployment of those features might be language-specific (e.g.,
; in syntactically ergative languages).  NB: The phrase structure
; rules differentiate SPR and SUBJ in that SPR is treated as the
; semantic head.

; By hypothesis, the order of the syntactic arguments on the ARG-ST
; list corresponds to the order of the semantric arguments ARGn, with
; the caveat that not all syntactic arguments are also semantic
; arguments, as in constructions involving expletives or raising.  The
; ARGn features do not correspond to theta roles but rather should
; have their interpretation specified in the Sem-I, where the
; interpretations of each ARGn will be relative to (classes of)
; predicates.  Nonetheless, we expect the order of elements on the
; ARG-ST list follow a thematic role or grammatical function hierarchy
; in underived lexical items.  This order may be perturbed by lexical
; rules.  In addition, there are degrees of freedom allowed by the
; mapping from ARG-ST to the valence features and the possibility of
; scrambling by realizing elements of a valence list "out of order".

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; For verbs, adjectives and nouns that don't require specifiers


; Kim is tired, Kim sleeps, Kim is in the park, Kim is a student.
; Kim ga nemui, Kim ga neru.
; Kim est fatigue, Kim dors, Kim est a la maison, Kim est etudiant.

; (Kim is a student requires an analysis of predicative NPs.)

intransitive-lex-item := basic-one-arg & 
  [ ARG-ST < [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind ] >,
    SYNSEM.LKEYS.KEYREL.ARG1 #ind ].

; It rains.
; Il pleut.

expl-arg-only-lex-item := basic-one-arg &
   [ ARG-ST < [ LOCAL.CONT.HOOK.INDEX expl-ind ] > ].

; Kim eats lunch.  Kim is fond of apples.
; Kim ga hiru gohan wo taberu.  
; Kim mange le dejeuner.  

transitive-lex-item := basic-two-arg &
   [ ARG-ST < [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind1 ],
	      [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind2 ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #ind1,
			   ARG2 #ind2 ] ].

; Kim gives Sandy a book.
; Kim ga Sandy ni hon wo ageru.
; Kim donne un livre a Sandy.

ditransitive-lex-item := basic-three-arg &
  [ ARG-ST < [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind1 ],
	     [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind2 ],
	     [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind3 ] >,
    SYNSEM.LKEYS.KEYREL [ ARG1 #ind1,
			  ARG2 #ind2,
			  ARG3 #ind3 ] ].

; That Kim sleeps is obvious.
; [NB: This is just one possible analysis of clausal subjects.
;  in English, a non-branching NP -> CP rule is also plausible.
;  We are interested in arguments from other languages supporting
;  one analysis or the other.]

clausal-arg-intrans-lex-item := basic-one-arg &
   [ ARG-ST < [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #ltop ] ]. 

; That Kim sleeps surprises Sandy.

clausal-first-arg-trans-lex-item := basic-two-arg &
   [ ARG-ST < [ LOCAL.CONT.HOOK.LTOP #ltop ],
	      [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #ltop,
			   ARG2 #ind ] ].

; Sandy believes that Kim sleeps.
; Sandy ga Kim ga neru to shinjita.
; Sandy croit que Kim dors.

clausal-second-arg-trans-lex-item := basic-two-arg &
   [ ARG-ST < [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind ],
	      [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #ind,
			   ARG2 #ltop ] ].

; Kim told Sandy that Pat slept.
; Kim ga Sandy ni Pat ga neta to itta.
; Kim a dit a Sandy que Pat dormait.

clausal-third-arg-ditrans-lex-item := basic-three-arg &
   [ ARG-ST < [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind1 ],
	      [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind2 ],
	      [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #ind1,
			   ARG2 #ind2,
			   ARG3 #ltop ] ].

; It is obvious that Kim sleeps.  
; Il est evident que Kim dors.

; (Many of these might be generated via a lexical rule from
; clausal-arg-intrans-lex-items, but some probably don't alternate).

clausal-expl-arg-lex-item := basic-two-arg &
   [ ARG-ST < [ LOCAL.CONT.HOOK.INDEX expl-ind ],  
	      [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #ltop ] ].

; Kim seems to sleep; Kim is sleeping.

trans-first-arg-raising-lex-item := basic-two-arg & 
   [ ARG-ST < [ LOCAL.CONT.HOOK.INDEX #ind ],
	      [ LOCAL.CONT.HOOK [ XARG #ind,
				  LTOP #ltop ] ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #ltop ] ].

; Kim tries to sleep.

trans-first-arg-control-lex-item := basic-two-arg &
   [ ARG-ST < [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind ],
	      [ LOCAL.CONT.HOOK [ XARG #ind,
				  LTOP #ltop ] ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #ind,
			   ARG2 #ltop ] ].

; Kim appeared to Sandy to leave, Kim seems to Sandy to have left.
; (Treat "Kim seems happy to Sandy" as derived in some way?)

ditrans-first-arg-raising-lex-item := basic-three-arg &
   [ ARG-ST < [ LOCAL.CONT.HOOK.INDEX #ind1 ],
	      [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind2 ],
	      [ LOCAL.CONT.HOOK [ XARG #ind1,
				  LTOP #ltop ] ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #ind2,
			   ARG2 #ltop ] ].


; Kim promised Sandy to leave. 

ditrans-first-arg-control-lex-item := basic-three-arg &
   [ ARG-ST < [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind1 ],
	      [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind2 ],
	      [ LOCAL.CONT.HOOK [ XARG #ind1,
				  LTOP #ltop ] ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #ind1,
			   ARG2 #ind2,
			   ARG3 #ltop ] ].

; Kim believed Sandy to have left.

distrans-second-arg-raising-lex-item := basic-three-arg &
   [ ARG-ST < [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind1 ],
	      [ LOCAL.CONT.HOOK.INDEX #ind2 ],
	      [ LOCAL.CONT.HOOK [ XARG #ind2,
				  LTOP #ltop ] ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #ind1,
			   ARG2 #ltop ] ].

; Kim appealed to Sandy to leave.			     

ditrans-second-arg-control-lex-item := basic-three-arg &
   [ ARG-ST < [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind1 ],
	      [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind2 ],
	      [ LOCAL.CONT.HOOK [ XARG #ind2,
				  LTOP #ltop ] ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #ind1,
			   ARG2 #ind2,
			   ARG3 #ltop ] ].
	                     

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; For nouns requiring specifiers, adjectives taking degree specifiers, etc.

; Keep specifiers on ARG-ST because amalgamation constraints are
; stated there.  Also, in the eventual hope of implementing
; a binding theory, which seems to need to take account of possessor
; nouns in picture NPs (Runner et al 2004).

; a dog, Kim's dog

; The specifier does not play a semantic role in the book
; relation, so there is nothing more to say: these can just
; inherit from basic-one-arg, and not link in that one argument.
; The head-spec rule identifies the head's HOOK with the SPEC..HOOK
; of the specifier, which gives the specifier access to the noun's
; index for linking purposes.

; a book about dogs
; very fond of apples

spr-plus-one-arg-lex-item := basic-two-arg &
   [ ARG-ST < synsem, 
	      [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind ] >,
     SYNSEM.LKEYS.KEYREL.ARG1 #ind ].

; the claim that Sandy slept.
; very happy that Sandy slept

spr-plus-clausal-arg-lex-item := basic-two-arg &
   [ ARG-ST < synsem, 
	      [ LOCAL.CONT.HOOK.LTOP #ltop ] >,
     SYNSEM.LKEYS.KEYREL.ARG1 #ltop ].

; Whether or not we need more types here is going to largely depend
; on whether we treat deverbal nouns semantically as nominalizations,
; and how we handle the linking in that case.  Leave this for later.

; Kim is very eager to sleep.
; How eager to sleep is Kim?

spr-trans-first-arg-control-lex-item := basic-three-arg &
   [ ARG-ST < synsem,
	      [ LOCAL.CONT.HOOK.INDEX ref-ind & #ind ],
	      [ LOCAL.CONT.HOOK [ XARG #ind,
				  LTOP #ltop ] ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #ind,
			   ARG2 #ltop ] ].

; Possibly more types related to the above.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Modifiers

; Modifiers which can be used either attributively or predicatively 
; identify their XARG with their MOD..IND, so that the modified element
; or the subject play the same role.  Assume other constraints will block
; a modifier from picking up a subject (in the ERG, this is done by
; not giving them any SUBJ ever, since adjectives and PPs require
; the support of the copula to function as predicates; in a language
; which doesn't use the copula in these contexts, something else would
; need to be done.

attrib-or-pred-lex-item := lex-item &
  [ SYNSEM.LOCAL [ CAT.HEAD.MOD.FIRST.LOCAL.CONT.HOOK.INDEX #ind,
		   CONT.HOOK.XARG #ind ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Part of speech

; These types are meant to cross-classify with the above, but
; many closed-class items have linking constraints which are particular
; to the part of speech class, and so some linking constraints are
; included.

; Bringing in norm-sem-lex-item here where relevant, although this
; might be too stringent.

basic-verb-lex := norm-sem-lex-item & 
  [ SYNSEM [ LOCAL.CAT.HEAD verb,
	     LKEYS.KEYREL event-relation ]].

; ERB 2004-08-26 Put in qeq, assuming that for all scopal modifiers
; the relevant argument position is ARG1, and there will be
; no further handle constraints.  The latter especially may be
; too strong.

; Adpositions and adjectives (also adverbs, somewhere?) may
; have additional arguments, but the modified element is assumed
; to always be the ARG1.  These types should be cross-classified
; with argument structure types appropriate to their combinatoric
; potential.

scopal-mod-lex := lex-item &
  [ SYNSEM [ LOCAL [ CAT.HEAD.MOD < [ LOCAL scopal-mod &
					    [ CONT.HOOK.LTOP #larg ]] >,
		     CONT.HCONS <! qeq & 
				 [ HARG #harg,
				   LARG #larg ] !> ],
	     LKEYS.KEYREL.ARG1 #harg ]].

intersective-mod-lex := no-hcons-lex-item &
  [ SYNSEM [ LOCAL.CAT.HEAD.MOD < [ LOCAL intersective-mod & 
					  [ CONT.HOOK.INDEX #ind ]] >,
	     LKEYS.KEYREL.ARG1 #ind ] ].

no-mod-lex := no-hcons-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < > ].

basic-adjective-lex := norm-hook-lex-item & single-rel-lex-item &
  [ SYNSEM [ LOCAL.CAT.HEAD adj,
	     LKEYS.KEYREL event-relation ]].

basic-scopal-mod-adj-lex := basic-adjective-lex & scopal-mod-lex.
basic-int-mod-adj-lex := basic-adjective-lex & intersective-mod-lex.
basic-nomod-adj-lex := basic-adjective-lex & no-mod-lex.

basic-adposition-lex := norm-hook-lex-item & single-rel-lex-item &
  [ SYNSEM [ LOCAL.CAT.HEAD adp,
	     LKEYS.KEYREL event-relation ]].

basic-scopal-mod-adposition-lex := basic-adposition-lex & scopal-mod-lex.
basic-int-mod-adposition-lex := basic-adposition-lex & intersective-mod-lex.
basic-nomod-adposition-lex := basic-adposition-lex & no-mod-lex.

basic-adverb-lex := norm-hook-lex-item & single-rel-lex-item &
  [ SYNSEM [ LOCAL.CAT.HEAD adv,
	     LKEYS.KEYREL event-relation ]].

basic-scopal-adverb-lex := basic-adverb-lex & scopal-mod-lex.
basic-int-adverb-lex := basic-adverb-lex & intersective-mod-lex.

; Anticipate subtypes of basic-noun-lex for common nouns,
; proper nouns, and pronouns.  All are treated as norm-sem-lex-item
; (i.e., only introducing a single relation, and no H-CONS).  One
; might think otherwise based on canonical examples from familiar
; languages in which pronouns and proper nouns don't have determiners.
; However, even in languages like English, we find examples like
; "The Kim that I know is younger than the one that you know."
; So, rather than build the quantifier for proper nouns/pronouns
; into the lexical entry, use (potentially obligatory) non-branching
; rules to introduce the quantifier and discharge the SPR requirement.

basic-noun-lex := norm-sem-lex-item & 
  [ SYNSEM [ LOCAL.CAT.HEAD noun,
	     LKEYS.KEYREL noun-relation ]].

; Note the use of the feature SPEC in basic-determiner-lex.
; This is important semantically to allow the determiner to grab
; onto the INDEX and LTOP of the N' it combines with.  Elsewhere
; in the lexical types we have avoided mentioning the valence features,
; believing the mapping from ARG-ST to valence features to be somewhat
; language-specific.  In this case, however, it does not concern
; a mapping to ARG-ST.

basic-determiner-lex := norm-hook-lex-item &
  [ SYNSEM [ LOCAL [ CAT [ HEAD det,
			   VAL.SPEC.FIRST.LOCAL.CONT.HOOK [ INDEX #ind,
							    LTOP #larg ]],
		     CONT [ HCONS <! qeq &
				   [ HARG #harg,
				     LARG #larg ] !>,
			    RELS <! relation !> ] ],
	     LKEYS.KEYREL quant-relation &
		   [ ARG0 #ind,
		     RSTR #harg ] ] ].

; Subordinating conjunctions take two clauses, one as an argument
; (i.e., element of ARG-ST) and one as modifiee.  We allow quantifiers
; to scope between the messages of the clauses and the subord-relation
; in order to capture the ambiguity of:

; No one drinks coffee because it tastes good.

; We are interested in examples from languages where the analogous
; sentence is not analogously ambiguous.

; No hypothesis yet about the HEAD value of these cross-linguistically.

basic-subord-conjunction-lex := basic-one-arg &
  [ ARG-ST < [ LOCAL.CONT.HOOK.LTOP #ltop1 ] >,
    SYNSEM [ LOCAL [ CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #ltop2 ] >,
		     CONT [ HCONS <! qeq &
				   [ HARG #harg,
				     LARG #larg ] !>,
			    RELS <! relation,
				  message & 
				  [ LBL #msg,
				    PRED proposition_m_rel,
				    MARG #harg ] !>,
			    HOOK [ LTOP #msg ] ] ],
	     LKEYS.KEYREL subord-relation &
		   [ LBL #larg,
		     L-HNDL #ltop1,
		     R-HNDL #ltop2 ] ] ].

; Coming soon:
; Lexical type for negative particles like English "not"
; Lexical type for WH elements
; Documentation listing the phenomena handled by these lexical types.
