;;; -*- Mode: TDL; Package: LKB -*-

;;; Module for free word order, i.e., all possible
;;; orders of head, subj, comps (thinking initially
;;; about V, S, and O).

;;; Just using the V-final and V-initial modules
;;; together is unsatisfactory, since that system gives
;;; multiple parses for V-medial sentences.  On
;;; the other hand, the SVO and OVS modules together
;;; will generate SOV and VOS words, but not VSO and OSV.
;;; Any other combinations would (I believe) lead to
;;; respecifications of types (head-subj-phrase, etc)
;;; rather than multiple parallel types.

;;; In other words, the problem here is that we want 
;;; the subject to be allowed to attach lower than 
;;; complements just in case the higher complements 
;;; are on the same side of the verb as the subject.

;;; The implementation here makes use of a new feature
;;; INIT on head to track the headedness of rules, as
;;; well as constraints on the value of valence features.
;;; Head complement rules can either leave the INIT value
;;; unconstrained and require [ HEAD-DTR..SUBJ nelist ], or
;;; constrain the INIT value and require [ HEAD-DTR..SUBJ < > ].
;;; The head subject phrases can either require 
;;; [ HEAD-DTR..COMPS < > ] and leave INIT unspecified,
;;; or constrain INIT and require [ HEAD-DTR..COMPS nelist ].
;;; The value of doing this on both head-subj and head-comp
;;; rules is that it will (in theory) scale to cases of
;;; multiple complements.  This file gives head-complement
;;; rules for realizing the first or second member of
;;; the COMPS list.  Analogous rules for a third member
;;; could be written.

; Extra feature for tracking which head-comp or
; head-subj phrase has applied.  Tracks whether 
; required head-comp phrase is head-initial or head-final.

head :+ [ INIT bool ].

head-subj-phrase-1 := basic-head-subj-phrase & head-initial &
   [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

head-subj-phrase-2 := basic-head-subj-phrase & head-initial &
   [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.INIT +,
				 VAL.COMPS nelist ]].

subj-head-phrase-1 := basic-head-subj-phrase & head-final &
   [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

subj-head-phrase-2 := basic-head-subj-phrase & head-final &
   [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.INIT -,
				 VAL.COMPS nelist ]].

head-comp-phrase-1 := basic-head-1st-comp-phrase & head-initial &
   [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ nelist ].

head-comp-phrase-2 := basic-head-1st-comp-phrase & head-initial &
   [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.INIT +,
				 VAL.SUBJ < > ]].

head-comp-phrase-3 := basic-head-2nd-comp-phrase & head-initial &
   [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ nelist ].

head-comp-phrase-4 := basic-head-2nd-comp-phrase & head-initial &
   [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.INIT +,
				 VAL.SUBJ < > ]].

comp-head-phrase-1 := basic-head-1st-comp-phrase & head-final &
   [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ nelist ].

comp-head-phrase-2 := basic-head-1st-comp-phrase & head-final &
   [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.INIT -,
				 VAL.SUBJ < > ]].

comp-head-phrase-3 := basic-head-2nd-comp-phrase & head-final &
   [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ nelist ].

comp-head-phrase-4 := basic-head-2nd-comp-phrase & head-final &
   [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.INIT -,
				 VAL.SUBJ < > ]].
