### $Id: matrixdef,v 1.37 2008-09-30 23:50:02 lpoulson Exp $

Section general "General Information"

Label "<h3>Language</h3>"

Text language "Language name" "<p>Name of your language: " "<br>" 50
Text iso-code "ISO code" "<a href=\"http://www.sil.org/iso639-3/codes.asp\">ISO code</a> for your language: " " (optional) </p>" 6

Label "<h3>Archiving</h3>"

Label "<p>The developers of the Grammar Matrix project would like to retain your answers to this questionnaire in an archive.  We hope that, as the number of linguistic phenomena covered by the questionnaire grows, these archived sets of answers can be used as the basis for a database that will be useful to linguistic typological research.</p>"

Radio archive "Archive" "<p>May we retain your answers to this questionnaire?<br>" ""
. yes "Yes" "" " yes<br>"
. no "No" "" " no</p>"

Label "<p>If you answered \"yes\", we ask that you also (optionally) provide the information below.  This information will be used to distinguish multiple linguists working on the same language, to help us improve the Grammar Matrix, and possibly to contact you in the future.  We will not share your answers or identifying information outside the project, unless required by law.</p>"

Text email "Email address" "<table border=\"0\"><tr><td valign=\"top\">Your email address: <td>" "</tr>" 40

Text affiliation "Affiliation" "<tr><td valign=\"top\">Your affiliation: <td>" "</tr>" 40

Text motivation "Motivation" "<tr><td valign=\"top\">Your reason for using this system: <td>" "<br>(e.g. descriptive linguistic research, for a class)</tr></table>" 80


Section word-order "Word Order"

Radio word-order "Basic word order" "Please indicate which pattern best describes the basic word order of your language in matrix (main) clauses:<br>" ""
. sov "Subject, Object, Verb" "" "SOV<br>"
. svo "Subject, Verb, Object" "" "SVO<br>"
. vso "Verb, Subject, Object" "" "VSO<br>"
. osv "Object, Subject, Verb" "" "OSV<br>"
. ovs "Object, Verb, Subject" "" "OVS<br>"
. vos "Verb, Subject, Object" "" "VOS<br>"
. v-final "Verb-final" "" "V-final<br>"
. v-initial "Verb-initial" "" "V-initial<br>"
. free "Free word order" "" "free (pragmatically determined word order)<br>"
. v2 "v2 word order" "" "finite verb or auxiliary in second position, else free word order"

Label "<p>Note: Modules for V2 order (finite verb second, non-finite verb clause-finally) and differing word order between matrix and subordinate clauses are currently under development.</p>"

Separator

Radio has-dets "Has determiners" "Does your language have determiners (as independent words)?" ""
. yes "Yes" "" "yes"
. no "No" "" "no<br>"

Radio noun-det-order "Order of determiners and nouns" "If so, what is the order of determiners with respect to nouns?" ""
. noun-det "Noun-Det" "" "Noun-Det"
. det-noun "Det-Noun" "" "Det-Noun<br><br>"

Separator

Radio has-aux "Has auxiliaries" "Does your language have auxiliary verbs?" ""
. yes "Yes" "" "yes"
. no "No" "" "no<br>"

Label "<p>If so, please specify the following auxiliary properties:</p>"
Label "<div style=\"padding-left: 30px\">"

  Radio aux-comp-order "Order of auxiliary and complement" "<b>Word Order:</b> Does an auxiliary verb appear before or after its complement?<br>" ""
  . before "Before" "" "before <br>"
  . after "After" "" "after <br><br>"

  Radio aux-comp "Aux {i} complement" "<b>Complements:</b> The complements of auxiliaries are:<br>" ""
  . s "S" "" "saturated sentences<br>"
  . vp "VP" "" "VPs, raising the subject<br>"
  . v "V" "" "Vs, raising all of its arguments (argument composition)<br><br>" 

Label "(If you work with a language where the complement type (V, VP, or S) varies depending on the auxiliary please let us know.)<br><br>"

Label "<div style=\"padding-left: 30px\">"
    Label "If auxiliaries take a V complement and your language has VSO, OSV, or free word order, please answer the question below. In this case, the word order of the grammar will depend on whether verbs appear in a verbal cluster or not. In a verbal cluster, verbs are immediately adjacent to each other with no other arguments intervening. For instance, in a VSO language a preceding auxiliary forming a verbal cluster would result in the order AuxVSO. If no verbal cluster is formed, the order will be AuxSVO.<br><br>"
  Radio v-cluster "verb cluster" "Do the auxiliaries form a cluster?<br>" ""
  . yes "Yes" "" "yes<br>"
  . no "No" "" "no<br><br>" 

Label "NOTE: If the verbal cluster question is answered by \"no\" for a free word order language (with V auxiliary complement), the resulting grammar will allow only one auxiliary per clause.  When the auxiliary-complement order is non-harmonic (i.e. does not correspond to the general head-complement order), we assume your language has verbal clusters. Furthermore, we assume that V-initial and V-final languages form verbal clusters. If any of these assumptions does not apply to the language you work with, please let us know."

  Label "</div>"

Label "<p><span style=\"color:red\">NOTE: As Modules for V2 order are still under development, relative order of auxiliaries and their complements have not been implemented yet.</p>"

Label "</div>"


Section number "Number"

Label "<p><span class=\"dfn\">Number</span> is a grammatical category that distinguishes between different numbers of real-world entities.  For example, many languages distinguish a <span class=\"dfn\">singular</span> number from a <span class=\"dfn\">plural</span>, the former begin associated with one entity and the latter with more than one.  Other languages distinguish still more number values, including a <span class=\"dfn\">dual</span> (two entities) and a <span class=\"dfn\">paucal</span> (a few entities).  It is important to distinguish between number, described here, and numerals, which cannot currently be described in this questionnaire.  The answers you provide on this page will determine the values available on the lexicon page for the <span class=\"feat\">number</span> feature (or the <span class=\"feat\">pernum</span> feature, about which see the Person section of the questionnaire for more details).</p>"

Label "<p>Please describe the number hierarchy in your language.  Add all the values of number that the language's grammar distinguishes.  For each you may provide one or more supertypes, using the other number values you have defined or the root type <tt>number</tt> (which will be assumed if no supertype is provided).  If your language does not have number as a grammatical category, leave this section blank.</p>"

BeginIter number{i} "a Number"

  Text name "Number {i} name" "Number name: " "" 20

  BeginIter supertype{j} "a Supertype"

    Select name "Number {i} supertype {j} name" "Supertype: " ""
    fillregex number[0-9]+_name 1
    . number "Number" "number"

  EndIter supertype

EndIter number


Section person "Person"

Label "<p><span class=\"dfn\">Person</span> is a grammatical category that distinguishes between different discourse participants.  Natural languages generally distinguish up to three discourse participants: the speaker (the <span class=\"dfn\">first person</span>), the person spoken to (the <span class=\"dfn\">second person</span>), and anyone else (the <span class=\"dfn\">third person</span>).  Some languages are analyzed as having an additional <span class=\"dfn\">fourth person</span> category, whose meaning varies from language to language.  The answers you provide on this page will determine what values are available later in the questionnaire for the <span class=\"feat\">person</span> feature (or the <span class=\"feat\">pernum</span> feature; see below).</p>"

Radio person "Person" "<p>Which values of person are distinguished in your language?<br>" ""
. none "None" "" "none<br>"
. 1-2-3 "First, second, and third" "" "First, second, and third<br>"
. 1-2-3-4 "First, second, third, and fourth" "" "First, second, third, and fourth<br>"
. 1-non-1 "First and non-first" "" "First and non-first<br>"
. 2-non-2 "Second and non-second" "" "Second and non-second<br>"
. 3-non-3 "Third and non-third" "" "Third and non-third</p>"

Label "<p>Some languages are best analyzed as having subtypes of the first person for some values of the <span class=\"feat\">number</span> feature.  For example, <span class=\"dfn\">inclusive/exclusive</span> languages make a distinction in the non-singular between the first person <span class=\"dfn\">exclusive</span>, which does not include the person spoken to, and the first person <span class=\"dfn\">inclusive</span>, which does.  In <span class=\"dfn\">minimal/augmented</span> languages, three distinctions are made: speaker and one person spoken to, speaker and one other (third) person, and speaker and more than one other person.</p>"

Radio first-person "First person" "<p>What subtypes does your language distinguish in the first person?<br>" ""
. none "None" "" " none<br>"
. incl-excl "Inclusive/exclusive" "" " inclusive and exclusive"

MultiSelect incl-excl-number "Inclusive/exclusive number" " in the: " "<br>"
fillnumbers

Radio first-person "First person" "" ""
. other "Other" "" " other:</p>"

Label "<div style=\"padding-left: 16px\">"

Label "Please provide names for the subtypes distinguished by your language.  The names you provide below will be prefixed with the appropriate person and number value; for example, if you enter a subtype named \"excl\" of the first person for the number values <tt>dual</tt> and <tt>plural</tt>, the system will produce two subtypes named <tt>1dual_excl</tt> and <tt>1plural_excl</tt>.)<br>"

BeginIter person-subtype{i} "a Subtype"

  Text name "Subtype {i} name" "Name: " "" 20

  MultiSelect number "Subtype {i} number" " in the first person: " ""
  fillnumbers

EndIter person-subtype

Label "</div>"


Section gender "Gender"

Label "<p>Hockett (1958) defines grammatical <span class=\"dfn\">gender</span>s as \"classes of nouns reflected in the behavior of associated words.\"  Gender is, therefore, a phenomenon that appears in patterns of agreement.  Some languages have no genders, others divide nouns into two genders (e.g. <span class=\"dfn\">masculine</span> and <span class=\"dfn\">feminine</span>, <span class=\"dfn\">animate</span> and <span class=\"dfn\">inanimate</span>, or <span class=\"dfn\">rational</span> and <span class=\"dfn\">non-rational</span>), while still others have more.  Some languages have genders that are subtypes of other genders; for example, a language may distinguish between inanimate nouns and animate nouns, and within the animate nouns, between masculine and feminine.  Any number of genders and the relationship between them can be described by creating a type hierarchy, below.  The hierarchy you define will determine what values of the <span class=\"feat\">gender</span> feature are available later in the questionnaire.</p>"

Label "<p>Please describe the gender hierarchy in your language.  Add all the values of gender that the language's grammar distinguishes.  For each you may provide one or more supertypes, using the other gender values you have defined or the root type <tt>gender</tt> (which will be assumed if no supertype is provided).  If your language does not have gender as a grammatical category, leave this section blank.</p>"

BeginIter gender{i} "a Gender"

  Text name "Gender {i} name" "Gender name: " "" 20

  BeginIter supertype{j} "a Supertype"

    Select name "Gender {i} supertype {j} name" "Supertype: " ""
    fillregex gender[0-9]+_name 1
    . gender "Gender" "gender"

  EndIter supertype

EndIter gender

Label "<h4>References</h4>"
Label "<font size=\"2\">"
Label "<p>Hockett, Charles F. 1958. A Course in Modern Linguistics. New York: Macmillan.</p>"
Label "</font>"


Section case "Case"

Label "<p>Blake (2001) defines <span class=\"dfn\">case</span> as &quot;a system of marking dependent nouns for the type of relationship they bear to their heads.&quot; For example, case commonly marks the subject or the direct object of a verb. The marking might consist of affixation or some other morpholological process that marks words, or it might be a adposition that marks whole noun phrases.</p>"
Label "<p>This questionnaire allows you to describe <span class=\"dfn\">core case marking</span> in your language; that is, the pattern of cases marking the mandatory arguments of transitive and intransitive verbs.  Following Dixon (1968), we refer to the grammatical relations commonly expressed by case using the following abbreviations: A refers to the agent of a transitive verb; O refers to the patient (or object) of a transitive verb; and S refers to the lone argument (or subject) of intransitive verbs.</p>"

Radio case-marking "Core case marking" "<p>What type of core case marking does your language exhibit?</p>" ""
. none "None" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>None</b><br>(Verbal argument roles are determined only by word order, by intonation, or pragmatically.)</p>"
. nom-acc "Nominative-accusative" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Nominative-accusative</b><br>"

Text nom-acc-nom-case-name "Nominative case name" "S and A take a case named the " " (e.g. nominative, subjective)<br>" 20

Text nom-acc-acc-case-name "Accusative case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20

Radio case-marking "Core case marking" "" ""
. erg-abs "Ergative-absolutive" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Ergative-absolutive</b><br>"

Text erg-abs-erg-case-name "Ergative case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20

Text erg-abs-abs-case-name "Absolutive case name" "S and O take a case named the " " (e.g. absolutive, nominative)<br>" 20

Radio case-marking "Core case marking" "" ""
. tripartite "Tripartite" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Tripartite</b><br>"

Text tripartite-s-case-name "S case name" "S takes a case named the " " (e.g. nominative, subjective)<br>" 20

Text tripartite-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, agentive)<br>" 20

Text tripartite-o-case-name "O case name" "O takes a case named the " " (e.g. absolutive, patientive)<br>" 20

Radio case-marking "Core case marking" "" ""
. split-s "Split-S" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Split-S</b><br>"

Label "(The S argument of some intransitive verbs is marked by the same case as the agent of transitives, while for other verbs the S argument is marked by the same case as the patient.)<br>"

Text split-s-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, agentive)<br>" 20

Text split-s-o-case-name "O case name" "O takes a case named the " " (e.g. absolutive, patientive)<br>" 20

Radio case-marking "Core case marking" "" ""
. fluid-s "Fluid-S" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Fluid-S</b><br>"

Label "(The S argument of any intransitive verb can be marked either by the same case as the transitive agent or patient, depending on pragmatic factors, e.g. whether the S is perceived as being in control of the action.)<br>"

Text fluid-s-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, agentive)<br>" 20

Text fluid-s-o-case-name "O case name" "O takes a case named the " " (e.g. absolutive, patientive)<br>" 20

Radio case-marking "Core case marking" "" ""
. split-n "Split N" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Split conditioned on features of the noun phrase arguments</b><br>"

Label "(Some classes of noun phrases (e.g. pronouns) show a nominative-accusative pattern, while others (e.g. common nouns) show an ergative-absolutive pattern.  You will have an opportunity to define these classes on the Lexicon page.)<br>"

Text split-n-nom-case-name "Nominative case name" "S and A take a case named the " " (e.g. nominative, subjective)<br>" 20

Text split-n-acc-case-name "Accusative case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20

Text split-n-erg-case-name "Ergative case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20

Text split-n-abs-case-name "Absolutive case name" "S and O take a case named the " " (e.g. absolutive, nominative)<br>" 20

Radio case-marking "Core case marking" "" ""
. split-v "Split V" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Split conditioned on features of the verb</b><br>"

Label "(Depending on some feature of the verb (e.g. tense or aspect), the core arguments are sometimes marked in a nominative-accusative pattern and other times in an ergative-absolutive pattern.  You will have an opportunity to define these features on the Lexicon page.)<br>"

Text split-v-nom-case-name "Nominative case name" "S and A take a case named the " " (e.g. nominative, subjective)<br>" 20

Text split-v-acc-case-name "Accusative case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20

Text split-v-erg-case-name "Ergative case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20

Text split-v-abs-case-name "Absolutive case name" "S and O take a case named the " " (e.g. absolutive, nominative)<br>" 20

Radio case-marking "Core case marking" "" ""
. focus "Focus" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Focus-case</b><br>"

Label "(A number of Austronesian languages, including several Philippine languages, have a system where A and O are marked by cases.  An additional case, sometimes called the <span class=\"dfn\">focus</span>, is mandatory in every clause and has its grammatical role assigned by the morphology of the verb.  You will have an opportunity to define this morphology on the Lexicon page.)<br>"

Text focus-focus-case-name "Focus case name" "The focus case is named the " "<br>" 20

Text focus-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20

Text focus-o-case-name "O case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20

Label "<p><b>Additional Cases</b></p><p>If your language has any additional cases not covered above that occur in simple intransitive or transitive clauses (e.g. if you language has verbs whose O is marked by the dative), define those cases here:</p>"

BeginIter case{i} "a Case"

  Text name "Case {i} name" "Name: " "" 20

EndIter case

Label "<h4>References</h4>"
Label "<font size=\"2\">"
Label "<p>Blake, Barry J. 2001. Case. Cambridge: Cambridge University Press.</p>"
Label "<p>Dixon, R. M. W. 1968. The Dyirbal Language of North Queensland. Ph.D. thesis, University of London.</p>"
Label "</font>"


Section direct-inverse "Direct-inverse"

Label "<p>In some languages, the pattern of marking of verbal arguments (or verbs themselves) is sensitive to a grammatical <span class=\"dfn\">scale</span> that ranks argument noun phrases according to how natural they are in the role of agent; for example, a language might rank animate NPs as more natural agents than inanimate NPs.  In such languages, transitive sentences in which the agent outranks the patient are marked differently from those in which the patient outranks the agent.  Such sentences are said to differ in <span class=\"dfn\">direction</span>.  Sentences where the agent outranks the patient are called <span class=\"dfn\">direct</span>, while sentences where the patient outranks the agent are called <span class=\"dfn\">inverse</span>.  The difference between direct and inverse sentences may be marked by a different verb form, by different cases on the argument NPs, or both.  Creating a direct-inverse scale here will make available, on the Lexicon page, argument structures for verbs that are sensitive to the scale, and also the <span class=\"feat\">direction</span> feature for use in verbal inflection.</p>"

Label "<p>If your language shows the direct-inverse pattern, please describe the features that define the scale below.  The scale entries should be entered in order from the highest (most agent-like) to the lowest (most patient-like).</p>"

BeginIter scale{i} "a Scale Entry"

  Label "<b>Scale entry {i}</b><br>Features:"

  BeginIter feat{j} "a Feature" 1

    Select name "Scale entry {i} feature {j} name" "Name: " " "
    fillnames

    Select value "Scale entry {i} feature {j} value" "Value: " ""
    fillvalues scale{i}_feat{j}_name

  EndIter feat

EndIter scale

Select scale-equal "Direction when equal" "When the agent and patient have the same scale value, the main verb is " "<br>(The other form may be something like a reflexive.  If you select \"some other form\", the resulting grammar will not parse sentences where the agent and patient are equally ranked.  You will need to edit the starter grammar manually to add the other form.)"
. direct "Direct" "direct"
. other "Some other form" "some other form"


Section tense-aspect "Tense and Aspect"

Label "<p>You may define three semantic features directly related to tense and aspect on this page as well as a syntactic feature related to verb forms. If additional features are needed for defining tense and aspect in your language,e.g., for defining arbitrary or quasi-semantic verb classes, you may define them on the Other Features page.</p>" 

Label "<h3>Semantic Features</h3>"
Label "<div style=\"padding-left: 16px\">"

Label "<h4><span class=\"feat\">tense</span></h4>"

Label "Comrie (1985:9) defines <span class=\"dfn\">tense</span> as \"... grammaticalized expression of location in time\". Which categories of tense are grammaticalized varies across languages. You may create a hierarchy of values for the feature <span class=\"feat\">tense</span> as appropriate for your language. If your language does not have tense as a grammatical category, leave this section blank."

Label "You may define a hierarchy of values for the <span class=\"feat\">tense</span> feature in one of two ways:"

Label "<ul><li>Select among the following common hierarchy elements and supplement with subtypes as needed, or <li>Build your own hierarchy.</ul>"

Radio tense-definition "Tense hierarchy definition style" "" ""
. choose "Choose" "" "<b>Select among common hierarchy elements</b><br>"

Label "<div style=\"padding-left: 35px\">"

Label "<br>Which of the following are tense hierarchy elements in your language?<br><br>"

Check past "Past" "" "<b>past</b><br>"
  BeginIter past-subtype{i} "a subtype"
    Text name "Past subtype {i} name" "Subtype: " "" 20
  EndIter past-subtype

Check present "Present" "" "<b>present</b><br>"
  BeginIter present-subtype{i} "a subtype"
    Text name "Present subtype {i} name" "Subtype: " "" 20
  EndIter present-subtype

Check future "Future" "" "<b>future</b><br>"
  BeginIter future-subtype{i} "a subtype"
    Text name "Future subtype {i} name" "Subtype: " "" 20
  EndIter future-subtype

Check nonpast "Non-Past" "" "<b>nonpast</b> &nbsp;&nbsp;&nbsp;&nbsp; <font size=-1>(note: If present and/or future are also selected they are assumed to be subtypes of nonpast.)<br></font>"
  BeginIter nonpast-subtype{i} "a subtype"
    Text name "Non-Past subtype {i} name" "Subtype: " "" 20
  EndIter nonpast-subtype

Check nonfuture "Non-Future" "" "<b>nonfuture</b> &nbsp;&nbsp;&nbsp;&nbsp; <font size=-1>(note: If present and/or past are also selected they are assumed to be subtypes of nonfuture.)<br></font>"
  BeginIter nonfuture-subtype{i} "a subtype"
    Text name "Non-Future subtype {i} name" "Subtype: " "" 20
  EndIter nonfuture-subtype

Label "</div>"

Radio tense-definition "Tense hierarchy definition style" "" ""
. build "Build" "" "<b>Build your own <span class=\"feat\">tense</span> hierarchy</b><br>"

Label "<div style=\"padding-left: 35px\">"
Label "<br>Build your hierarchy from the top down starting with subtypes of the supertype: tense.</p>"

BeginIter tense{i} "a tense type" 

  Text name "tense {i} name" "Tense name: " "" 20
  BeginIter supertype{j} "a Supertype" 1

    Select name "Tense {i} supertype {j} name" "Supertype: " ""
    fillregex tense[0-9]+_name 1
    . tense "Tense" "tense"

  EndIter supertype

EndIter tense
Label "</div>"

Label "<h4><span class=\"feat\">aspect</span></h4>"

Label "<p>According to Kibort (2008), \"The term 'aspect' designates the perspective taken on the internal temporal organisation of the situation, and so 'aspects' distinguish different ways of viewing the internal temporal constituency of the same situation (Comrie 1976:3ff,...; Bybee 2003:157). The 'situation' is meant here as [a] general term covering events, processes, states, etc., as expressed by the verb phrase or the construction. Unlike tense, which is situation-external time, aspect is situation-internal and non-deictic, as it is not concerned with relating the time of the situation to any other time point.\""

Label "<p>\"Aspectual meaning of a clause can be broken up into two independent aspectual components (Smith 1991/1997): Aspectual viewpoint [and] Situation type ... .\" Aspectual viewpoint conveys \"the temporal perspective from which the situation is presented.\" Situation type \"classifies the situation according to its temporal properties.\" (Kibort 2008)" 

Label "<p>See references below, especially Kibort (2008), for more detail."

Label "<div style=\"padding-left: 35px\">"

Label "<p><b>Viewpoint Aspect</b>"

Label "<p>Viewpoint aspect is also commonly referred to as grammatical aspect.  The most common viewpoint opposition is perfective/imperfective. You may create a hierarchy of values for the feature <span class=\"feat\">aspect</span>, reflecting viewpoint aspect, as appropriate for your language. If your language does not have viewpoint aspect (also commonly referred to as grammatical aspect) as a grammatical category, leave this section blank."

BeginIter aspect{i} "an aspect type" 

  Text name "aspect {i} name" "Aspect name: " "" 20
  BeginIter supertype{j} "a Supertype" 1

    Select name "Aspect {i} supertype {j} name" "Supertype: " ""
    fillregex aspect[0-9]+_name 1
    . aspect "Aspect" "aspect"

  EndIter supertype

EndIter aspect

Label "<p><b>Situation Aspect</b>"

Label "<p>The term \"situation aspect\" overlaps with, or subsumes, lexical aspect, inherent aspect and some uses of the term Aktionsart. Situation aspect values may be conveyed by the meaning of the verb or through overt morphological marking however situation aspect values may depend on qualities of verbal arguments or sentential adjuncts (for example). In this case the values are compositionally derived."

Label "<p><span style=\"color:red\">Note: The implementation of situation aspect is still under development; There is, as yet, no implementation of compositionally derived situation aspect. Currently the <span class=\"feat\">situation</span> feature may be used to represent inherent lexical qualities or those conveyed through overt morphological marking. This more accurately reflects uses of the term \"lexical aspect\".</p>"

Label "<p>You may create a hierarchy of values for the feature <span class=\"feat\">situation</span>, reflecting inherent or morphologically marked situation aspect. If this is not appropriate for your language, leave this section blank.

BeginIter situation{i} "a situation type" 

  Text name "situation {i} name" "Situation name: " "" 20
  BeginIter supertype{j} "a Supertype" 1

    Select name "Situation {i} supertype {j} name" "Supertype: " ""
    fillregex situation[0-9]+_name 1
    . situation "Situation" "situation"

  EndIter supertype

EndIter situation

Label "</div>"
Label "</div>"

Separator

Label "<h3>Syntactic Feature</h3>"

Label "<div style=\"padding-left: 16px\">"
Label "<h4><span class=\"feat\">form</span></h4>"
Label "<p>In addition to the semantic features tense and aspect, your grammar may utilize a syntactic feature characterizing the form the verb takes. The <span class=\"feat\">form</span> feature distinguishes finite from non-finite forms and can be used to constrain auxiliary complement forms. If not applicable, you may leave this section blank.</p>"
Label "<p>If you have indicated on the word order page that your language has auxiliary verbs, your grammar will include <tt>finite</tt> and <tt>nonfinite</tt> as values of <span class=\"feat\">form</span>. If your language does not have auxiliaries you may still include <tt>finite</tt> and <tt>nonfinite</tt> as values of <span class=\"feat\">form</span> in your grammar:<br>" 
Check noaux-fin-nf "Finite-nonfinite" "" "My language has no auxiliaries but does make a syntactically relevant finite/non-finite distinction.</p>"

Label "<p>It is often the case that languages have multiple non-finite forms, e.g., English: infinitive, past participle, present participle. If applicable, you may expand the hierarchy of verb <span class=\"feat\">form</span> values in your grammar by providing subtypes of <tt>finite</tt> and <tt>nonfinite</tt>:</p>" 

Label "<div style=\"padding-left: 35px\">"

Label "<b>nonfinite</b>:"
  BeginIter nf-subform{i} "a subtype"
    Text name "Nonfinite subtype {i} name" "nonfinite subtype name: " "" 20
  EndIter nf-subform

Label "<b>finite</b>:"
  BeginIter fin-subform{i} "a subtype"
    Text name "Finite subtype {i} name" "finite subtype name: " "" 20
  EndIter fin-subform

Label "</div>"
Label "</div>"

Label "<h4>References</h4>"
Label "<font size=\"2\">"
Label "<p>Bybee, Joan L. 2003. Aspect. In: Frawley, W.J. (ed.) International Encyclopedia of Linguistics. Second Edition. Oxford: OUP. 157-158."
Label "<p>Comrie, Bernard. 1976. Aspect. Cambridge: CUP."
Label "<p>Comrie, Bernard. 1985. Tense. Cambridge: CUP."
Label "<p>Kibort, Anna. \"Aspect.\" Grammatical Features. 7 January 2008. <a href=\"http://www.features.surrey.ac.uk/features/aspect.html\">http://www.features.surrey.ac.uk/features/aspect.html</a>."
Label "<p>Smith, Carlota. 1997. The Parameter of Aspect. (Second Edition). Dordrecht: Kluwer Academic Publishers. (Revised version of Smith, Carlota. 1991. The Parameter of Aspect. Dordrecht: Kluwer Academic Publishers)."
Label "</font>"


Section other-features "Other Features"

Label "<p>If your language has other features beyond those that can be defined elsewhere in this questionnaire, you can define those features here.  For example, if your language has merged features (e.g. <span class=\"feat\">pernum</span> instead of <span class=\"feat\">person</span> and <span class=\"feat\">number</span>, <span class=\"feat\">gendnum</span> instead of <span class=\"feat\">gender</span> and <span class=\"feat\">number</span>), they can be defined below.</p>"

Label "<p>For each feature, you will define a type hierarchy, which consists of a root type you will name (e.g. <span class=\"feat\">pernum</span>), and then a series of other values of the feature, each of which is the subtype of at least one of the other values, possibly the root.</p>"

BeginIter feature{i} "a Feature"

  Text name "Feature {i} name" "Feature name: " "<br>" 20

  Radio type "Feature {i} type" "Is this feature:<br>" ""
  . head "Head" "" " a syntactic feature (which will go under <span class=\"feat\">head</span>)?<br>"
  . index "Index" "" " a semantic feature (which will go under <span class=\"feat\">index</span>)?<br>"

  Label "Values in the feature hierarchy:"

  BeginIter value{j} "a Value"

   Text name "Feature {i} Value {j} name" "Value name: " "" 20

    BeginIter supertype{k} "a Supertype" 1

      Select name "Feature {i} Value {j} supertype {k} name" "Supertype: " ""
      fillregex (feature{i}_name|feature{i}_value[0-9]+_name) 1

    EndIter supertype

  EndIter value

EndIter feature


Section sentential-negation "Sentential Negation"

Label "<p>Please indicate which strategy or strategies your language uses for sentential negation (as distinct from constituent negation). (You may leave this section blank, in which case your grammar will not include any information about negation.)</p>"

Check infl-neg "Negation by inflection" "<p>" "Inflectional negation: Checking this box enables a feature called <span class=\"feat\">negation</span> with possible value <tt>plus</tt> for use in defining morphemes on the lexicon page.  Defining morphemes that specify [<span class=\"feat\">negation</span> <tt>plus</tt>] will produce lexical rules that add the semantics of negation.</p>" 

Check adv-neg "Adverbial negation" "<p>" "An adverb which is an independent modifier of:<br>"

Radio neg-mod "Negative adverb modifies" "" ""
. s "S" "" "S "
. vp "VP" "" "VP "
. v "V" "" "V "

Radio neg-order "Negative adverb order" "and appears " ""
. before "Before" "" "before "
. after "After" "" "after "
. either "Either" "" "on either side of the category it modifies.<br>"

Text neg-adv-orth "Negative adverb spelling" "...and which is spelled: " "</p>" 20

Label "<p>Notes: This section is under construction.  We hope to soon return the functionality of allowing different kinds of interaction between adverbial and inflectional negation, as well as the functionality for negation by selected adverbs.</p>"



Section coordination "Coordination"

Label "<p>Languages can have multiple strategies for marking coordination that differ among the various parts of speech. The Matrix supports both lexical and morphological marking of coordination and several different marking patterns, including:</p>"

Label "<div style=\"padding-left: 16px\"><p><span class=\"dfn\">Monosyndeton</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;A B and C&quot; (last coordinand is marked; also allows &quot;A and B and C&quot;)<br><span class=\"dfn\">Polysyndeton</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;A and B and C&quot; (all coordinands but the first are marked)<br><span class=\"dfn\">Omnisyndeton</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;and A and B and C&quot; (all coordinands are marked)<br><span class=\"dfn\">Asyndeton</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;A B C&quot; (no marking; also known as <span class=\"dfn\">juxtaposition</span>)</div></p>"

Label "<p>You may define any number of coordination strategies below.  You may also leave this section blank, in which case the starter grammar produced will not support coordination.</p>"

BeginIter cs{i} "a Coordination Strategy"

Label "<p>Coordination Strategy {i}:<br>&nbsp;&nbsp;&nbsp;&nbsp;in which"

Check n "Coordination Strategy {i} coordinates Ns" "" "nouns "
Check np "Coordination Strategy {i} coordinates NPs" "" "NPs "
Check vp "Coordination Strategy {i} coordinates VPs" "" "VPs "
Check s "Coordination Strategy {i} coordinates Ss" "" "sentences<br>"

Radio pat "Coordination Strategy {i} pattern" "&nbsp;&nbsp;&nbsp;&nbsp;are marked in a " ""
. mono "Monosyndeton" "" "monosyndeton "
. poly "Polysyndeton" "" "polysyndeton "
. omni "Omnisyndeton" "" "omnisyndeton "
. a "Asyndeton" "" "asyndeton &nbsp; pattern<br>"

Radio mark "Coordination Strategy {i} mark" "&nbsp;&nbsp;&nbsp;&nbsp;by a " ""
. word "Word" "" "word "
. affix "Affix" "" "affix "

Text orth "Coordination Strategy {i} spelling" "spelled " "" 10

Radio order "Coordination Strategy {i} order" "that comes " ""
. before "Before" "" "before "
. after "After" "" "after the coordinand"

Label "</p>"

EndIter cs


Section matrix-yes-no "Matrix Yes/No Questions"

Label "<p>Please indicate which strategy your language uses to form matrix yes-no questions.  You may leave this section blank, in which case your grammar will not include a question-forming strategy.</p>"

Check q-part "Yes/No question particle" "" "A separate question particle: "

Radio q-part-order "Question particle order" "" ""
. before "Before" "" "sentence initial "
. after "After" "" "sentence final<br>"

Text q-part-orth "Question particle spelling" "&nbsp;&nbsp;&nbsp;&nbsp;Spelling of question particle: " "<br>" 40

Check q-infl "Inflection" "" "Verbal inflection:<br>"

Radio q-infl-type "Inflection type" "&nbsp;&nbsp;&nbsp;&nbsp;On: " ""
. aux "Auxiliaries only" "" "auxiliaries only "
. main "Main verbs only" "" "main verbs only "
. aux-main "Main or auxiliary verbs" "" "any finite verb (main or auxiliary)<br>"

Radio ques-aff "Affix type" "&nbsp;&nbsp;&nbsp;&nbsp;Affix type: " ""
. prefix "Prefix" "" "prefix "
. suffix "Suffix" "" "suffix<br>"

Text ques-aff-orth "Affix spelling" "&nbsp;&nbsp;&nbsp;&nbsp;Affix Spelling: " "<br>" 10

Check q-inv "Subject-verb inversion" "" "Subject-verb inversion: "

Radio q-inv-verb "Inverted verb in questions" "" ""
. main "Main" "" "main verbs only "
. aux "Auxiliary" "" "auxiliaries only "
. main-aux "Main and auxiliary" "" "any verb<br>"


Section lexicon "Lexicon"

Label "<p>On this page you will define <span class=\"dfn\">lexical types</span> and <span class=\"dfn\">lexical items</span> within those types.  For most lexical items you must provide both the spelling of the stem and a <span class=\"dfn\">predicate</span> (or <span class=\"dfn\">relation</span>) that identifies the stem's semantic contribution (e.g. <tt>_cat_n_rel</tt> for the noun relation contributed by <i>cat</i> or <tt>_sleep_v_rel</tt> for the verb relation contributed by <i>sleep</i>).</p>"

Label "<p>In addition to lexical types, you can define inflectional morphology for nouns, verbs, and determiners.  To do so, first define one or more inflectional <span class=\"dfn\">slots</span>, which determine the order in which morphemes appear, then define one or more <span class=\"dfn\">morphemes</span> that can appear in each slot, along with the <span class=\"dfn\">features</span> specified by each morpheme.  To determine the order of slots, you must define one or more <span class=\"dfn\">inputs</span> for each.  For morphemes that attach directly to stems, the input will be a lexical type; for morphemes that attach to already-inflected stems, the input will be another slot.</p>"

Separator

Label "<h3>Noun Types</h3>"

BeginIter noun{i} "a Noun Type" 1

  Label "<b>Noun type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Noun {i} name" "Type name: " "<br><br>" 20

  Label "Features:"

  BeginIter feat{j} "a Feature"

    Select name "Noun {i} feature {j} name" "Name: " " "
    fillnames

    MultiSelect value "Noun {i} feature {j} value" "Value: " ""
    fillvalues noun{i}_feat{j}_name

  EndIter feat

  Radio det "Noun {i} determiner" "<p>For nouns of this type, a determiner is " "</p>"
  . obl "Obligatory" "" "obligatory "
  . opt "Optional" "" "optional "
  . imp "Impossible" "" "impossible "

  Label "Stems:"

  BeginIter stem{j} "a Stem" 1

    Text orth "Noun {i} stem {j} spelling" "Spelling: " "" 30

    Text pred "Noun {i} stem {j} predicate" " Predicate: " "" 30

  EndIter stem

  Label "</div>"

EndIter noun

Separator

Label "<h3>Noun Inflection</h3>"

BeginIter noun-slot{i} "a Slot"

  Text name "Noun slot {i} name" "<b>Noun slot {i}</b>:<br>Slot name: " " " 20

  Check opt "Noun slot {i} optional" ", which is " " optional"

  Select order "Noun slot {i} order" " and appears " " the following inputs:<br>"
  . after "After" "after"
  . before "Before" "before"

  BeginIter input{j} "an Input" 1

    Select type "Noun slot {i} input {j} type" "Input: " ""
    fillregex (noun|verb|det)(-slot)?[0-9]+_name
    . noun "Any noun" "any noun"
    . verb "Any verb" "any verb"
    . iverb "Any intransitive verb" "any intransitive verb"
    . tverb "Any transitive verb" "any transitive verb"

  EndIter input

  Label "<p>Morpheme(s) that appear in this slot:</p>"

  BeginIter morph{j} "a Morpheme"

    Text name "Noun slot {i} morpheme {j} name" "Morpheme name: " ", " 20

    Text orth "Noun slot {i} morpheme {j} spelling" "spelling: " ", with the following features:<br>" 20

    BeginIter feat{k} "a Feature"

      Select name "Noun slot {i} morpheme {j} feature {k} name" "Name: " " "
      fillnames

      MultiSelect value "Noun slot {i} morpheme {j} feature {k} value" "Value: " ""
      fillvalues noun-slot{i}_morph{j}_feat{k}_name

    EndIter feat

  EndIter morph

  Label "<p>Constraints on other slots:</p>"

  BeginIter constraint{j} "a Constraint"

    Select type "Noun slot {i} constraint {j} type" "Constraint: " ", "
    . req "Requires closer" "If this slot appears, the other slot MUST ALSO appear CLOSER TO THE STEM"
    . forces "Requires further" "If this slot appears, the other slot MUST ALSO appear FURTHER FROM THE STEM"
    . disreq "Cannot co-occur" "If this slot appears, the other slot MUST NOT appear"

    Select other-slot "Noun slot {i} constraint {j} other slot" "other slot: " ""
    fillregex (noun|verb|det)(-slot)[0-9]+_name

  EndIter constraint

EndIter noun-slot

Separator

Label "<h3>Verb Types</h3>"

BeginIter verb{i} "a Verb Type" 2

  Label "<b>Verb type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Verb {i} name" "Type name: " "<br><br>" 20

  Label "Features:"

  BeginIter feat{j} "a Feature"

    Select name "Verb {i} feature {j} name" "Name: " " "
    fillnames

    MultiSelect value "Verb {i} feature {j} value" "Value: " ""
    fillvalues verb{i}_feat{j}_name

    Select head "Verb {i} feature {j} head" "Specified on: " ""
    . verb "The verb" "the verb"
    . subj "The subject" "the subject NP"
    . obj "The object" "the object NP"
    . higher "Higher-ranked" "the higher-ranked NP"
    . lower "Higher-ranked" "the lower-ranked NP"

  EndIter feat

  Select valence "Verb {i} arguments" "<p>Argument structure: " "</p>"
  fillverbpat

  Label "Stems:"
  BeginIter stem{j} "a Stem" 1

    Text orth "Verb {i} stem {j} spelling" "Spelling: " "" 30

    Text pred "Verb {i} stem {j} predicate" " Predicate: " "" 30

  EndIter stem

  Label "</div>"

EndIter verb

Separator

Label "<h3>"
Label auxlabel "Auxiliary Verb Types</h3>"

BeginIter aux{i} "an Auxiliary Type" 

  Label "<b>Auxiliary type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Aux {i} type name" "Type name: " "" 30

  Label "<p>Auxiliary:</p>"
  Label "<div style=\"padding-left: 30px\">"

  Radio sem "Aux {i} semantics" "This auxiliary type contributes:<br>" ""
  . add-pred "Predicate" "" "An independent predicate, e.g., English modal auxiliary 'can'."

  Label "<div style=\"padding-left: 25px\">"
  Label "<p>If this type contributes a predicate, you may also specify semantic feature values on the auxiliary, e.g., English epistemic modal 'might'. Note that these features place no constraints on the semantic values of the complement. Constraints on the complement may be defined further below in the complement section </p>" 

  BeginIter feat{j} "an auxiliary feature"

     Select name "Aux {i} feature {j} name" "Name: " ""
     fillnames

     MultiSelect value "Aux {i} feature {j} value" "Value: " ""
     fillvalues aux{i}_feat{j}_name

  EndIter feat
  Label "</div>"

  Radio sem "Aux {i} semantics" "" ""
  . no-pred "No predicate" "" "No predicate, so it does not directly contribute semantic values, e.g., English auxiliary 'be'."

  Label "</div>"

  Label "<p>Stem(s):</p>"        
  Label "<div style=\"padding-left: 30px\">" 

  BeginIter stem{j} "a Stem" 1

    Text orth "Aux {i} stem {j} spelling" "Spelling: " "" 30

    Text pred "Aux {i} stem {j} predicate" "&nbsp;&nbsp;&nbsp;&nbsp;If applicable, predicate: " "" 30

  EndIter stem
  Label "</div>"

  Label complabel "Complement Features:"
  Label "<div style=\"padding-left: 30px\">"

  Label "<br>You may specify feature values for the complement of this auxiliary type here.&nbsp;&nbsp;&nbsp;&nbsp;Note: A value for the feature FORM is required.<br><br>"

  BeginIter compfeature{j} "a complement feature" 1

    Select name "Aux {i} complement feature {j} name" "Name: " ""
    fillnames

    MultiSelect value "Aux {i} complement feature {j} value" "Value: " ""
    fillvalues aux{i}_compfeature{j}_name

  EndIter compfeature
  Label "</div>"

  Label "<p>Subject:</p>"
  Label "<div style=\"padding-left: 30px\">"

  Radio subj "Aux {i} subject" "If this auxiliary type takes a VP or V complement, its subject is a:<br>" ""
  . np "Noun phrase" "" "noun phrase without case restrictions <br>"
  . np-comp-case "NP comp case" "" "noun phrase bearing the case the verbal complement assigns to its subject <br>"
  . np-aux-case "NP aux case" "" "noun phrase, receiving the following case from its auxiliary: "

  Select subj_case "Aux {i} subject-case" "" ""
  fillvalues case 1

  Radio subj "Aux {i} subject" "" ""
  . adp "Adpositional phrase" "<br>" "adpositional phrase<br><br>"

  Label "</div>"
  Label "</div>"

EndIter aux

Separator

Label "<h3>Verb Inflection</h3>"

BeginIter verb-slot{i} "a Slot"

  Text name "Verb slot {i} name" "<b>Verb slot {i}</b>:<br>Slot name: " " " 20

  Check opt "Verb slot {i} optional" ", which is " " optional"

  Select order "Verb slot {i} order" " and appears " " the following inputs:<br>"
  . after "After" "after"
  . before "Before" "before"

  BeginIter input{j} "an Input" 1

    Select type "Verb slot {i} input {j} type" "Input: " ""
    fillregex (noun|verb|aux|det)(-slot)?[0-9]+_name
    . noun "Any noun" "any noun"
    . verb "Any verb" "any verb"
    . iverb "Any intransitive verb" "any intransitive verb"
    . tverb "Any transitive verb" "any transitive verb"
    . aux "Any auxiliary verb" "any auxiliary verb"

  EndIter input

  Label "<p>Morpheme(s) that appear in this slot:</p>"

  BeginIter morph{j} "a Morpheme"

    Text name "Verb slot {i} morpheme {j} name" "Morpheme name: " ", " 20

    Text orth "Verb slot {i} morpheme {j} spelling" "spelling: " ", with the following features:<br>" 20

    BeginIter feat{k} "a Feature"

      Select name "Verb slot {i} morpheme {j} feature {k} name" "Name: " " "
      fillnames

      MultiSelect value "Verb slot {i} morpheme {j} feature {k} value" "Value: " ""
      fillvalues verb-slot{i}_morph{j}_feat{k}_name

      Select head "Verb slot {i} morpheme {j} feature {k} head" "Specified on: " ""
      . verb "The verb" "the verb"
      . subj "The subject" "the subject NP"
      . obj "The object" "the object NP"
      . higher "Higher-ranked" "the higher-ranked NP"
      . lower "Higher-ranked" "the lower-ranked NP"

    EndIter feat

  EndIter morph

  Label "<p>Constraints on other slots:</p>"

  BeginIter constraint{j} "a Constraint"

    Select type "Verb slot {i} constraint {j} type" "Constraint: " ", "
    . req "Requires closer" "If this slot appears, the other slot MUST ALSO appear CLOSER TO THE STEM"
    . forces "Requires further" "If this slot appears, the other slot MUST ALSO appear FURTHER FROM THE STEM"
    . disreq "Cannot co-occur" "If this slot appears, the other slot MUST NOT appear"

    Select other-slot "Verb slot {i} constraint {j} other slot" "other slot: " ""
    fillregex (noun|verb|det)(-slot)[0-9]+_name

  EndIter constraint

EndIter verb-slot

Separator

Label "<h3>Determiners</h3>"

BeginIter det{i} "a Determiner"

  Label "<b>Determiner type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Determiner {i} name" "Type name: " "<br>" 20

  BeginIter stem{j} "a Stem" 1

    Text orth "Determiner {i} spelling" "Spelling: " "" 30

    Text pred "Determiner {i} predicate" " Predicate: " "<br>" 30

  EndIter stem

  Label "Features:"

  BeginIter feat{j} "a Feature"

    Select name "Determiner {i} feature {j} name" "Name: " " "
    fillnames

    MultiSelect value "Determiner {i} feature {j} value" "Value: " ""
    fillvalues det{i}_feat{j}_name

  EndIter feat

  Label "</div>"

EndIter det

Separator

Label "<h3>Determiner Inflection</h3>"

BeginIter det-slot{i} "a Slot"

  Text name "Determiner slot {i} name" "<b>Determiner slot {i}</b>:<br>Slot name: " " " 20

  Check opt "Determiner slot {i} optional" ", which is " " optional"

  Select order "Determiner slot {i} order" " and appears " " the following inputs:<br>"
  . after "After" "after"
  . before "Before" "before"

  BeginIter input{j} "an Input" 1

    Select type "Determiner slot {i} input {j} type" "Input: " ""
    fillregex (noun|verb|det)(-slot)?[0-9]+_name
    . noun "Any noun" "any noun"
    . verb "Any verb" "any verb"
    . iverb "Any intransitive verb" "any intransitive verb"
    . tverb "Any transitive verb" "any transitive verb"

  EndIter input

  Label "<p>Morpheme(s) that appear in this slot:</p>"

  BeginIter morph{j} "a Morpheme"

    Text name "Determiner slot {i} morpheme {j} name" "Morpheme name: " ", " 20

    Text orth "Determiner slot {i} morpheme {j} spelling" "spelling: " ", with the following features:<br>" 20

    BeginIter feat{k} "a Feature"

      Select name "Determiner slot {i} morpheme {j} feature {k} name" "Name: " " "
      fillnames

      MultiSelect value "Determiner slot {i} morpheme {j} feature {k} value" "Value: " ""
      fillvalues det-slot{i}_morph{j}_feat{k}_name

    EndIter feat

  EndIter morph

  Label "<p>Constraints on other slots:</p>"

  BeginIter constraint{j} "a Constraint"

    Select type "Determiner slot {i} constraint {j} type" "Constraint: " ", "
    . req "Requires closer" "If this slot appears, the other slot MUST ALSO appear CLOSER TO THE STEM"
    . forces "Requires further" "If this slot appears, the other slot MUST ALSO appear FURTHER FROM THE STEM"
    . disreq "Cannot co-occur" "If this slot appears, the other slot MUST NOT appear"

    Select other-slot "Determiner slot {i} constraint {j} other slot" "other slot: " ""
    fillregex (noun|verb|det)(-slot)[0-9]+_name

  EndIter constraint

EndIter det-slot

Separator

Label "<h3>Case-marking Adpositions</h3>"

BeginIter adp{i} "an Adposition"

  Text orth "Adposition {i} spelling" "Spelling: " "" 20

  Check opt "Adposition {i} optional" ", which is " " optional"

  Select order "Adposition {i} order" " and appears " " a noun phrase<br><br>Features:<br>"
  . after "After" "after"
  . before "Before" "before"

  BeginIter feat{j} "a Feature"

    Select name "Adposition {i} feature {j} name" "Name: " " "
    fillnames

    MultiSelect value "Adposition {i} feature {j} value" "Value: " ""
    fillvalues adp{i}_feat{j}_name

  EndIter feat

EndIter adp


Section test-sentences "Some Test Sentences"

Label "<p>In this section, you can provide example sentences that will appear as defaults in the LKB's parse dialog.  Please use only the vocabulary defined in the Lexicon section.</p>"

Text sentence1 "Sentence 1" "<p>Sentence 1: " "</p>" 100

Text sentence2 "Sentence 2" "<p>Sentence 2: " "</p>" 100
