## $Id: matrixdef,v 1.37 2008-09-30 23:50:02 lpoulson Exp $

Section general "General Information"

Label "<h3>Language</h3>"

Text language "Language name" "<p>Name of your language: " "<br>" 50
Text iso-code "ISO code" "<a href=\"http://www.sil.org/iso639-3/codes.asp\">ISO code</a> for your language: " " (optional) </p>" 6

Label "<h3>String-processing</h3><p>Your grammar will include a basic tokenizer file for string-level processing (<span class='tt'>vanilla.rpp</span>, see <a href='http://moin.delph-in.net/ReppTop/'>ReppTop</a> documentation).  We have three default options for this file.  If you do not answer, your grammar will include a tokenizer which will discard most ascii punctuation (except the hyphen, colon, and equals [-,:,=]).<br />"

Radio punctuation-chars "Punctuation characters" "<br />" ""
. discard-all "discard-all" "" "split on, and then discard all punctuation characters found in this default list (all lower ascii punctuation except \x22 \"): <span class='tt'>!#$%&#38;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~\</span><!--we can't currently do anything about the unicode characters... maybe later 。！？…．　○●◎＊☆★◇◆--><br />"
. keep-all "keep-all" "" "only split space and tab characters, all other characters can occur in tokens<br />"
. keep-list "keep-list" "" "place characters into a list of characters that can occur within tokens (you can copy and paste from the default list above; do not use any commas or spaces to delimit characters)."

Text punctuation-chars-list "Punctuation characters" "&nbsp;&nbsp;Punctuation characters to parse:" "<br />" 50

Label "<h3>Archiving and Version Control</h3>"

Label "<p>The developers of the Grammar Matrix project would like to
retain your answers to this questionnaire in an archive.  We hope
that, as the number of linguistic phenomena covered by the
questionnaire grows, these archived sets of answers can be used as the
basis for a database that will be useful to linguistic typological
research. We welcome answers from users of all experience levels.</p>"

Radio archive "Archive" "<p>May we retain your answers to this questionnaire?<br>" ""
. yes "Yes" "" " yes (recommended)<br>"
. no "No" "" " no</p>"

Label "<p>If you answered \"yes\", we ask that you also (optionally)
provide the information below.  This information will be used to
distinguish multiple linguists working on the same language, to help
us improve the Grammar Matrix, and possibly to contact you in the
future.  We will not share your answers or identifying information
outside the project, unless required by law.</p>"

Text email "Email address" "<table id='feedback'><tr><td>Your email address: <td>" "</tr>" 40
one-name
Text affiliation "Affiliation" "<tr><td>Your affiliation: <td>" "</tr>" 40

Text motivation "Motivation" "<tr><td>Your reason for using this system: <td>" "<br>(e.g. descriptive linguistic research, for a class)</tr>" 80

TextArea comment "Comments" "<tr><td>Comments on your implementation of the grammar: <td>" "<br>(e.g. Choice of analyses, sources of information, etc.)</tr></table>" 80x6

Label "<p>We recommend that you use version control for your grammar development, and aim to facilitate that in two ways.  First, you can choose to have your grammar's code initialized into a Git or Mercurial repository.  Please see <a href=\"http://wiki.delph-in.net/moin/VersionControlForGrammarDevelopment\">this wiki page</a> for information on how to use these systems. The wiki also includes information on how to use Subversion (svn) with your grammar.</p>"

Radio vcs "Version Control System" "<p>Version Control System.<br>" ""
. none "None" "" " None<br>"
. hg "Mercurial (hg)" "" " Mercurial (hg)<br>"
. git "Git" "" " Git<br>"

Label "<p>You may also wish to have your repository hosted through an open source hosting service (e.g., Google Code or GitHub).  This provides off-site back-up and facilitates sharing your grammar and collaborating with others.  The wiki (linked above) includes information on how to set that up.  Note that Google Code can host Mercurial or Subversion repositories, and GitHub hosts Git repositories. If you do host your grammar on one of these sites, please let us know that you have, by emailing matrix-dev -at- uw.edu.</p>"

Section word-order "Word Order"

Label "<p>"

Radio word-order "Basic word order" "Please indicate which pattern best describes the basic word order of your language in matrix (main) clauses:<br>" "</p>"
. sov "Subject, Object, Verb" "" "SOV<br>"
. svo "Subject, Verb, Object" "" "SVO<br>"
. vso "Verb, Subject, Object" "" "VSO<br>"
. osv "Object, Subject, Verb" "" "OSV<br>"
. ovs "Object, Verb, Subject" "" "OVS<br>"
. vos "Verb, Subject, Object" "" "VOS<br>"
. v-final "Verb-final" "" "V-final<br>"
. v-initial "Verb-initial" "" "V-initial<br>"
. free "Free word order" "" "free (pragmatically determined word order)<br>"
. v2 "v2 word order" "" "finite verb or auxiliary in second position, else free word order<br>"
. v2 "v2 word order" "" "finite verb second, non-finite verb clause-finally"

Separator

Radio has-dets "Has determiners" "Does your language have determiners (as independent words)?" ""
. yes "Yes" "" "yes"
. no "No" "" "no<br>"

Radio noun-det-order "Order of determiners and nouns" "If so, what is the order of determiners with respect to nouns?" ""
. noun-det "Noun-Det" "" "Noun-Det"
. det-noun "Det-Noun" "" "Det-Noun<br><br>"

Separator

Radio has-aux "Has auxiliaries" "Does your language have auxiliary verbs?" ""
. yes "Yes" "" "yes"
. no "No" "" "no<br>"

Label "<p>If so, please specify the following auxiliary properties:</p>"
Label "<div style=\"padding-left: 30px\">"

  Radio aux-comp-order "Order of auxiliary and complement" "<b>Word Order:</b> Does an auxiliary verb appear before or after its complement?<br>" ""
  . before "Before" "" "before <br>"
  . after "After" "" "after <br><br>"

  Radio aux-comp "Aux {i} complement" "<b>Complements:</b> The complements of auxiliaries are:<br>" ""
  . s "S" "" "saturated sentences<br>"
  . vp "VP" "" "VPs, raising the subject<br>"
  . v "V" "" "Vs, raising all of its arguments (argument composition)<br><br>"

Label "(If you work with a language where the complement type (V, VP,
or S) varies depending on the auxiliary please let us know.)<br><br>"

  Radio multiple-aux "multiple auxiliaries" "Can there be more than one auxiliary in a clause?<br>" ""
  . yes "Yes" "" "yes<br>"
  . no "No" "" "no<br><br>"

Label "NOTE: If your language has free word order and allows more than one auxiliary per clause, we assume that the verbal group forms a cluster (i.e. that all verbal forms are adjacent to each other). If your language reveals different behavior, please let us know."


Label "<p><span style=\"color:red\">NOTE: As Modules for V2 order are
still under development, relative order of auxiliaries and their
complements have not been implemented yet.</span></p>"

Separator 

Label "<p>The word order in subordinate clauses is:</p>"

  Radio subord-word-order "Clausal Complement Type {i} clause word order" "" ""
  . same "same as in indicative" "" "Same as in the matrix clause<br>" 
  . vfinal "Verb Final" "" "Verb-final (assuming matrix order is V2, like in German)"
  
Label "<p> NOTE: We assume that the order in all subordinate clauses 
(e.g. clausal modifiers and clausal complements)
is the same. If your language reveals different behavior, 
please let us know.</p>"

Label "</div>"

Section number "Number"

Label "<p><span class=\"dfn\">Number</span> is a grammatical category
that distinguishes between different numbers of real-world entities.
For example, many languages distinguish a <span
class=\"dfn\">singular</span> number from a <span
class=\"dfn\">plural</span>, the former begin associated with one
entity and the latter with more than one.  Other languages distinguish
still more number values, including a <span class=\"dfn\">dual</span>
(two entities) and a <span class=\"dfn\">paucal</span> (a few
entities).  It is important to distinguish between number, described
here, and numerals, which cannot currently be described in this
questionnaire.  The answers you provide on this page will determine
the values available on the lexicon page for the <span
class=\"feat\">number</span> feature (or the <span
class=\"feat\">pernum</span> feature, about which see the Person
section of the questionnaire for more details).</p>"

Label "<p>Please describe the number hierarchy in your language.  Add
all the values of number that the language's grammar distinguishes.
For each you may provide one or more supertypes, using the other
number values you have defined or the root type
<span class=\"tt\">number</span> (which
will be assumed if no supertype is provided).  If your language does
not have number as a grammatical category, leave this section
blank.</p>"

BeginIter number{i} "a Number" 1

  Text name "Number {i} name" "Number name: " "" 20

  BeginIter supertype{j} "a Supertype"

    Select name "Number {i} supertype {j} name" "Supertype: " ""
    fillregex p=number[0-9]+_name n=1
    . number "Number" "number"

  EndIter supertype

EndIter number


Section person "Person"

Label "<p><span class=\"dfn\">Person</span> is a grammatical category
that distinguishes between different discourse participants.  Natural
languages generally distinguish up to three discourse participants:
the speaker (the <span class=\"dfn\">first person</span>), the person
spoken to (the <span class=\"dfn\">second person</span>), and anyone
else (the <span class=\"dfn\">third person</span>).  Some languages
are analyzed as having an additional <span class=\"dfn\">fourth
person</span> category, whose meaning varies from language to
language.  The answers you provide on this page will determine what
values are available later in the questionnaire for the <span
class=\"feat\">person</span> feature (or the <span
class=\"feat\">pernum</span> feature; see below).</p>"

Radio person "Person" "<p>Which values of person are distinguished in your language?<br>" ""
. none "None" "" "none<br>"
. 1-2-3 "First, second, and third" "" "First, second, and third<br>"
. 1-2-3-4 "First, second, third, and fourth" "" "First, second, third, and fourth<br>"
. 1-non-1 "First and non-first" "" "First and non-first<br>"
. 2-non-2 "Second and non-second" "" "Second and non-second<br>"
. 3-non-3 "Third and non-third" "" "Third and non-third</p>"

Label "<p>Some languages are best analyzed as having subtypes of the
first person for some values of the <span class=\"feat\">number</span>
feature.  For example, <span class=\"dfn\">inclusive/exclusive</span>
languages make a distinction in the non-singular between the first
person <span class=\"dfn\">exclusive</span>, which does not include
the person spoken to, and the first person <span
class=\"dfn\">inclusive</span>, which does.  In <span
class=\"dfn\">minimal/augmented</span> languages, three distinctions
are made: speaker and one person spoken to, speaker and one other
(third) person, and speaker and more than one other person.</p>"

Radio first-person "First person" "<p>What subtypes does your language distinguish in the first person?<br>" ""
. none "None" "" " none<br>"
. incl-excl "Inclusive/exclusive" "" " inclusive and exclusive"

MultiSelect incl-excl-number "Inclusive/exclusive number" " in the: " "<br>"
fillnumbers


Radio first-person "First person" "" ""
. other "Other" "" " other:</p>"

Label "<div style=\"padding-left: 16px\">"

Label "Please provide names for the subtypes distinguished by your
language.  The names you provide below will be prefixed with the
appropriate person and number value; for example, if you enter a
subtype named \"excl\" of the first person for the number values
<span class=\"tt\">dual</span> and <span class=\"tt\">plural</span>, the system will produce two
subtypes named <span class=\"tt\">1dual_excl</span> and <span class=\"tt\">1plural_excl</span>.)<br>"

BeginIter person-subtype{i} "a Subtype"

  Text name "Subtype {i} name" "Name: " "" 20

  MultiSelect number "Subtype {i} number" " in the first person: " ""
  fillnumbers

EndIter person-subtype

Label "</div>"


Section gender "Gender"

Label "<p>Hockett (1958) defines grammatical <span
class=\"dfn\">gender</span>s as \"classes of nouns reflected in the
behavior of associated words.\" Gender is, therefore, a phenomenon
that appears in patterns of agreement.  Some languages have no
genders, others divide nouns into two genders (e.g. <span
class=\"dfn\">masculine</span> and <span
class=\"dfn\">feminine</span>, <span class=\"dfn\">animate</span> and
<span class=\"dfn\">inanimate</span>, or <span
class=\"dfn\">rational</span> and <span
class=\"dfn\">non-rational</span>), while still others have more.
Some languages have genders that are subtypes of other genders; for
example, a language may distinguish between inanimate nouns and
animate nouns, and within the animate nouns, between masculine and
feminine.  Any number of genders and the relationship between them can
be described by creating a type hierarchy, below.  The hierarchy you
define will determine what values of the <span
class=\"feat\">gender</span> feature are available later in the
questionnaire.</p>"

Label "<p>Please describe the gender hierarchy in your language.  Add
all the values of gender that the language's grammar distinguishes.
For each you may provide one or more supertypes, using the other
gender values you have defined or the root type <span class=\"tt\">gender</span>
(which will be assumed if no supertype is provided).  If your language does
not have gender as a grammatical category, leave this section
blank.</p>"

BeginIter gender{i} "a Gender" 1

  Text name "Gender {i} name" "Gender name: " "" 20

  BeginIter supertype{j} "a Supertype"

    Select name "Gender {i} supertype {j} name" "Supertype: " ""
    fillregex p=gender[0-9]+_name n=1
    . gender "Gender" "gender"

  EndIter supertype

EndIter gender

Label "<h4>References</h4>"
Label "<div style=\"font-size:2\">"
Label "<p>Hockett, Charles F. 1958. A Course in Modern
Linguistics. New York: Macmillan.</p>"
Label "</div>"


Section case "Case"

Label "<p>Blake (2001) defines <span class=\"dfn\">case</span> as
&quot;a system of marking dependent nouns for the type of relationship
they bear to their heads.&quot; For example, case commonly marks the
subject or the direct object of a verb. The marking might consist of
affixation or some other morpholological process that marks words, or
it might be an adposition that marks whole noun phrases.</p>"

Label "<p>This questionnaire allows you to describe <span
class=\"dfn\">core case marking</span> in your language; that is, the
pattern of cases marking the mandatory arguments of transitive and
intransitive verbs.  Following Dixon (1968), we refer to the
grammatical relations commonly expressed by case using the following
abbreviations: A refers to the agent of a transitive verb; O refers to
the patient (or object) of a transitive verb; and S refers to the lone
argument (or subject) of intransitive verbs.</p>"

Radio case-marking "Core case marking" "<p>What type of core case marking does your language exhibit?</p>" ""
. none "None" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>None</b><br>(Verbal argument roles are determined only by word order, by intonation, or pragmatically.)</p>"
. nom-acc "Nominative-accusative" "<p style=\"margin-left:20px;margin-bottom:0px;text-indent:-20px\">" "<b>Nominative-accusative</b><br></p>"

Label "<p style=\"margin-left:20px;margin-top:0px\">"
Text nom-acc-nom-case-name "Nominative case name" "S and A take a case named the " " (e.g. nominative, subjective)<br>" 20
Text nom-acc-acc-case-name "Accusative case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20
Label "</p>"


Radio case-marking "Core case marking" "" ""
. erg-abs "Ergative-absolutive" "<p style=\"margin-left:20px;margin-bottom:0px;text-indent:-20px\">" "<b>Ergative-absolutive</b><br></p>"

Label "<p style=\"margin-left:20px;margin-top:0px\">"
Text erg-abs-erg-case-name "Ergative case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20
Text erg-abs-abs-case-name "Absolutive case name" "S and O take a case named the " " (e.g. absolutive, nominative)<br>" 20
Label "</p>"


Radio case-marking "Core case marking" "" ""
. tripartite "Tripartite" "<p style=\"margin-left:20px;margin-bottom:0px;text-indent:-20px\">" "<b>Tripartite</b><br></p>"

Label "<p style=\"margin-left:20px;margin-top:0px\">"
Text tripartite-s-case-name "S case name" "S takes a case named the " " (e.g. nominative, subjective)<br>" 20
Text tripartite-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, agentive)<br>" 20
Text tripartite-o-case-name "O case name" "O takes a case named the " " (e.g. absolutive, patientive)<br>" 20
Label "</p>"


Radio case-marking "Core case marking" "" ""
. split-s "Split-S" "<p style=\"margin-left:20px;margin-bottom:0px;text-indent:-20px\">" "<b>Split-S</b><br></p>"

Label "<p style=\"margin: 0px 0px 0px 20px\">(The S argument of some intransitive verbs is marked by the
same case as the agent of transitives, while for other verbs the S
argument is marked by the same case as the patient.)</p>"

Label "<p style=\"margin-left:20px;margin-top:0px\">"
Text split-s-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, agentive)<br>" 20
Text split-s-o-case-name "O case name" "O takes a case named the " " (e.g. absolutive, patientive)<br>" 20
Label "</p>"


Radio case-marking "Core case marking" "" ""
. fluid-s "Fluid-S" "<p style=\"margin-left:20px;margin-bottom:0px;text-indent:-20px\">" "<b>Fluid-S</b><br></p>"

Label "<p style=\"margin: 0px 0px 0px 20px\">(The S argument of some intransitive verbs is marked by the
same case as the agent of transitives, while for other verbs the S
argument is marked by the same case as the patient, and for still
other verbs the S argument can be marked by either case, depending on
pragmatic factors (e.g. whether the S is perceived as being in control
of the action.)</p>"

Label "<p style=\"margin-left:20px;margin-top:0px\">"
Text fluid-s-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, agentive)<br>" 20
Text fluid-s-o-case-name "O case name" "O takes a case named the " " (e.g. absolutive, patientive)<br>" 20
Label "</p>"


Radio case-marking "Core case marking" "" ""
. split-n "Split N" "<p style=\"margin-left:20px;margin-bottom:0px;text-indent:-20px\">" "<b>Split conditioned on features of the noun phrase arguments</b><br></p>"

Label "<p style=\"margin: 0px 0px 0px 20px\">(Some classes of noun phrases (e.g. pronouns) show a
nominative-accusative pattern, while others (e.g. common nouns) show
an ergative-absolutive pattern.  You will have an opportunity to
define these classes on the Lexicon page.)</p>"

Label "<p style=\"margin-left:20px;margin-top:0px\">"
Text split-n-nom-case-name "Nominative case name" "S and A take a case named the " " (e.g. nominative, subjective)<br>" 20
Text split-n-acc-case-name "Accusative case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20
Text split-n-erg-case-name "Ergative case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20
Text split-n-abs-case-name "Absolutive case name" "S and O take a case named the " " (e.g. absolutive, nominative)<br>" 20
Label "</p>"


Radio case-marking "Core case marking" "" ""
. split-v "Split V" "<p style=\"margin-left:20px;margin-bottom:0px;text-indent:-20px\">" "<b>Split conditioned on features of the verb</b><br></p>"

Label "<p style=\"margin: 0px 0px 0px 20px\">(Depending on some feature of the verb (e.g. tense or aspect),
the core arguments are sometimes marked in a nominative-accusative
pattern and other times in an ergative-absolutive pattern.  You will
have an opportunity to define these features on the Lexicon
page.)</p>"

Label "<p style=\"margin-left:20px;margin-top:0px\">"
Text split-v-nom-case-name "Nominative case name" "S and A take a case named the " " (e.g. nominative, subjective)<br>" 20
Text split-v-acc-case-name "Accusative case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20
Text split-v-erg-case-name "Ergative case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20
Text split-v-abs-case-name "Absolutive case name" "S and O take a case named the " " (e.g. absolutive, nominative)<br>" 20
Label "</p>"


Radio case-marking "Core case marking" "" ""
. focus "Focus" "<p style=\"margin-left:20px;margin-bottom:0px;text-indent:-20px\">" "<b>Focus-case</b><br></p>"

Label "<p style=\"margin: 0px 0px 0px 20px\">(A number of Austronesian languages, including several
Philippine languages, have a system where A and O are marked by cases.
An additional case, sometimes called the <span
class=\"dfn\">focus</span>, is mandatory in every clause and has its
grammatical role assigned by the morphology of the verb.  You will
have an opportunity to define this morphology on the Morphology
page.)</p>"

Label "<p style=\"margin-left:20px;margin-top:0px\">"
Text focus-focus-case-name "Focus case name" "The focus case is named the " "<br>" 20
Text focus-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20
Text focus-o-case-name "O case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20
Label "</p>"


Label "<p><b>Additional Cases</b></p><p>If your language has any
additional cases not covered above that occur in simple intransitive
or transitive clauses (e.g. if you language has verbs whose O is
marked by the dative), define those cases here:</p>"

BeginIter case{i} "a Case"

  Text name "Case {i} name" "Name: " "" 20

EndIter case

Label "<h4>References</h4>"
Label "<div style=\"font-size:2\">"
Label "<p>Blake, Barry J. 2001. Case. Cambridge: Cambridge University
Press.</p>"
Label "<p>Dixon, R. M. W. 1968. The Dyirbal Language of North
Queensland. Ph.D. thesis, University of London.</p>"
Label "</div>"


Section adnom-poss "Adnominal Possession" 

Label "<p>There are two ways to add possessive constructions to your grammar: you can define <b>possessive strategies</b>, or define classes of <b>possessor pronouns</b>. For many languages, both are appropriate.</p>"

Label "<p>An adnominal <b>possessive strategy</b> is a pattern wherein one noun phrase is marked as the possessor of another noun phrase. This strategy may consist of some morphological marking on either the possessor or the possessum, though some languages convey possession through simple juxtaposition of noun phrases. </p>"


BeginIter poss-strat{i} "a possessive strategy"

     Radio order "Word order" "<p>The word order within a possessive phrase is:</p>" ""
     . head-final "head-final" "" "possessor-first<br>"
     . head-initial "head-initial" "" "possessum-first<br>"
     . either "either" "" "either<br>"

     Radio mod-spec "Modifier or specifier" "<p>In some possessive strategies, the possessor acts like a <b>specifier</b> of the possessum; in other strategies, the possessor is more like a <b>modifier</b> of the possessum. For a full explanation of the tests used to distinguish these two behaviors, see the documentation link above. <br><br> <b>Note:</b> The primary test for this property is whether or not the possessum can take both a possessor and a determiner at the same time. If it can, then the possessor is modifier-like; if it cannot, the possessor is specifier-like. <b>If there is no strong evidence either way, the specifier-like analysis should be chosen.</b> <br><br> In this strategy, is the possessor more like a </p>" ""
     . spec "specifier" "" "specifier<br>"
     . mod "modifier" "" "modifier<br>"

     Radio mark-loc "Mark location" "<p> Do any morphemes (affixes, clitics, or separate words) appear which mark the noun phrase as possessive? If so, where?</p>" ""
     . possessor "Possessor marking" "" "On the possessor<br>"  "toggle_element.call(this, 'possessor-morph{i}', 'on'); toggle_element.call(this, 'possessum-morph{i}', 'off');toggle_element.call(this, 'juxt{i}', 'off');toggle_element.call(this, 'possessum-only{i}', 'off');"
     . possessum "Possessum marking" "" "On the possessum<br>"  "toggle_element.call(this, 'possessum-morph{i}', 'on'); toggle_element.call(this, 'possessor-morph{i}', 'off');toggle_element.call(this, 'juxt{i}', 'off');toggle_element.call(this, 'possessum-only{i}', 'on');"
     . both "Both marking" "" "On both the possessor and the possessum<br>" "toggle_element.call(this, 'possessum-morph{i}', 'on'); toggle_element.call(this, 'possessor-morph{i}', 'on');toggle_element.call(this, 'juxt{i}', 'off');toggle_element.call(this, 'possessum-only{i}', 'off');"
     . neither "Neither marking" "" "No possessive morphemes appear<br>" "toggle_element.call(this, 'possessum-morph{i}', 'off'); toggle_element.call(this, 'possessor-morph{i}', 'off');toggle_element.call(this, 'juxt{i}', 'on');toggle_element.call(this, 'possessum-only{i}', 'off');"


     Label "<div id='juxt{i}' style='display:none'>"

        Radio pronoun-allow "Pronoun allowability" "<p>Can the possessor in these unmarked possessive constructions be a pronoun?</p>" ""
        . yes "Pronouns allowed" "" "yes<br>"
        . no "Pronouns disallowed" "" "no<br>" 	
     
        Label "<p>If there are constraints on the features of the possessor (e.g. case) in these unmarked possessive constructions, please use the button below to add them.</p>"

        BeginIter feat{j} "a feature constraint on the possessor"
     
           Select name "Juxtaposition construction possessor feature {j} Name" "Name: " " "
      	   fillnames c=noun

      	   MultiSelect value "Juxtaposition construction possessor feature {j} Value" "Value: " ""
      	   fillvalues p=poss-strat{i}_feat{j}_name      

        EndIter feat

     Label "</div>"

     Label "<div id='possessor-morph{i}' style='display:none'>"
     
	Radio possessor-type "Possessor morpheme type" "<p>Is the morpheme that marks the <b>possessor</b> an affix? Or is it a separate word or clitic?</p>" ""
     	. affix "Possessor affix" "" "affix<br>"  "toggle_element.call(this, 'possessor-affix{i}', 'on'); toggle_element.call(this, 'possessor-non-affix{i}', 'off');"
     	. non-affix "Possessor non-affix" "" "separate word or clitic<br>" "toggle_element.call(this, 'possessor-affix{i}', 'off'); toggle_element.call(this, 'possessor-non-affix{i}', 'on');"
     
        Label "<div id='possessor-affix{i}' style='display:none'>"
	   
	   Radio possessor-affix-agr "Possessor agreement" "<p>Does the affix that marks the possessor agree with the possessum (e.g. in person, number, or gender)?</p>" ""
	   . agree "Possessor agree" "" "yes<br>"
	   . non-agree "Possessor non-agree" "" "no<br>"

	   Label "<p> A feature called <span class=\"feat\">poss-strat{i}</span> with possible values <span class=\"tt\">possessor</span>, <span class=\"tt\">possessum</span>,  and <span class=\"tt\">nonpossessive</span> has been defined for use in defining morphemes on the morphology page.  In order to define a possessor-marking affix, add the appropriate position class and lexical rules, and mark the lexical rules as [<span class=\"feat\">poss-strat{i}</span> <span class=\"tt\">possessor</span>]. If you make the possessive marking obligatory (recommended), remember to also create a non-possessive inflecting rule in the same position class by creating a lexical rule type marked [<span class=\"feat\">poss-strat{i}</span> <span class=\"tt\">nonpossessive</span>]. Be sure to select the feature that corresponds to <span class=\"feat\">poss-strat{i}</span>. If the possessor-marking affix(es) agree(s) with the possessum, add appropriate person, number, and gender features to each lexical rule type. Note that any person/number/gender features that are listed on a possessor lexical rule type are assumed to be features that agree with the possessum.</p>"

	Label "</div>"

     	Label "<div id='possessor-non-affix{i}' style='display:none'>"

	   Radio possessor-mark-order "Mark Order" "<p>Does the word that marks the possessor appear before or after it?</p>" ""
	   . head-initial "Marker before" "" "before<br>"
	   . head-final "Marker after" "" "after<br>"
	   . either "Marter either order" "" "either<br>"

	   Radio pronoun-allow "Pronoun allowability" "<p>Can the possessor marked by this word or clitic be a pronoun?</p>" ""
	   . yes "Pronouns allowed" "" "yes<br>"
	   . no "Pronouns disallowed" "" "no<br>"

           Label "<p>If there are any feature constraints (such as case) on the noun marked by this word or clitic, please enter them using the button below:</p>"

           BeginIter dep-comp-feat{j} "a feature constraint on the possessor"

              Select name "Non-affix marked possessor feature {j} Name" "Name: " ""
	      fillnames c=noun

              MultiSelect value "Non-affix marked possessor feature {j} Value" "Value: " ""
	      fillvalues p=poss-strat{i}_dep-comp-feat{j}_name

           EndIter dep-comp-feat

           Radio possessor-agr "Possessor agreement" "<p>Does the possessor-marking word or clitic agree with the possessum?</p>" ""
	   . agree "Possessor agree" "" "yes<br>" "toggle_element.call(this, 'possessor-agr{i}', 'on'); toggle_element.call(this, 'possessor-non-agr{i}', 'off');"
	   . non-agree "Possessor non agree" "" "no<br>"  "toggle_element.call(this, 'possessor-agr{i}', 'off');toggle_element.call(this, 'possessor-non-agr{i}', 'on');"

	   Label "<div id='possessor-non-agr{i}' style='display:none'>"

	      Text possessor-orth "Possessor word orth" "<br>The possessor-marking word is spelled " "<br>" 15

	   Label "</div>"

	   Label "<div id='possessor-agr{i}' style='display:none'>"

  	      BeginIter possessor-form{n} "a possessor-marking word with agreement features"
 
 	         Text name "Type name" "Type name: " "-adp-lex<br>" 15

	         Text agr-orth "Agreement orthography" "<br> The form spelled: " "<br>carries the following agreement features<br>" 15

	         BeginIter feat{k} "an agreement feature"
	   
	            Select name "Possessive strategy {i} possessor-marking word Form {n} Feature {k} Name" "Name: " " "
      	            fillnames c=noun

		    MultiSelect value "Possessive Strategy {i} possessor-marking word Form {n} Feature {k} Value" "Value: " ""
      	            fillvalues p=poss-strat{i}_possessor-form{n}_feat{k}_name

    	         EndIter feat

	      EndIter possessor-form

	   Label "</div>"

     	Label "</div>"

     Label "</div>"                                                                                                                            

   Label "<div id='possessum-only{i}' style='display:none'>"
     	   
      Label "<p>If there are any feature constraints (such as case) on the possessor in this construction, please enter them using the button below:</p>"

      BeginIter possessor-feat{j} "a feature constraint on the possessor"
     
          Select name "Unmarked possessor feature {j} Name" "Name: " " "
          fillnames c=noun

          MultiSelect value "Unmarked possessor feature {j} Value" "Value: " ""
          fillvalues p=poss-strat{i}_possessor-feat{j}_name      

     EndIter possessor-feat

   Label "</div>"

   Label "<div id='possessum-morph{i}' style='display:none'>"
     
      Radio possessum-type "Possessum morpheme type" "<p>Is the morpheme that marks the <b>possessum</b> an affix? Or is it a separate word or clitic?</p>" ""
      . affix "Possessum affix" "" "affix<br>" "toggle_element.call(this, 'possessum-affix{i}', 'on'); toggle_element.call(this, 'possessum-non-affix{i}', 'off');"
      . non-affix "Possessum non-affix" "" "separate word or clitic<br>"  "toggle_element.call(this, 'possessum-affix{i}', 'off'); toggle_element.call(this, 'possessum-non-affix{i}', 'on');"

      Label "<div id='possessum-affix{i}' style='display:none'>"

       	  Radio possessum-affix-agr "Possessum agreement" "<p>Does the affix that marks the possessum agree with the possessor (e.g. in person, number, or gender)?</p>" ""
	  . agree "Possessum agree" "" "yes<br>"
	  . non-agree "Possessum non-agree" "" "no<br>"

	  Label "<p>A feature called <span class=\"feat\">poss-strat{i}</span> with possible values <span class=\"tt\">possessor</span>, <span class=\"tt\">possessum</span>, and <span class=\"tt\">nonpossessive</span> has been defined for use in defining morphemes on the morphology page.  In order to define a possessum-marking affix, add the appropriate position class and lexical rules, and mark the lexical rules as [<span class=\"feat\">poss-strat{i}</span> <span class=\"tt\">possessum</span>]. If you make the possessive marking obligatory (recommended), remember to also create a non-possessive inflecting rule in the same position class by creating a lexical rule type marked [<span class=\"feat\">poss-strat{i}</span> <span class=\"tt\">nonpossessive</span>]. Be sure to select the feature that corresponds to <span class=\"feat\">poss-strat{i}</span>. If the possessum-marking affix(es) agree(s) with the possessor, add appropriate person, number, and gender features to each lexical rule type. Note that any person/number/gender features that are listed on a possessum lexical rule type are assumed to be features that agree with the possessor.</p>"
	   
     Label "</div>"

     Label "<div id='possessum-non-affix{i}' style='display:none'>"

        Radio possessum-mark-order "Mark Order" "<p>Does the word that marks the possessum appear before or after it?</p>" ""
	. head-initial "Marker before" "" "before<br>"
	. head-final "Marker after" "" "after<br>"
	. either "Marter either order" "" "either<br>"

        Radio possessum-agr "Possessum agreement" "<p>Does the possessum-marking word or clitic agree with the possessor?</p>" ""
        . agree "Possessum agree" "" "yes<br>" "toggle_element.call(this, 'possessum-agr{i}', 'on'); toggle_element.call(this, 'possessum-non-agr{i}', 'off');"
        . non-agree "Possessum non agree" "" "no<br>"  "toggle_element.call(this, 'possessum-agr{i}', 'off');toggle_element.call(this, 'possessum-non-agr{i}', 'on');"

	Label "<div id='possessum-non-agr{i}' style='display:none'>" 

          Text possessum-orth "Possessum word orth" "<br>The possessum-marking word is spelled " "<br>" 15

        Label "</div>"

        Label "<div id='possessum-agr{i}' style='display:none'>"

	   BeginIter possessum-form{m} "a possessum-marking word with agreement features"

	      Text name "Type name" "Type name: " "-noun-lex<br>" 15

	      Text agr-orth "Orthography agreement" "<br>The form spelled: " "<br> carries the following agreement features:<br>" 15

              BeginIter feat{l} "an agreement feature"
	   
                 Select name "Possessive strategy {i} possessum-marking word Form {k} Feature {l} Name" "Name: " " "
                 fillnames c=noun

                 MultiSelect value "Noun Position Class {i} Lexical Rule Type {j} Form {k} Feature {l} Value" "Value: " ""
                 fillvalues p=poss-strat{i}_possessum-form{m}_feat{l}_name

              EndIter feat

	   EndIter possessum-form

        Label "</div>"

     Label "</div>"

   Label "</div>"                                                                                                                                                                                         

EndIter poss-strat

Label "<p>In some constructions, the possessor can be a pronoun. <b>This pronoun can be either an independent word or an affix.</b> Possessor pronouns which constitute entirely novel forms can be entered as <b>classes of possessor pronouns</b> below. If the possessor pronoun is identical to non-possessive pronouns and can appear in the same contexts as non-pronominal possessors, then it can be covered by adding a possessive strategy using the above button, and indicating that the possessor may be a pronoun. Likewise, if the possessor pronoun is formed by inflecting pronouns in the same manner as common nouns, it can be covered by a possessive strategy above. </p>"

BeginIter poss-pron{i} "a class of possessor pronouns"

  Radio type "Possessive Pronoun Type" "<p>Are these possessor pronouns affixes? Or are they separate words or clitics? </p>" ""
  . affix "affix" "" "affixes<br>" "toggle_element.call(this, 'pron-non-affix{i}', 'off');toggle_element.call(this, 'pron-affix{i}', 'on');"
  . non-affix "non-affix" "" "separate words or clitics<br>" "toggle_element.call(this, 'pron-non-affix{i}', 'on');toggle_element.call(this, 'pron-affix{i}', 'off');"

  Label "<div id='pron-affix{i}' style='display:none'>"

    Radio agr "Pronominal agreement" "<p>Do these affixes agree with the possessum in person, number, or gender?</p>" ""
    . agree "agree" "" "yes<br>"
    . non-agree "non-agree" "" "no<br>"

    Radio mod-spec "Modifier or Specifier" "<p>If your language has determiners, does the possessum noun still appear with a determiner when marked with these affixes?</p>" ""
    . mod "Mod" "" "yes<br>"
    . spec "Spec" "" "no<br>"

    Label "<p>A feature called <span class=\"feat\">poss-pron{i}</span> with possible values <span class=\"tt\">plus</span> and <span class=\"tt\">minus</span> has been defined for use in defining morphemes on the morphology page.  In order to define a pronominal affix, add the appropriate position class and lexical rules, and mark the lexical rules as [<span class=\"feat\">poss-pron{i}</span> <span class=\"tt\">plus</span>]. Be sure to select the feature that corresponds to <span class=\"feat\">poss-pron{i}</span>. Note that any person/number/gender features that are listed on a pronominal affix are assumed to be inherent features of that pronominal affix, rather than agreement features. Agreement features should all be added on this page.</p>"

  Label "</div>"

  Label "<div id='pron-non-affix{i}' style='display:none'>"
  
    Radio order "Possessive Pronoun Order" "<p>Do the possessor pronouns occur to the left or the right of the possessum?</p>" ""
    . head-final "head-final" "" "left<br>"
    . head-initial "head-initial" "" "right<br>"
    . either "either" "" "either<br>"

    Radio mod-spec "Modifier or Specifier" "<p>Does the possessor function more like a modifier or a specifier?</p>" ""
    . mod "Modifier" "" "modifier<br>" 
    . spec "Specifier" "" "specifier<br>"

    Radio agr "Pronominal agreement" "<p>Do these pronouns agree with the possessum in person, number, gender, case, or other features?</p>" ""
    . agree "agree" "" "yes<br>"
    . non-agree "non-agree" "" "no<br>"

    BeginIter  instance{j} "a possessor pronoun instance"

      Text name "Possessive Pronoun Name" "<br>Form name: " "" 15

      Text orth "Possessive Pronoun Orthography" "<br>Form spelling: " "" 15

      Label "<p>Add a feature (e.g. person, number, gender, case) that belongs to this pronoun inherently:</p>"
  
      BeginIter feat{k} "an inherent feature to this pronoun"

         Select name "Possessive pronoun {i} Instance {j} Feature {k} Name" "Name: " " "
         fillnames c=noun

      	 MultiSelect value "Possessive pronoun {i} Instance {j} Feature {k} Value" "Value: " ""
      	 fillvalues p=poss-pron{i}_instance{j}_feat{k}_name

      EndIter feat

      Label "<p>Add any <b>person, number, or gender</b> agreement features to this pronoun that agree with the possessum:</p>"
  
      BeginIter agr-feat{k} "a PNG agreement feature to this pronoun"

         Select name "Possessive pronoun {i}  Instance {j} Feature {k} Name" "Name: " " "
         fillnames c=noun

         MultiSelect value "Possessive pronoun {i} Instance {j} Feature {k} Value" "Value: " ""
         fillvalues p=poss-pron{i}_instance{j}_agr-feat{k}_name

      EndIter agr-feat

      Label "<p>Add any agreement features <b>other</b> than person, number, or gender to this pronoun that agree with the possessum:</p>"

      BeginIter non-png-feat{k} "a non-PNG agreement feature to this pronoun"

         Select name "Possessive pronoun {i}  Instance {j} Feature {k} Name" "Name: " " "
         fillnames c=noun

         MultiSelect value "Possessive pronoun {i} Instance {j} Feature {k} Value" "Value: " ""
         fillvalues p=poss-pron{i}_instance{j}_non-png-feat{k}_name

      EndIter non-png-feat

    EndIter instance

    Radio possessum-mark "Possessum Marked When Possessor is Pronoun" "<p>Does the possessum take any marking when it appears with these possessor pronouns?</p>" ""
    . yes "Yes" "" "yes<br>" "toggle_element.call(this, 'possessum-mark-pron{i}', 'on')"
    . no "No" "" "no<br>" "toggle_element.call(this, 'possessum-mark-pron{i}', 'off')"

    Label "<div id='possessum-mark-pron{i}' style='display:none'>"	

     Radio possessum-mark-type "Possessum morpheme type" "<p>Is the morpheme that marks the <b>possessum</b> an affix? Or is it a separate word or clitic?</p>" ""
     . affix "Possessum affix" "" "affix<br>" "toggle_element.call(this, 'possessum-mark-affix{i}', 'on'); toggle_element.call(this, 'possessum-mark-non-affix{i}', 'off');"
     . non-affix "Possessum non-affix" "" "separate word or clitic<br>"  "toggle_element.call(this, 'possessum-mark-affix{i}', 'off'); toggle_element.call(this, 'possessum-mark-non-affix{i}', 'on');"

     Label "<div id='possessum-mark-affix{i}' style='display:none'>"

       Radio possessum-mark-affix-agr "Possessum agreement" "<p>Does the affix that marks the possessum agree with the possessor (e.g. in person, number, or gender)?</p>" ""
       . agree "Possessum agree" "" "yes<br>"
       . non-agree "Possessum non-agree" "" "no<br>"

       Label "<p>A feature called <span class=\"feat\">poss-pron{i}_possessum</span> with possible values <span class=\"tt\">plus</span> and <span class=\"tt\">minus</span> has been defined for use in defining morphemes on the morphology page. In order to define a possessum-marking affix, add the appropriate position class and lexical rules, and mark the lexical rules as [<span class=\"feat\">poss-pron{i}_possessum</span> <span class=\"tt\">plus</span>]. If you make the possessive marking obligatory (recommended), remember to also create a non-possessive inflecting rule in the same position class by creating a lexical rule type marked [<span class=\"feat\">poss-pron{i}_possessum</span> <span class=\"tt\">minus</span>]. Be sure to select the feature that corresponds to <span class=\"feat\">poss-pron{i}_possessum</span>. If the possessum-marking affix(es) agree(s) with the possessor, add appropriate person, number, and gender features to each lexical rule type. Note that any person/number/gender features that are listed on a possessum lexical rule type are assumed to be features that agree with the possessor.</p>"
	   
     Label "</div>"

     Label "<div id='possessum-mark-non-affix{i}' style='display:none'>"

       Radio possessum-mark-order "Mark Order" "<p>Does the word that marks the possessum appear before or after it?</p>" ""
       . head-initial "Marker before" "" "before<br>"
       . head-final "Marker after" "" "after<br>"
       . either "Marter either order" "" "either<br>"

       Text possessum-orth "Possessum word orth" "<br>The possessum-marking word is spelled " "<br>" 15
	   
      Label "</div>"

    Label "</div>"

  Label "</div>"

EndIter poss-pron


Section direct-inverse "Direct-inverse"

Label "<p>In some languages, the pattern of marking of verbal
arguments (or verbs themselves) is sensitive to a grammatical <span
class=\"dfn\">scale</span> that ranks argument noun phrases according
to how natural they are in the role of agent; for example, a language
might rank animate NPs as more natural agents than inanimate NPs.  In
such languages, transitive sentences in which the agent outranks the
patient are marked differently from those in which the patient
outranks the agent.  Such sentences are said to differ in <span
class=\"dfn\">direction</span>.  Sentences where the agent outranks
the patient are called <span class=\"dfn\">direct</span>, while
sentences where the patient outranks the agent are called <span
class=\"dfn\">inverse</span>.  The difference between direct and
inverse sentences may be marked by a different verb form, by different
cases on the argument NPs, or both.  Creating a direct-inverse scale
here will make available, on the Lexicon page, argument structures for
verbs that are sensitive to the scale, and also the <span
class=\"feat\">direction</span> feature for use in verbal
inflection.</p>"

Label "<p>If your language shows the direct-inverse pattern, please
describe the features that define the scale below.  The scale entries
should be entered in order from the highest (most agent-like) to the
lowest (most patient-like).</p>"

BeginIter scale{i} "a Scale Entry" 1

  Label "<b>Scale entry {i}</b><br>Features:"

  BeginIter feat{j} "a Feature" 0 1

    Select name "Scale entry {i} feature {j} name" "Name: " " "
    fillnames c=noun

    Select value "Scale entry {i} feature {j} value" "Value: " ""
    fillvalues p=scale{i}_feat{j}_name

  EndIter feat

EndIter scale

Select scale-equal "Direction when equal" "<p>When the agent and patient have the same scale value, the main verb is " "<br>(The other form may be something like a reflexive.  If you select \"some other form\", the resulting grammar will not parse sentences where the agent and patient are equally ranked.  You will need to edit the starter grammar manually to add the other form.)</p>"
. direct "Direct" "direct"
. other "Some other form" "some other form"


Section tense-aspect-mood "Tense, Aspect and Mood"

Label "<p>You may define semantic features directly related to
tense, aspect and mood on this page as well as a syntactic feature related
to verb forms. If additional features are needed for defining tense, aspect or mood  in your language,e.g., for defining arbitrary or
quasi-semantic verb classes, you may define them on the Other Features
page.</p>"

Label "<h3>Semantic Features</h3>"
Label "<div style=\"padding-left: 16px\">"

Label "<h4><span class=\"feat\">tense</span></h4>"

Label "Comrie (1985:9) defines <span class=\"dfn\">tense</span> as
\"... grammaticalized expression of location in time\". Which
categories of tense are grammaticalized varies across languages. You
may create a hierarchy of values for the feature <span
class=\"feat\">tense</span> as appropriate for your language. If your
language does not have tense as a grammatical category, leave this
section blank."

Label "You may define a hierarchy of values for the <span
class=\"feat\">tense</span> feature in one of two ways:"

Label "<ul><li>Select among the following common hierarchy elements
and supplement with subtypes as needed, or <li>Build your own
hierarchy.</ul>"

Radio tense-definition "Tense hierarchy definition style" "" ""
. choose "Choose" "" "<strong>Select among common hierarchy elements</strong><br>"

Label "<div style=\"padding-left: 35px\">"

Label "<br>Which of the following are tense hierarchy elements in your
language?<br><br>"

Check past "Past" "" "<b>past</b><br>"
  BeginIter past-subtype{i} "a subtype"
    Text name "Past subtype {i} name" "Subtype: " "" 20
  EndIter past-subtype

Check present "Present" "<br><br>" "<b>present</b><br>"
  BeginIter present-subtype{i} "a subtype"
    Text name "Present subtype {i} name" "Subtype: " "" 20
  EndIter present-subtype

Check future "Future" "<br><br>" "<b>future</b><br>"
  BeginIter future-subtype{i} "a subtype"
    Text name "Future subtype {i} name" "Subtype: " "" 20
  EndIter future-subtype

Check nonpast "Non-Past" "<br><br>" "<b>nonpast</b> &nbsp;&nbsp;&nbsp;&nbsp; <span style=\"font-size:-1\">(note: If present and/or future are also selected they are assumed to be subtypes of nonpast.)<br></span>"
  BeginIter nonpast-subtype{i} "a subtype"
    Text name "Non-Past subtype {i} name" "Subtype: " "" 20
  EndIter nonpast-subtype

Check nonfuture "Non-Future" "<br><br>" "<b>nonfuture</b> &nbsp;&nbsp;&nbsp;&nbsp; <span style=\"font-size:-1\">(note: If present and/or past are also selected they are assumed to be subtypes of nonfuture.)<br></span>"
  BeginIter nonfuture-subtype{i} "a subtype"
    Text name "Non-Future subtype {i} name" "Subtype: " "" 20
  EndIter nonfuture-subtype

Label "</div>"

Radio tense-definition "Tense hierarchy definition style" "" ""
. build "Build" "" "<strong>Build your own <span class=\"feat\">tense</span> hierarchy</strong><br>"

Label "<div style=\"padding-left: 35px\">"
Label "<br>Build your hierarchy from the top down starting with
subtypes of the supertype: tense.<br>"

BeginIter tense{i} "a tense type" 1

  Text name "tense {i} name" "Tense name: " "" 20
  BeginIter supertype{j} "a Supertype" 0 1

    Select name "Tense {i} supertype {j} name" "Supertype: " ""
    fillregex p=tense[0-9]+_name n=1
    . tense "Tense" "tense"

  EndIter supertype

EndIter tense
Label "</div>"

Label "<h4><span class=\"feat\">aspect</span></h4>"

Label "<p>According to Kibort (2008), \"The term 'aspect' designates
the perspective taken on the internal temporal organisation of the
situation, and so 'aspects' distinguish different ways of viewing the
internal temporal constituency of the same situation (Comrie
1976:3ff,...; Bybee 2003:157). The 'situation' is meant here as [a]
general term covering events, processes, states, etc., as expressed by
the verb phrase or the construction. Unlike tense, which is
situation-external time, aspect is situation-internal and non-deictic,
as it is not concerned with relating the time of the situation to any
other time point.\""

Label "<p>\"Aspectual meaning of a clause can be broken up into two
independent aspectual components (Smith 1991/1997): Aspectual
viewpoint [and] Situation type ... .\" Aspectual viewpoint conveys
\"the temporal perspective from which the situation is presented.\"
Situation type \"classifies the situation according to its temporal
properties.\" (Kibort 2008)"

Label "<p>See references below, especially Kibort (2008), for more
detail."

Label "<div style=\"padding-left: 35px\">"

Label "<p><b>Viewpoint Aspect</b>"

Label "<p>Viewpoint aspect is also commonly referred to as grammatical
aspect.  The most common viewpoint opposition is
perfective/imperfective.You may create a hierarchy consisting of only this opposition or you may create a hierarchy of your own, as appropriate for your language. If your language does not have viewpoint aspect (also commonly referred to as grammatical aspect) as a grammatical category, leave this section blank.<br><br>"

Check perimper "Perfective/Imperfective" "" "Create a hierarchy consisting of just the values <b>perfective</b> and <b>imperfective</b> as subtypes of aspect."

Label "<p>Build your own hierarchy of values for the feature <span class=\"feat\">aspect</span>. Note: this is an alternative to choosing the binary opposition above -- if hierarchy elements are defined below the choice above is overridden."

BeginIter aspect{i} "an aspect type" 1

  Text name "aspect {i} name" "Aspect name: " "" 20
  BeginIter supertype{j} "a Supertype" 0 1

    Select name "Aspect {i} supertype {j} name" "Supertype: " ""
    fillregex p=aspect[0-9]+_name n=1
    . aspect "Aspect" "aspect"

  EndIter supertype

EndIter aspect

Label "<p><b>Situation Aspect</b>"

Label "<p>The term \"situation aspect\" overlaps with, or subsumes,
lexical aspect, inherent aspect and some uses of the term
Aktionsart. Situation aspect values may be conveyed by the meaning of
the verb or through overt morphological marking however situation
aspect values may depend on qualities of verbal arguments or
sentential adjuncts (for example). In this case the values are
compositionally derived."

Label "<p><span style=\"color:red\">Note: The implementation of
situation aspect is still under development; There is, as yet, no
implementation of compositionally derived situation aspect. Currently
the <span class=\"feat\">situation</span> feature may be used to
represent inherent lexical qualities or those conveyed through overt
morphological marking. This more accurately reflects uses of the term
\"lexical aspect\".</span></p>"

Label "<p>You may create a hierarchy of values for the feature <span
class=\"feat\">situation</span>, reflecting inherent or
morphologically marked situation aspect. If this is not appropriate
for your language, leave this section blank."

BeginIter situation{i} "a situation type" 1

  Text name "situation {i} name" "Situation name: " "" 20
  BeginIter supertype{j} "a Supertype" 0 1

    Select name "Situation {i} supertype {j} name" "Supertype: " ""
    fillregex p=situation[0-9]+_name n=1
    . situation "Situation" "situation"

  EndIter supertype

EndIter situation

Label "</div>"
Label "</div>"

Label "<div style=\"padding-left: 16px\">"
Label "<h4><span class=\"feat\">mood</span></h4>"

Label "According to Palmer (1986), the term 'mood' is generally used to refer to modality reflected in verbal inflection. The broader category modality is a somewhat vague grammatical category that is quite language specific. However, modality may be roughly described as relating to the opinions or attitudes of the speaker. Modality may include mood (e.g., subjunctive), modal systems and notions of hearsay or evidentiality. While we call this feature <span class=\"feat\">mood</span> it may be used to define values of the broader category of modality, if desired."

Label "You may define values for the feature <span class=\"feat\">mood</span> below. You may select a simple set of values for the feature, reflecting a subjunctive/indicative contrast, or you may define a hierarchy of values for the feature as appropriate for your language. If you would like, you may leave this section blank.<br><br>"

Check subjind "Subjunctive/Indicative" "" "Create a hierarchy consisting of just the values <b>subjunctive</b> and <b>indicative</b> as subtypes of mood."

Label "<p>Build your own hierarchy of values for the feature <span class=\"feat\">mood</span>. Note: this is an alternative to choosing the binary opposition above -- if hierarchy elements are defined below the choice above is overridden."

BeginIter mood{i} "a mood type" 1

  Text name "mood {i} name" "Mood name: " "" 20
  BeginIter supertype{j} "a Supertype" 0 1

     Select name "Mood {i} supertype {j} name" "Supertype: " ""
     fillregex p=mood[0-9]+_name n=1
     . mood "Mood" "mood"

  EndIter supertype

EndIter mood

Label "</div>"

Label "<h4>References</h4>"
Label "<div style=\"font-size:2\">"
Label "<p>Bybee, Joan L. 2003. Aspect. In: Frawley, W.J. (ed.)
International Encyclopedia of Linguistics. Second Edition. Oxford:
OUP. 157-158."
Label "<p>Comrie, Bernard. 1976. Aspect. Cambridge: CUP."
Label "<p>Comrie, Bernard. 1985. Tense. Cambridge: CUP."
Label "<p>Kibort, Anna. \"Aspect.\" Grammatical Features. 7 January
2008. <a
href=\"http://www.features.surrey.ac.uk/features/aspect.html\">http://www.features.surrey.ac.uk/features/aspect.html</a>."
Label "<p>Palmer, Frank R. 1986. Mood and Modality. Cambridge: CUP."
Label "<p>Smith, Carlota. 1997. The Parameter of Aspect. (Second
Edition). Dordrecht: Kluwer Academic Publishers. (Revised version of
Smith, Carlota. 1991. The Parameter of Aspect. Dordrecht: Kluwer
Academic Publishers)."
Label "</div>"

Section evidentials "Evidentials"

Label "<p>Evidentiality refers to the grammatical expression of information source, how the speaker knows what he/she is saying.  Common evidential meanings include \"I heard it from someone else,\" \"I saw it myself,\" \"I inferred it from evidence,\" etc.  Evidentials are most commonly expressed through inflection on the verb or through auxiliary verbs, often described simply as clitics or particles in the literature.</p>"

Label "<p>Here, you may define an inventory of evidential terms.  On the Morphology and Lexicon pages, you may then add an evidential feature either to a lexical rule type on the Morphology page or an auxiliary verb on the Lexicon page.  Note that even though evidentials are specified as features in this interface, in the grammar produced by the Grammar Matrix, evidential semantics will be expressed by an indpendent predicate, not a feature.</p>"

Label "<p>NOTE: For auxiliary verbs expressing evidentials, the evidential feature should be an auxiliary feature, not a complement feature.</p>"

Label "<p>NOTE: For auxiliary verbs expressing evidentials, select \"No predicate.\"  If you specify an evidential feature AND define a predicate for the auxiliary verb, the evidential semantics will overwrite the defined predicate.</p>"

Label "<p>NOTE: You should not specify more than one evidential value on each lexical rule type or auxiliary verb.</p>"

Label "<h3>Semantic Features</h3>"

Label "<div style=\"padding-left: 16px\">"

  Radio evidential-definition "Evidential hierarchy definition style" "" ""
  . noevid "No Evidentiality" "" "<strong>No evidentiality in this language</strong><br>"

  Radio evidential-definition "Evidential hierarchy definition style" "" ""
  . choose "Choose" "" "<strong>Select among common hierarchy elements</strong><br>"

    Label "<div style=\"padding-left: 35px\">"

    Label "<br>Which of the following are evidential hierarchy elements in this subsystem?<br><br>"

    Check firsthand "Firsthand" "" "<b>firsthand</b><br>"

    Check nonfirsthand "NonFirsthand" "" "<b>non-firsthand</b><br>"

    Check visual "Visual" "" "<b>visual</b><br>"

    Check nonvisual "NonVisualSensory" "" "<b>non-visual sensory</b><br>"

    Check inferential "Inferential" "" "<b>inferential</b><br>"

    Check reported "Reported" "" "<b>reported</b><br>"

    Check quoatative "Quotative" "" "<b>quotative</b><br>"

    Check everythingelse "EverythingElse" "" "<b>\"everything else\"</b><br>"

    Label "</div>"

  Radio evidential-definition "Evidential hierarchy definition style" "" ""
  . build "Build" "" "<strong>Specify your own hierarchy</strong><br>"

  BeginIter evidential{i} "an evidential term" 0 0
    Text name "Evidential Term {i} Name" "<b>Evidential Term {i}</b>:<br/>Evidential Term Name: " " " 20
  EndIter evidential

Label "</div>"

Label "<h4>References</h4>"
Label "<div style=\"font-size:2\">"
Label "<p>Aikhenvald, A. (2006). Evidentiality. Oxford linguistics. Oxford University Press."
Label "<p>Murray, S. E. (2017). The Semantics of Evidentials. Oxford University Press."
Label "</div>"

Section other-features "Other Features"

Label "<p>If your language has other features beyond those that can be
defined elsewhere in this questionnaire, you can define those features
here.  For example, if your language has merged features (e.g. <span
class=\"feat\">pernum</span> instead of <span
class=\"feat\">person</span> and <span class=\"feat\">number</span>,
<span class=\"feat\">gendnum</span> instead of <span
class=\"feat\">gender</span> and <span class=\"feat\">number</span>),
they can be defined below.
<br><br>
</p>"

Label "<h3>Syntactic FORM Feature for verbs</h3>"

Label "<p>To start, your
grammar may utilize a syntactic feature characterizing the form the
verb takes. The <span class=\"feat\">form</span> feature distinguishes
finite from non-finite forms and can be used to constrain auxiliary
complement forms and for marking clausal complements (e.g. via morphology).
If not applicable, you may leave this section
blank.</p>"

Label "<p>If you have indicated on the word order page that your
language has auxiliary verbs, your grammar must include
<span class=\"tt\">finite</span> and <span class=\"tt\">nonfinite</span> as values of <span
class=\"feat\">form</span>. If your language does not have auxiliaries
you may still include <span class=\"tt\">finite</span> and <span class=\"tt\">nonfinite</span> as values
of <span class=\"feat\">form</span> in your grammar:<br><br>"

Check form-fin-nf "Finite-nonfinite" "" "Add finite/non-finite FORM feature distinction.</p>"

Label "<p>It is often the case that languages have multiple non-finite
forms, e.g., English: infinitive, past participle, present
participle. If applicable, you may expand the hierarchy of verb <span
class=\"feat\">form</span> values in your grammar by providing
subtypes of <span class=\"tt\">finite</span> and <span class=\"tt\">nonfinite</span>:</p>"


BeginIter form-subtype{i} "a Subtype for FORM"

  Text name "Feature FORM Subtype {i} name" "Name: " "" 20

  MultiSelect supertype "FORM Subtype {i} supertype" " Supertype: " ""
  fillforms

EndIter form-subtype

Label "<p>(Hint: Click Save and Stay to see the supertypes.)</p>"

Label "<h3>Other Syntactic and Semantic Features</h3>"

Label "<p>For each additional feature, you will define a type hierarchy, which
consists of a root type you will name (e.g. <span
class=\"feat\">pernum</span>), and then a series of other values of
the feature, each of which is the subtype of at least one of the other
values, possibly the root.</p>"


Label "<input type=\"hidden\" name=\"existing_value_type1_name\"  value=\"bool\">
<input type=\"hidden\" name=\"existing_value_type2_name\"  value=\"luk\">"

BeginIter feature{i} "a Feature" 1

  Text name "Feature {i} name" "Feature name: " "<br>" 20

  Radio type "Feature {i} type" "Is this feature:<br>" ""
  . head "Head" "" " a syntactic feature (which will go under <span class=\"feat\">head</span>)?<br>"
  . index "Index" "" " a semantic feature (which will go under <span class=\"feat\">index</span>)?<br><br>"

  Radio cat "Feature {i} cat" "Is this feature for:<br>" ""
  . noun "noun" "" " nominal categories?<br>"
  . verb "verb" "" " verbal categories?<br>"
  . both "both" "" " both categories?<br><br>"

  Label "Values in the feature hierarchy:<br>"

  Radio new "Value {i} type" "" ""
  . no "existing" "" " use an existing value type: " "remove_element_all('feature{i}', 'value');"

  Select existing "existing" "" "<br>" "remove_element_all('feature{i}', 'value'); check_radio_button('feature{i}_new', 'no');"
  fillregex p=(existing_value_type[0-9]+_name) n=1
  fillnames2 c=both

  Radio new "Value {i} type" "" ""
  . yes "new" "" " define a new value type<br>" "empty_value('feature{i}_existing', 0);"

  Label "<div id='feature{i}_region'>"

  BeginIter value{j} "a Value" 1

   Text name "Feature {i} Value {j} name" "Value name: " "" 20

    BeginIter supertype{k} "a Supertype" 0 1

      Select name "Feature {i} Value {j} supertype {k} name" "Supertype: " ""
      fillregex p=(feature{i}_name|feature{i}_value[0-9]+_name) n=1

    EndIter supertype

  EndIter value

  Label "</div>"

EndIter feature


Section sentential-negation "Sentential Negation"

Cache verbpcs verb-pc[0-9]+$ name

Label "<p>On this page you can select a strategy that your language uses for sentential negation.
In most cases, morpheme classes that you can further modify will be created on the morphology page.</p>"

Label "<p>Sentential negation constructions can be classified based on the number
of overt morphemes required by the construction.
What's the morphosyntactic exponence of the negation construction you'd like to model?<p>"


Radio neg-exp "neg exp" "" ""
. 0 "0" "" "zero" "set_negexp('0')"
. 1 "1" "" "simple" "set_negexp('1')"
. 2 "2" "" "bipartite" "set_negexp('2')"
. 3 "3" "" "tripartite" "set_negexp('3')"
. more "n" "" "more?!" "set_negexp('more')"

Label "<hr /><a id='anobutton' onclick='toggle_display_lex(\"asymmetric_negation_options\",\"anobutton\")'>&#9658;
asymmetric negation options</a><div id='asymmetric_negation_options' style='display:none'>"


Label "<div id='anhdiv'><a id='anhbutton'
onclick='toggle_display_lex(\"asymmetric_negation_help\", \"anhbutton\")'>&#9658;
asymmetric negation help</a>
<div id='asymmetric_negation_help' style='display:none'><p>Negation
is marked with respect to affirmation (Givón 1984).
In many languages, there are certain tenses/moods/aspects
which are not compatible with negation.
You might model this by enabling a HEAD feature,
[NEGATED luk], set this to '+' on negated verbs and have certain constructions
and/or lexical types specify an incompatible value.</p>

<p>Alternatively, you can have negation specify the values for particular features,
and use an agreement mechanism to trigger the presence of any appropriate marking.
For example, in Maung [mph],  irrealis marking is obligatory with negation.
So you might have the negator specify an AGR feature of irrealis,
then make sure that the head that it is attaching to agrees.</p>

<pre>
ŋi-udba
1sg.3-put
'I put.'

ŋi-udba-ji
1SG.3-put-IRR.NPST
'I can put.'

marig ŋi-udba-ji
NEG 1SG.3-put-IRR.NPST
'I do not put.', 'I cannot put.'

*marig  ŋi-udba
NEG 1SG.3-put
I do not put.
</pre>

</div></div>"
Check neg-head-feature "enable negated head feature" "<p>" "Enable a HEAD feature
([NEGATED luk]) which is appropriate for heads of type verb.<br />"
Label "</div><hr />"


Label "<div id='zero-neg' class='neg_exp_switch' style='display:none'>
<p>Negation without an overt marker.  In some south Dravidian languages such as
(Historical Kannada [kan]), sentential negation was marked by the <em>absence</em>
of the tense marking morpheme that appeared in the corresponding affirmative.
This sort of phenomenon is typologically rare.</p><p>You can model omissive
negation as a phonologically empty inflectional rule ('lexical rule type/instance')
which targets a particular position class in your morphotactic system.
You'll then have to specify at least one other morpheme that canuoccur
in this position class so that negation is indicated by the lack of phonological
material in this position.</p>"

#Select vpc-0-neg "0 neg vpc" "<p>I can create a phonologically
#empty negation affix for you here.  Choose a position class from the verbal
#position classes that you've defined (on the morphology page),
#or choose \"create\" to create a new pc for use with zero neg:" "
#You'll see the result of this choice as a lexical rule instance with no affix and a
#feature called [NEGATION] with the value \"plus\".
#This 'feature' is not a grammatical one---it won't appear in your grammar,
#it only indicates to the customization system that negative semantics should be added
#to this morpheme at customize time.</p>"
#fillcache c=verbpcs
#. create "Create" "create new pc"

Label "</div>"


Label "<div id='uni-neg' class='neg_exp_switch' style='display:none'><p>
Negation can be indicated by the presence of a single negative morpheme.
Your negative morpheme might be bound (negation by inflection) or it might be free
(one of the other choices). Your free negator might be a syntactic head (a verb),
or it might be a dependent (a complement or a modifier).  Specify it's syntax below.</p>"

Check infl-neg "Negation by inflection" "<p>" "Inflectional negation:
Checking this box enables a feature called <span class=\"feat\">negation</span>
with possible value <span class=\"tt\">plus</span> for use in defining morphemes
on the morphology page.  Defining morphemes that specify [<span class=\"feat\">negation</span>
<span class=\"tt\">plus</span>] will produce lexical rules that add the semantics of negation.</p>"

Check neg-aux "Negation by auxiliary verb" "<p>" "Negative auxiliary verb:
Checking this box creates a neg-aux type which contributes a neg_rel that
outscopes it's complement's handle.  This lexical type will show up on the
lexicon page where you'll need to further specify its syntax.</p>"

Text neg-aux-index "index for neg aux" "<span style='display:none'>" "</span>" 1

Check adv-neg "Adverbial negation" "" "An adverb which is a modifier of:<br />"

Radio neg-mod "Negative adverb modifies" "" ""
. s "S" "" "S "
. vp "VP" "" "VP "
. v "V" "" "V "

Radio neg-order "Negative adverb order" "and appears " ""
. before "before" "" "before "
. after "after" "" "after "
. either "either" "" "on either side of the category it modifies.<br>"

Text neg-adv-orth "Negative adverb spelling" "...and which is spelled: " "" 20

Check comp-neg "Negation by selected complement" "<p>" "An adverb like particle
which is a selected complement.  This option will create a non-inflecting lexical
rule that maps plain Vs to Vs which select for negation in addition to their regular COMPS.</p>" "neg_comp()"

Label "<div style='margin-left:10px'>"
Radio comp-neg-head "neg selected by" "Is neg selected by" "<br />"
. aux "aux" "" "a (sub-)class of aux-verbs" "neg_comp()"
. v   "v"   "" "any (finite) verb" "neg_comp()"

Radio comp-neg-order "neg ordered" "How is neg ordered with respect to other COMPS?" "<br />(NB:
After other complements order is only available for non-argument composing auxiliaries.)<br />"
. before "before" "" "before "
. after "after" "" "after "

Text comp-neg-orth "neg spelling" "What's the ORTH value for neg?" "" 20


Label "</div></div>"

Label "<div id='bi-neg' class='neg_exp_switch' style='display:none'>
<p> Negation can be indicated by the required presence of two negative morphemes.
You'll have to specify their morphosyntax and their interactions.</p>"

Hidden bineg-type "bineg type"

Label "<p>We can label the two morphemes NEG1 and NEG2 and ask about the syntactic
properties of each.  Perhaps in your language one of the two negative morphemes
is more closely associated with the contribution of negative force to the sentence,
and the other functions as a resumptive or specifying marker.  Call the primary
indicator of negation NEG1 and the secondary one NEG2.  Please choose the morpheme
type for each exponent of negation:</p>"

Radio neg1-type "NEG1 type" "NEG1" "<br />"
. b "bound" "" "bound" "display_neg_form()"
. fh "free-H" "" "free, syntactic head" "display_neg_form()"
. fc "free-comp" "" "free, syntactic complement" "display_neg_form()"
. fm "free-mod" "" "free, syntactic modifier" "display_neg_form()"



Radio neg2-type "NEG2 type" "NEG2" ""
. b "bound" "" "bound" "display_neg_form()"
. fh "free-H" "" "free, syntactic head" "display_neg_form()"
. fc "free-comp" "" "free, syntactic complement" "display_neg_form()"
. fm "free-mod" "" "free, syntactic modifier" "display_neg_form()"


Label "<div id=\"infl-infl-neg\" class='bineg_switch' style='display:none'>
<p>If both NEG1 and NEG2 are bound to the same root, you can set up the dendency
using the morphotactics system on the morphology page. Only specify that one of your
LRIs is 'negation plus' (you only need one <em>neg_rel</em>), and set up a requires
relation between the two morphemes.</p><p>If NEG1 is bound to an auxiliary and NEG2
is bound to a lexical verb, check the box below.  This will enable several options
for you as you define your lexical rules for NEG1 and NEG2 on the morphology page.
A value for FORM 'negform' will be added to your grammar (as a subtype of nonfinite).
Indicate the lexical rule corresponding to NEG1 by setting [NEGATION +] (this adds the
negative semantics) and the requirement that the complement be [FORM negform].
For the second negator, you can create it in the normal way using the morphology page.
Be sure that the FORM value for your NEG2 morpheme is set to negform.
This will set up the NEG2 lexical rule to change the FORM value on its head to negform.
In this way, auxiliary verbs inflected by NEG1 will require their complement to be headed
by a verb which has been inflected by NEG2.</p>"
Check neg1b-neg2b "neg1 bound to aux requires neg2 bound to lexical verb" "neg1 bound
to aux requires neg2 bound to lexical verb" "</div>"

Label "<div id='infl-head-neg' class='bineg_switch' style='display:none'>
<p>You have selected a negation construction with a negative auxiliary verb
and an inflectional rule.  When you save this page, the negative auxiliary will be
created for you on the lexicon page (where you can further define and constrain its syntax.
A subtype of nonfinite (part of the FORM value hierarchy) called 'negform' has
also been created and your negative auxiliary should select for a complement
which is [FORM negform].  Indicate your negation lexical rule by marking
it as [negation plus] on the morphology subpage.  This rule will change the FORM of
verbs to which it attaches to [FORM negform].</p></div>"

Label "<div id='infl-comp-neg' class='bineg_switch' style='display:none'><p>You have
selected a construction with a negative inflectional rule and a negative selected complement.
Define your lexical rule on the morphology subpage and indicate it with [negation plus].
Please provide some specifics about the negative complement here:</p>"

Radio comp-neg-head-infl-comp-neg "neg selected by" "Is neg selected by" "<br />"
. aux "aux" "" "a (sub-)class of aux-verbs" "neg_comp()"
. v   "v"   "" "any (finite) verb" "neg_comp()"

Radio comp-neg-order-infl-head "neg ordered" "How is neg ordered with resepct
to other COMPS?" "<br />(NB: After other complements order is only available
for non-argument composing auxiliaries.)<br />"
. before "before" "" "before "
. after "after" "" "after "

Text comp-neg-orth "neg spelling" "What's the ORTH value for neg?" "" 20
Label "</div>"

Label "<div id='infl-mod-neg' class='bineg_switch' style='display:none'>
<p>You have selected a negation construction with a negative inflectional
rule and a negative word attached through a head-modifier rule.
Define your lexical rule on the morphology subpage and indicate it with [negation plus].
Please provide some further information about the negative modifier here:</p><p>"

Radio neg-mod-infl-mod-neg "negative adv modifies" "NEG adverb modifies:" "<br />"
. s "S" "" "S "
. vp "VP" "" "VP "
. v "V" "" "V "

Radio neg-mod-order-infl-mod-neg "negative adverb order" "NEG adverb is ordered: " ""
. before "before" "" "before "
. after "after" "" "after "
. either "either" "" "on either side of the category it modifies.<br>"

Text neg-mod-orth "negative adverb spelling" "NEG adverb is spelled: " "" 20
Label "</div>"

Label "<div id='head-head-neg' class='bineg_switch' style='display:none'><p>Two negative heads is not available.  Please contact matrix-dev if you believe this is the best analysis for your language.</p></div>"
Label "<div id='head-comp-neg' class='bineg_switch' style='display:none'><p>You have selected a negative construction with a negative auxiliary verb and a negative selected complement.  When you save the page, the negative auxiliary verb will be created for you on the lexicon page where you can further define its syntax.  Please provide some more information about the negative complement here:</p><p>"

## in head-comp neg, the comp should be a comp of the head (an auxiliary),
## so we don't need this choice
# Radio comp-neg-head "neg selected by" "Is NEG complement selected by" "<br />"
# . aux "aux" "" "a (sub-)class of aux-verbs" "neg_comp()"
# . v   "v"   "" "any (finite) verb" "neg_comp()"

Radio comp-neg-order-head-comp "neg ordered" "How is NEG complement ordered with resepct to other COMPS?" "<br />(NB: After other complements order is only available for non-argument composing auxiliaries.)<br />"
. before "before" "" "before "
. after "after" "" "after "

Text comp-neg-orth "neg spelling" "What's the ORTH value for NEG complement?" "</p>" 20
Label "</div>"

Label "<div id='head-mod-neg' class='bineg_switch' style='display:none'><p>You have selected a negation construction with a negative auxiliary verb and a negative adverb attached through a head-modifier rule.  The negative auxiliary verb will be created for you on the lexicon page where you can further specify its syntax.  Please provide some further information about the negative modifier here:</p>"

Radio neg-mod-head-mod-neg "negative adv modifies" "NEG adverb modifies:" "<br />"
. s "S" "" "S "
. vp "VP" "" "VP "
. v "V" "" "V "

Radio neg-mod-order-head-mod-neg "negative adverb order" "NEG adverb is ordered: " ""
. before "before" "" "before "
. after "after" "" "after "
. either "either" "" "on either side of the category it modifies.<br>"

Text neg-mod-orth "negative adverb spelling" "NEG adverb is spelled: " "" 20
Label "</div>"

Label "<div id='comp-comp-neg' class='bineg_switch' style='display:none'><p>You have selected a construction with two negative complements.  Please provide some further information about the two complements here:</p><p>"

Radio comp-neg1-head "neg1 selected by" "Is NEG1 selected by" "<br />"
. aux "aux" "" "a (sub-)class of aux-verbs" "neg_comp()"
. v   "v"   "" "any (finite) verb" "neg_comp()"

Radio comp-neg1-order "neg1 ordered" "How is NEG1 ordered with resepct to other COMPS?" "<br />(NB: After other complements order is only available for non-argument composing auxiliaries.)<br />"
. before "before" "" "before "
. after "after" "" "after "

Text comp-neg1-orth "neg1 spelling" "What's the ORTH value for NEG1?" "</p><p>" 20

Radio comp-neg2-head "neg2 selected by" "Is NEG2 selected by" "<br />"
. aux "aux" "" "a (sub-)class of aux-verbs" "neg_comp()"
. v   "v"   "" "any (finite) verb" "neg_comp()"

Radio comp-neg2-order "neg2 ordered" "How is NEG2 ordered with resepct to other COMPS?" "<br />(NB: After other complements order is only available for non-argument composing auxiliaries.)<br />"
. before "before" "" "before "
. after "after" "" "after "

Text comp-neg2-orth "neg2 spelling" "What's the ORTH value for NEG2?" "</p>" 20
Label "</div>"

Label "<div id='comp-mod-neg' class='bineg_switch' style='display:none'><p>You have selected a negation construction with a negative complement and a negative modifier.  Please provide some further information here:</p><p>"

Radio comp-neg-head-comp-mod "neg selected by" "Is NEG complement selected by" "<br />"
. aux "aux" "" "a (sub-)class of aux-verbs" "neg_comp()"
. v   "v"   "" "any (finite) verb" "neg_comp()"

Radio comp-neg-order-comp-mod "neg ordered" "How is NEG ordered with resepct to other COMPS?" "<br />(NB: After other complements order is only available for non-argument composing auxiliaries.)<br />"
. before "before" "" "before "
. after "after" "" "after "

Text comp-neg-orth "neg spelling" "What's the ORTH value for the NEG complement?" "</p><p>" 20

Radio neg-mod-comp-mod-neg "negative adv modifies" "NEG adverb modifies:" "<br />"
. s "S" "" "S "
. vp "VP" "" "VP "
. v "V" "" "V "

Radio neg-mod-order-comp-mod-neg "negative adverb order" "NEG adverb is ordered: " ""
. before "before" "" "before "
. after "after" "" "after "
. either "either" "" "on either side of the category it modifies.<br>"

Text neg-mod-orth "negative adverb spelling" "NEG adverb is spelled: " "</p>" 20
Label "</div>"

Label "<div id='mod-mod-neg' class='bineg_switch' style='display:none'><p>You have selected a negation construction with two negative modifiers.  Please provide some further information here:</p><p>"

Radio neg1-mod "negative adv modifies" "NEG1 modifies:" "<br />"
. s "S" "" "S "
. vp "VP" "" "VP "
. v "V" "" "V "

Radio neg1-mod-order "negative adverb order" "NEG1 is ordered: " ""
. before "before" "" "before "
. after "after" "" "after "
. either "either" "" "on either side of the category it modifies.<br>"

Text neg1-mod-orth "negative adverb spelling" "NEG1 is spelled: " "</p>" 20

Radio neg2-mod "negative adv modifies" "NEG2 modifies:" "<br />"
. s "S" "" "S "
. vp "VP" "" "VP "
. v "V" "" "V "

Radio neg2-mod-order "negative adverb order" "NEG2 is ordered: " ""
. before "before" "" "before "
. after "after" "" "after "
. either "either" "" "on either side of the category it modifies.<br>"

Text neg2-mod-orth "negative adverb spelling" "NEG2 is spelled: " "" 20
Label "</div>"

Label "<div id=\"bineg_fb\"></div></div>"

Label "<div id='tri-neg' class='neg_exp_switch' style='display:none'><p> Negation by three morphemes has been reported in some languages of Vanuatu like Lewo [lww].</p></div>"

Label "<div id='x-neg' class='neg_exp_switch' style='display:none'><p>We're not aware of natural languages reported to require more than 3 morphemes as an integral part of a negation construction.  Please send e-mail about this language to the matrix-dev mailing list.</p></div>"

Label "<hr /><p>Notes: This section is under construction.  Expect problems.  Currently, some menu options (under bipartite negation) are only present as previews of future implementations and as of now provide no functionality.</p>"

Label "<h5>References</h5>
<ol>
<li>Givón, Talmy. 1984. <em>Syntax: a typological-functional introduction [vol. III].</em>  John Benjamins. Amsterdam, Philidelphia.</li>
</ol>"



Section coordination "Coordination"

Cache pats (fr|dconj)[0-9]+$ name

Label "<p>Languages can have multiple strategies for marking
coordination that differ among the various parts of speech. The Matrix
supports both lexical and morphological marking of coordination and
several different marking patterns, including:</p>"

Label "<div style=\"padding-left: 16px\"><p><span
class=\"dfn\">Monosyndeton</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;A B
and C&quot; (last coordinand is marked; also allows &quot;A and B and
C&quot;)<br><span
class=\"dfn\">Polysyndeton</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;A
and B and C&quot; (all coordinands but the first are marked)<br><span
class=\"dfn\">Omnisyndeton</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;and
A and B and C&quot; (all coordinands are marked)<br><span
class=\"dfn\">Asyndeton</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;A B
C&quot; (no marking; also known as <span
class=\"dfn\">juxtaposition</span>)</div>"

Label "<p>You may define any number of coordination strategies below.
You may also leave this section blank, in which case the starter
grammar produced will not support coordination.</p>"

BeginIter cs{i} "a Coordination Strategy" 1

  Label "<p>Coordination Strategy {i}:<br>&nbsp;&nbsp;&nbsp;&nbsp;in which"

  Check n "Coordination Strategy {i} coordinates Ns" "" "nouns "
  Check np "Coordination Strategy {i} coordinates NPs" "" "NPs "
  Check vp "Coordination Strategy {i} coordinates VPs" "" "VPs "
  Check s "Coordination Strategy {i} coordinates Ss" "" "sentences<br>"

  Radio pat "Coordination Strategy {i} pattern" "&nbsp;&nbsp;&nbsp;&nbsp;are marked in a " ""
  . mono "Monosyndeton" "" "monosyndeton "
  . poly "Polysyndeton" "" "polysyndeton "
  . omni "Omnisyndeton" "" "omnisyndeton "
  . a "Asyndeton" "" "asyndeton &nbsp; pattern<br>"

  Radio mark "Coordination Strategy {i} mark" "&nbsp;&nbsp;&nbsp;&nbsp;by a " ""
  . word "Word" "" "word "
  . affix "Affix" "" "affix spelled "

  Text orth "Coordination Strategy {i} spelling" "" "" 10

  Radio order "Coordination Strategy {i} order" "that comes " ""
  . before "Before" "" "before "
  . after "After" "" "after the coordinand<br>"

  BeginIter csap{j} "an agreement pattern (optional)" 1

    Select pat "Coordination Strategy {i} agreement name" "&nbsp;&nbsp;&nbsp;&nbsp;and uses the " ""
    fillcache c=pats

    Select target "Coordination Strategy {i} agreement target" "agreement pattern for " ""
      . all "all arguments" "all"
      . subj "subjects only" "subj"
      . obj "objects only" "obj"

  EndIter csap

  Label "</p>"

EndIter cs

Label "<h3 style='display:inline'>Agreement Features in Coordinated Phrases</h3>"

Label "<p>You may describe how agreement features work in coordinated structures. You can then link coordination strategies with a defined agreement pattern. You may also leave this section blank and not attach any agreement patterns to a coordination Type, in which case the top node of coordinated phrases will be underspecified for agreement features.</p>"

Label "<b>Feature Resolution</b>"

Label "<p>In a <b>feature resolution</b> pattern, the feature value of a coordinated phrase is derived from the values of both the child nodes. <p>For example, in many languages, person values follow a hierarchy in which any coordinated phrase with a 1st person conjunct will have 1st person value in the top node, phrases with a 2nd person conjunct (but no 1st person conjunct) will be 2nd person, and phrases with only 3rd person conjuncts will be 3rd person. You may also define feature resolution patterns for features such as gender and number. <p> You'll have to specify the rules that apply to each feature you wish to model.</p>"

BeginIter fr{i} "a feature resolution pattern" 1
  
  Label "<p>(Optionally) give this pattern a name: "
  
  Text name "Feature resolution agreement pattern {i}'s name: " "" "" 10

  Label "<p>This feature resolution pattern uses the following features: <br> "

  BeginIter feat{j} "a Feature"

    Select name "Feature resolution pattern {i} feature {j} name" "Feature: " " "
    fillnames c=noun
    
    BeginIter rule{k} "a Rule"

      MultiSelect left "Feature resolution pattern {i} feature {j} value" "Child 1: " ""
      fillvalues p=fr{i}_feat{j}_name 
        . any "any" "any"  
	. same "the same" "the same" 

      Select right "Feature resolution pattern {i} feature {j} value" "Child 2:" ""
      fillvalues p=fr{i}_feat{j}_name
        . any "any" "any" 
	. same "the same" "the same"  
	. nonmatching "any non-matching value in that list" "any non-matching value in that list"

      Select par "Feature resolution pattern {i} feature {j} value" "Parent: " ""
      fillvalues p=fr{i}_feat{j}_name
        . any "any" "any" 
	. same "the same" "the same"  

    EndIter rule

  EndIter feat

EndIter fr

Label "<p><b>Distinguished Conjunct</b>"

Label "<p>In a <b>distinguished conjunct</b> pattern, the feature value of a coordinated phrase is the same as the value of a particular conjunct. Typically, this conjunct is either the closest one to the verb (closest conjunct), or always in a particular position (first or last conjunct)."

BeginIter dconj{i} "a distinguished conjunct pattern" 1
  
  Label "<p>(Optionally) give this pattern a name: "

  Text name "Distinguished conjunct pattern {i}'s name: " "" "" 10

  Label "<p>This agreement pattern uses agreement features from the<br> "

  Radio order "Coordination Strategy {i} order" "" ""
  . first "Before" "" "first "
  . last "After" "" "last conjunct"
  . closest "After" "" "closest conjunct to the verb"

EndIter dconj


Section matrix-yes-no "Matrix Yes/No Questions"

Label "<p>Please indicate which strategy your language uses to form
matrix yes-no questions.  You may leave this section blank, in which
case your grammar will not include a question-forming strategy.</p>"

Check q-part "" "" "One or more separate question particles:<br>"

Radio q-part-order "Question Particle Position" "which occur: " "<br>"
. before "Before" "" "clause initially "
. after "After" "" "clause finally"
. second "Second Position" "" "second position"

 Check q-part-allopt "<p>" "" "Check if all particles are optional in constituent questions.</p>"

Label "<p>Note: If you mark more than one particle as obligatory below,
only one particle will be licensed per clause; the particles won't iterate.</p>"

BeginIter q-particle{i} "a Question Particle" 1

Text orth "Question particle {i} spelling" "Spelling of question particle: " "<br>" 40

Label "<p>This particle occurs in"

 Check main "Wh-questions in Main Clauses" "" "main"
 Check embed "Wh-questions in Embedded Clauses" "and" "embedded clauses</p>"

 Label "<p>If the particle is not optional:<br> In constituent questions, this particle is:<br>"

 Radio wh "Question particle in Constituent Questions" "" ""
 . oblig "Obligatory" "" "obligatory"
 . imp "Impossible" "" "impossible"

EndIter q-particle

Check q-infl "Inflection" "<p>" "Verbal inflection: Checking this box enables a feature called <span class=\"feat\">question</span> with possible value <span class=\"tt\">polar</span> for use in defining lexical rules on the morphology page.
Defining lexical rules that specify [<span class=\"feat\">question</span> <span class=\"tt\">polar</span>] will produce lexical rules in the grammar that add the semantics of questions.</p>"

Check q-inv "Subject-verb inversion" "" "Subject-verb inversion: "

Radio q-inv-verb "Inverted verb in questions" "" ""
. main "Main" "" "main verbs only "
. aux "Auxiliary" "" "auxiliaries only "
. main-aux "Main and auxiliary" "" "any verb<br>"


Section wh-q "Constituent (wh-) Questions"

Label "<p>Please indicate which strategy your language uses to form
constituent (aka wh-) questions.  You may leave this section blank, in which
case your grammar will not include a wh-question-forming strategy.</p>"

Label "<p>If you fill out this page, you must also fill out the Question Words section on the Lexicon page.</p>"

Label "<h3>Choices regarding the position of question phrases</h3>"

Separator

Radio front-matrix "Fronting" "<p> Question phrases can appear at the left edge of the sentence regardless of the position the questioned constituent would appear in (<i>Who did you see? I know who you saw</i> etc. ):<br>" ""
  . single "Single Fronting" "" "Only one question phrase can be fronted<br>"
  . multi "Multiple Fronting" "" "All question phrases can be fronted<br>"
  . in-situ "In Situ" "" "Question phrases cannot be fronted (stay <i>in situ</i>)<br><br>"

  Radio matrix-front-opt "Fronting optionality" " There is <span class=\"dfn\">obligatory</span> fronting: <br>" ""
  . single-oblig "Obligatory Single Fronting" "" "of at least one question phrase<br>"
  . all-oblig "Obligatory Multiple Fronting" ""  "of all question phrases <br>"
  . none-oblig "No Obligatory Fronting" ""  "fronting is optional <br>"

  #Check embed-insitu "In Situ Embedded Questions" "" "If fronting is optional, it is possible to have embedded in situ questions."

  Label"<p>NB: You may use the optional multiple fronting option to model the syntax of echo questions
   but there is currently no distinction between echo and canonical qiestions
   in the semantic representation that you obtain from this library.</p>"

    Label "<p>There is pied piping of:<br>"

    Check pied-pip "Pied-Piping" "" "noun phrases (<i>Which book did you read?</i> is possible), "
    Check oblig-pied-pip-noun "Obligatory Pied Piping Of Nouns" "" "and it is obligatory (<i>*Which did you read book?</i> is impossible in your language);<br>"
    Check pied-pip-adp "Pied-Piping Of Adpositions" "" "adpositional phrases (<i>To whom did you speak?</i> is possible), "
    Check oblig-pied-pip-adp "Obligatory Pied Piping Of Adpositions" "" "and it is obligatory (<i>*Who did you speak to?</i> is impossible in your language).</p>"

  Separator

 Label "<h3>Other choices</h3>"

 Check no-multi-ques "No Multiple Questions" "<p>" "Only one question phrase is allowed per sentence.</p>"
 Check wh-q-infl "Inflection" "<p>" "Constituent questions are marked morphologically
 (specify lexical rules on the Morphology page).</p>"

Check focus-marking "Information Structure Marking" "<p>" "Question words may bear
 overt focus marking (specify on Information Structure page).</p>"

Label "<p> "
 Check wh-q-inter-verbs "Iterrogative verbs" "" "Interrogative verbs (add appropriate entries on the Lexicon page).</p>"

 Label "<p> If you specified Auxiliary-Subject inversion for polar questions, does it also happen in constituent questions?<br>"
 Check wh-inv-matrix "Matrix Inversion" "" "yes, in matrix clauses <br>"
 Check wh-inv-embed "Embedded Inversion" "" "also in embedded clauses with constituent questions<br>"
 Check wh-inv-notsubj "No Inversion with Questions about Subjects" "" "but not in questions about subjects.</p>"


Section info-str "Information Structure"

Label "<p> Information structure, consisting of topic (what an
utterance is about) and focus (the new information an utterance
provides), refers to how speakers structure the content they wish to
convey to listeners. Different languages use different phonological,
morphological, and syntactic means of marking information structure in
sentences. <br><br>
Note: Modules for constraining positions of information structural components in FREE word order languages are currently under development. If your language uses free word order and multiple positions are checked, the grammar may not work properly. </p>"

Label	"<input type=\"hidden\" name=\"cat_type1_name\" value=\"nouns\">
     	 <input type=\"hidden\" name=\"cat_type2_name\" value=\"verbs\">
         <input type=\"hidden\" name=\"pos_type1_name\" value=\"before\">
         <input type=\"hidden\" name=\"pos_type2_name\" value=\"after\">"

Label "<h3>Focus</h3>"

Radio focus-pos "Focus position" "My language places focused constituents in a specific position. The position is<br>" ""
  . clause-initial "clause-initial" "&nbsp;&nbsp;&nbsp;&nbsp;" "clause-initial.<br> "
  . clause-final "clause-final" "&nbsp;&nbsp;&nbsp;&nbsp;" "clause-final.<br> "
  . preverbal "preverbal" "&nbsp;&nbsp;&nbsp;&nbsp;" "preverbal.<br> "
  . postverbal "postverbal" "&nbsp;&nbsp;&nbsp;&nbsp;" "postverbal.<br> "


BeginIter focus-marker{i} "a Focus Marker" 1

Radio type "Focus {i} marker" "This marker is<br>" ""
  . affix "Affix" "" "an affix (You should create this affix on Morphology.)<br>"
  . adp "Adposition" "" "an adposition (You should create this adposition on Lexicon.)<br>"
  . modifier "Modifier" "" "a modifier"

  MultiSelect pos "Focus {i} marker pos" "and appears" ""
  fillregex p=(pos_type[0-9]_name) n=1

  MultiSelect cat "Focus {i} marker cat" "" ""
  fillregex p=(cat_type[0-9]_name) n=1

  Text orth "Focus {i} marker orth" " Spelling: " "<br>" 10

EndIter focus-marker


Label "<h3>Topic</h3>"

Check topic-first "Specific position for topic" "" "Topic always occurs sentence-initially in my language.<br> "

BeginIter topic-marker{i} "a Topic Marker" 1

Radio type "Topic {i} marker" "This marker is<br>" ""
  . affix "Affix" "" "an affix (You should create this affix on Morphology.)<br>"
  . adp "Adposition" "" "an adposition (You should create this adposition on Lexicon.)<br>"
  . modifier "Modifier" "" "a modifier"

  MultiSelect pos "Topic {i} marker pos" "that appears" ""
  fillregex p=(pos_type[0-9]_name) n=1

  MultiSelect cat "Topic {i} marker cat" "" ""
  fillregex p=(cat_type[0-9]_name) n=1

  Text orth "Topic {i} marker orth" " Spelling: " "<br>" 10

EndIter topic-marker


Label "<h3>Contrastive Focus</h3>"


Check c-focus "Contrastive focus" "" "My language uses the same position to express contrastive focus as non-contrastive focus.<br>" "uncheck_all('c-focus-pos');"

Radio c-focus-pos "Contrastive focus position" "<br>My language places contrastively focused constituents in a specific position. The position is<br>" ""
  . clause-initial "clause-initial" "&nbsp;&nbsp;&nbsp;&nbsp;" "clause-initial.<br> " "uncheck_all('c-focus');"
  . clause-final "clause-final" "&nbsp;&nbsp;&nbsp;&nbsp;" "clause-final.<br> " "uncheck_all('c-focus');"
  . preverbal "preverbal" "&nbsp;&nbsp;&nbsp;&nbsp;" "preverbal.<br> " "uncheck_all('c-focus');"
  . postverbal "postverbal" "&nbsp;&nbsp;&nbsp;&nbsp;" "postverbal.<br> " "uncheck_all('c-focus');"

BeginIter c-focus-marker{i} "a Contrastive Focus Marker" 1

Radio type "Contrastive focus {i} marker" "This marker is<br>" ""
  . affix "Affix" "" "an affix (You should create this affix on Morphology.)<br>"
  . adp "Adposition" "" "an adposition (You should create this adposition on Lexicon.)<br>"
  . modifier "Modifier" "" "a modifier"

  MultiSelect pos "Contrastive focus {i} marker pos" "that appears" ""
  fillregex p=(pos_type[0-9]_name) n=1

  MultiSelect cat "Contrastive focus {i} marker cat" "" ""
  fillregex p=(cat_type[0-9]_name) n=1

  Text orth "Contrastive focus {i} marker orth" " Spelling: " "<br>" 10

EndIter c-focus-marker


Label "<h3>Contrastive Topic</h3>"

BeginIter c-topic-marker{i} "a Contrastive Topic Marker" 1

Radio type "Contrastive topic {i} marker" "This marker is<br>" ""
  . affix "Affix" "" "an affix (You should create this affix on Morphology.)<br>"
  . adp "Adposition" "" "an adposition (You should create this adposition on Lexicon.)<br>"
  . modifier "Modifier" "" "a modifier"

  MultiSelect pos "Contrastive topic {i} marker pos" "that appears" ""
  fillregex p=(pos_type[0-9]_name) n=1

  MultiSelect cat "Contrastive topic {i} marker cat" "" ""
  fillregex p=(cat_type[0-9]_name) n=1

  Text orth "Contrastive topic {i} marker orth" " Spelling: " "<br>" 10

EndIter c-topic-marker


Label "<h4>References</h4>"
Label "<font size=\"2\">"
Label "<p>Lambrecht, Knud. 1996. Information Structure and Sentence Form: Topic, Focus, and the Mental Representations of Discourse Referents. Cambridge, UK: Cambridge University Press.</p>"
Label "<p>Gundel, Jeanette K. 1999. On Different Kinds of Focus. In Peter Bosch and Rob van der Sandt (eds.), Focus: Linguistic, Cognitive, and Computational Perspectives, pages 293-305, Cambridge: Cambridge University Press.</p>"
Label "<p>Krifka, Manfred. 2008. Basic Notions of Information Structure. Acta Linguistica Hungarica 55(3), 243-276.</p>"
Label "<p>Fery, Caroline and Krifka, Manfred. 2008. Information Structure: Notional Distinctions, Ways of Expression. Unity and Diversity of Languages pages 123-136.</p>"
Label "<p>Song, Sanghoun and Bender, Emily M. 2011. Using Information Structure to Improve Transfer-based MT. Proceedings of the 18th International Conference on Head-Driven Phrase Structure Grammar, pages 348-368, Stanford: CSLI Publications.</p>"
Label "<p>Song, Sanghoun and Bender, Emily M. 2012. Individual Constraints for Information Structure. Proceedings of the 19th International Conference on Head-Driven Phrase Structure Grammar, pages 330–348, Stanford: CSLI Publications.</p>"
Label "</font>"



Section arg-opt "Argument Optionality"

Label "<p> Languages place different restrictions on argument
optionality.  Some require that subjects (and objects of transitive
verbs) always be overtly realized as separate words. Others allow
subjects and/or objects to be dropped for all verbs or only for
certain verbs or in particular contexts.  For example, English always
requires overt subjects (<i>I studied</i>) whereas in Arabic the
corresponding sentence does not require a pronoun (<i>darastu</i>).
In languages which allow arugment dropping a marker is often attached
to the verb that contains all of the information that a pronoun
would--person, number, and gender.  This is not always the case,
however.  Japanese for instance allows subject dropping but does not
mark the verb for person, number or gender (Dryer 2008).</p>"

Label "<p>Does your language allow argument optionality?  If so,
choose the option that best describes your language.  If not, leave
this page blank.</p>"
Label "<p> NOTE: The questionnaire is only able to handle subject and
object marking that occurs on the verb.  It is unable to handle
clitics which can attach to words other than the verb.</p>"

Label "<h3>Subject Dropping</h3>"
Label "<p>In some languages subjects can always be dropped and in
others they can only be dropped for certain verbs or in certain
contexts.  Tamil generally allows subject dropping but does not allow
verbs relating to the weather to drop their subjects (Asher 1985).
Arabic allows subjects to be dropped for all verbs, tenses and persons
whereas Hebrew does not allow subjects to be dropped in the present
tense (Vainikka and Levy 1999).  If your language only allows subjects
to be dropped for certain combinations of verb tenses/aspects and
persons/number, please choose the feature values for those
combinations.</p>"

Radio subj-drop "Subject Drop" "<p>Subject dropping can occur </p>" ""
. subj-drop-all "Subj Drop Always" "" "with any verb<br>"
. subj-drop-lex "Subj Drop Some" "" "only with certain verbs"

Label "<p>NOTE: When completing the lexicon page, for each verb type
which does not allow subject dropping, select the feature <span
class=\"feat\">OPT</span> - and marked on the subject.</p>"

Radio subj-mark-drop "Subj Mark Drop" "<p>When a subject is dropped, a subject marker on the verb is</p>" ""
. subj-mark-drop-req "Subj Mark Req" "" "required<br>"
. subj-mark-drop-opt "Subj Mark Opt" "" "optional<br>"
. subj-mark-drop-not "Subj Mark Not" "" "not permitted"

Radio subj-mark-no-drop "Subj Mark No Drop" "<p>When a subject is overt (not dropped), a subject marker on the verb is</p>" ""
. subj-mark-no-drop-req "Subj Mark Req" "" "required<br>"
. subj-mark-no-drop-opt "Subj Mark Opt" "" "optional<br>"
. subj-mark-no-drop-not "Subj Mark Not" "" "not permitted"

Label "<p>NOTE: When completing the morphology page, for each morpheme
that is optional or required when a subject is dropped and not
permitted when an overt subject is present, select <span
class=\"feat\">overt-arg</span> not permitted and marked on the
subject.</p>"

Label "<p> For each morpheme that is not permitted when a subject is
dropped and required or optional when an overt subject is present,
select <span class=\"feat\">drp-arg</span> not permitted and marked on
the subject.</p>"

Label "<p> For each morpheme that is optional when a subject is
dropped and required when an overt subject is present, select
<span class=\"feat\">dropped-arg</span>  permitted and marked
on the subject.</p>"

Label "<p>For each morpheme that is required when a subject is dropped and
optional when an overt subject is present, select
<span class=\"feat\">overt-arg</span> permitted and marked on the subject.</p>"

Radio subj-con  "Subject Context" "<p>Subject dropping occurs in </p>" ""
. subj-con-always "Subj Context All" "" "all contexts<br>"
. subj-con-some "Subj Context Some" "" "some contexts"

Label "<p><b>Contexts</b></p>"

BeginIter context{i} "a Context" 1
  Label "<b>Context {i}</b><br>"
  Label "Features:"

  BeginIter feat{j} "a Feature" 0 1

    Select name "Context {i} feature {j} name" "Name: " " "
    fillnames c=both

    MultiSelect value "Context {i} feature {j} value" "Value: " ""
    fillvalues p=context{i}_feat{j}_name

    Select head "Context {i} feature {j} head" "Specified on: " ""
    . verb "The verb" "the verb"
    . subj "The subject" "the subject NP"
    . obj "The object" "the object NP"
    . higher "Higher-ranked" "the higher-ranked NP"
    . lower "Lower-ranked" "the lower-ranked NP"

  EndIter feat

EndIter context

Label "<h3>Object Dropping</h3>"
Label "<p>Some languages allow all transitive verbs to drop their
objects. In other languages object dropping is restricted to certain
verbs.  English is an example of the latter.  In general transitive
verbs must have an overt object, but there are a few verbs such as eat
which allow object dropping.</p>"

Radio obj-drop "Object Drop" "<p>Object dropping is </p>" ""
. obj-drop-all "Obj Drop Always" "" "always allowed<br>"
. obj-drop-lex "Obj Drop Lex" "" "lexically licensed"

Label "<p>NOTE: When completing the lexicon page, for each verb which does not allow object dropping, select the feature <span
class=\"feat\">OPT</span> - and marked on the object.</p>"

Radio obj-mark-drop "Obj Mark Drop" "<p>When an object is dropped, an object marker on the verb is  </p>" ""
. obj-mark-drop-req "Obj Mark Req" "" "required<br>"
. obj-mark-drop-opt "Obj Mark Opt" "" "optional<br>"
. obj-mark-drop-not "Obj Mark Not" "" "not permitted<br>"

Radio obj-mark-no-drop "Obj Mark Drop" "<p>When an object is overt (not dropped), an object marker on the verb is</p>" ""
. obj-mark-no-drop-req "Obj Mark Req" "" "required<br>"
. obj-mark-no-drop-opt "Obj Mark Opt" "" "optional<br>"
. obj-mark-no-drop-not "Obj Mark Not" "" "not permitted<br>"

Label "<p>NOTE: When completing the morphology page, for each morpheme
that is optional or required when an object is dropped and not
permitted when an overt object is present, select <span
class=\"feat\">overt-arg</span> not permitted and marked on the
object.</p>"

Label "<p> For each morpheme that is not permitted when an object is
dropped and required or optional when an overt object is present,
select <span class=\"feat\">drp-arg</span> not permitted and marked on
the object.</p>"

Label "<p> For each morpheme that is optional when an object is
dropped and required when an overt object is present, select
<span class=\"feat\">dropped-arg</span>  permitted and marked
on the object.</p>"

Label "<p>For each morpheme that is required when an object is dropped and
optional when an overt object is present, select
<span class=\"feat\">overt-arg</span> permitted and marked on the object.</p>"


Label "<h4>References</h4>"
Label "<div style=\"font-size:2\">"
Label "<p>Asher, R.E. 1985. Tamil. London:Croom-Helm.</p>"
Label "<p>Dryer, M. 2008. \"Expression of Pronominal Subjects.\"
WALS. <a
href=\"http://wals.info/feature/description/101\">http://wals.info/feature/description/101</a></p>"
Label "<p> Vainikka, A and Levy, Y. 1999. \"Empty Subjects in Finnish
and Hebrew.\" Natural Language and Linguistic Theory 17: 614-71.</p>"
Label "</div>"

Section nominalclause "Nominalized Clauses"

Label "<p>If your language uses nominalization in the context of clausal complements
and/or clausal modifiers, define the nomminalization strategies here. They will then be available on the Clausal Complements, Clausal Modifers, and Morphology pages.</p>"

BeginIter ns{i} "a Nominalization Strategy" 1

  Text name "Nominalization Strategy {i} Name" "<b>Nominalization Strategy {i}</b>:<br/>Nominalization Strategy Name: " " " 20

    Radio level "Nominalization Strategy {i} Level" "<br><b>The nominalization of the clause happens:</b><br>" ""
  . low "Low" "" "at V"
  . mid "Mid" "" "at VP"
  . high "High" "" "at S"

Radio nmzRel "Nominalization Strategy {i} Relation" "<br><br><b>Is the nominalization syntactic
only or should it also be reflected in the semantics?</b><br>
  (Note: for mid or low nominalization, currently you must say that it is reflected in the semantics).
  </b><br>" ""
    . no "No" "" "Nominalization is syntactic only<br>"
    . yes "Yes" "" "Nominalization should be reflected in the semantics<br>"

EndIter ns

Section clausal-comp "Clausal Complements"

Define strategies for <b>sentential,
or clausal, complements</b> here.<br><br>

Label "<p>You may define several types of object clausal complements below.
You may also leave this section blank, in which case the starter
grammar produced will not support clausal complements.</p>"

Cache otherfeatures feature[0-9]+$ name

BeginIter comps{i} "a Clausal Complement Type" 1

  Label "<p>Clausal Complement Type {i}:<br>&nbsp;&nbsp;&nbsp;&nbsp;in which object complement clauses are placed:<br>"

  Check clause-pos-same "Clause Same Position" "" "in the same position as regular noun complements <br>"
  Check clause-pos-extra "Clause Extraposed" "" "in the extraposed position at the end of sentence.<br>"

  Label "<p> Please indicate whether this complementation strategy is for embedding questions.
  Often times it makes sense to create two completely separate strategies for embedding questions
  and for propositions, and have some clause-embedding verbs (like <i>ask</i>) only be associated
  with one and for other verbs (like <i>know</i>) to have two lexical entries.<br><br>"

  Radio ques "Embedded Clause Type" " This strategy is for embedding " ""
  . prop "Embedded Proposition" "" "propositions, "
  . ques "Embedded Questions" ""  "questions.</p>"


  Label "<p>The complement clauses are marked by
  a complementizer that comes "

  Check comp-pos-before "Complementizer Position Before" "" "before"
  Check comp-pos-after "Complementizer Position After" "" "or after the complement clause"<br>

  Radio comp "Clausal Complement Type {i} comp" " and is " ""
  . opt "Optional Complementizer" "" "optional or"
  . oblig "Obligatory Complementizer" ""  "obligatory.<br>"

  Check comp-q "Question Complementizer" "" "If this strategy is for questions, check if this is a
  <i>whether</i>-like complementizer which turns propositions into questions.<br>"


        BeginIter stem{j} "a Complementizer spelling" 0

                Text orth "comps {i} stem {j} spelling" "Spelling: " "" 30 ""

        EndIter stem

        Label "<p> You can put a FORM feature on the obligatory complementizer if you want to constrain the clausal
        verb in terms of which complementizers it can go with. (Note that all complementizers here
        are still assumed to be semantically empty.)</p>"

        Select cformvalue "Clausal Complement Type {i} Complementizer Form {k} Value" "Form Value: " ""
        fillvalues p=form l=1


  Label "<p> The embedded verb
  has the following features
  e.g. finite, nonfinite form (define in Other Features; we assume that mostly FORM and MOOD will be used;
  you can use custom syntactic but not semantic features; note that subject raising is not yet supported,
  so be careful with infinitives: you will not get the right semantics),
   nominalization (define in Nominalized Clauses):</p>"
  
    BeginIter feat{l} "a Feature"

      Select name "Clausal Complement Type {i} Embedded Verb Feature {l} Name" "Name: " ""
	  fillnames2 c=verb
 
      MultiSelect value "Clausal Complement Type {i} Embedded Verb Feature {l} Value" "Value: " ""
      fillvalues p=comps{i}_feat{l}_name

    EndIter feat

EndIter comps

Separator

Label "<p>
NOTES:
</p>"

Label "<p>
1. The current version
of the questionnaire only covers objectival clausal complements.
</p>"

Label "<p>2. You will need to specify the word order in the complement
clauses on the Word Order page. Currently, only one experimental
case is supported:
V2 order in the matrix and V-final in the subordinate clause, across all
types of subordinate clauses.</p>"

Label "<p>
3. Sorry, no extraposition to sentence-initial position yet! (e.g. SOV becomes OSV).
</p>"


Label "<p>
4. You will need to specify the position classes for the verbal morphology
in the Morphology section.
You will need to specify which verbs can take which type of complement in the Lexicon section.
</p>"

Label "<p>
5. The number of various combinations of choices becomes really large
when more than one complementation strategy is defined. You can specify multiple strategies,
but one-strategy scenario was tested better.
</p>"

Label "<p>
6. You can use different nominalization strategies in different complementation strategies,
but the distinction will have no effect unless there are other things that distinguish
the complementation strategies from each other. Using only nominalization type
to create different complementation strategies is currently not supported. Let us
know if your language does this!
</p>"

Label "<p>
7. The only case frame change that is currently supported is via nominalization.
 It is possible to mock up case change by leaving underlying verbs undespecified for case.
</p>"

Label "<p>
8. More than one complementizer is not yet supported.
</p>"

Label "<p>
9. Participial complements (where the participle is modifying the subject) are not yet supported.
</p>"

Label "<p>
10. Subject raising, equi-deletion are not yet supported.
</p>"



Section clausalmods "Clausal Modifiers"

Label "<p>Languages often have several different strategies for clausal modifers. You may define any number of clausal modifier strategies below or you can leave this page blank, in which case the starter grammar produced will not support clausal modifiers.</p>"

Label "<p>The Grammar Matrix defines clausal modification with three types of subordinators:</p>"

Label "<div style=\"padding-left: 16px\"><p><span
class=\"dfn\">Free Subordinating Morpheme</span><br>&nbsp;&nbsp;&nbsp;&nbsp;A free morpheme
that marks the subordinate clause<br><span
class=\"dfn\">Free Subordinating Morpheme Pair</span><br>&nbsp;&nbsp;&nbsp;&nbsp;A pair of subordinator 
morphemes, one  of which marks the subordinate clause, the other of which marks the matrix clause<br><span
class=\"dfn\">No Free Subordinating Morpheme</span><br>&nbsp;&nbsp;&nbsp;&nbsp;The clausal modifier does not contain a free subordinator morpheme<br></div>"

Label "<p>Clausal modifiers may also be marked by special verbal morphology, nominalization of the subordinate
clause, special word order in the subordinate clause, and subject sharing. You may define any number of 
clausal modifier strategies by combining the free morpheme type with subject sharing and various morphologial constraints.</p>"

Label "<p>Note: Some characteristics of clausal modifiers must be defined on other pages of the grammar matrix.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Special Word order (currently only supported for V2 languages with Vfinal word order in the subordinate clause) should be specified on the word order page<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nominalization strategies should be defined on the Nominalized Clauses page. These stragies can then be added to a clausal modifier strategy under Add a Feature.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Additional features such as finite/non-finite, or features associated with bound subordinator morphemes should be defined on the Other Features page and added to a clausal modifier strategy under Add a Feature.</p>"


BeginIter cms{i} "a Clausal Modifier Strategy" 1

  Label "<p>Clausal Modifier Strategy {i}:<br>"

    Radio position "Clause Position" "The clausal modifier is positioned:<br>" ""
    . before "Before" "" "before the matrix clause<br>"
    . after "After" "" "after the matrix clause<br>"
    . either "Either" "" "either before or after the matrix clause<br><br>"

    Radio modifier-attach "Clause Position" "The clausal modifier attaches to/modifies:<br>" ""
    . vp "VP" "" "a VP<br>"
    . s "S" "" "an S<br>"
    . either "Either" "" "either a VP or an S <br><br>"

    Radio subordinator "Clausal Modifier Strategy {i} pattern" "The subordinate predication is contributed by:<br><br>" ""
  . free "Free Subordinator" "" "a free subordinator morpheme<br>""toggle_element.call(this, 'free{i}', 'on'); toggle_element.call(this, 'pair{i}', 'off'); toggle_element.call(this, 'none{i}', 'off');"
  . pair "Subordinator Pair" "" "a free subordinator morpheme pair: one in the subordinate clause and one in the main clause<br>""toggle_element.call(this, 'free{i}', 'off'); toggle_element.call(this, 'pair{i}', 'on'); toggle_element.call(this, 'none{i}', 'off');"
  . none "No Subordinator" "" "this strategy does not use a free subordinator morpheme""toggle_element.call(this, 'free{i}', 'off'); toggle_element.call(this, 'pair{i}', 'off'); toggle_element.call(this, 'none{i}', 'on');"

    Label "<div id='free{i}' style='display:none'>"
      Radio subposition "Subordinator Position" "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The free subordinator morpheme is positioned:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" ""
      . before "Before" "" "before the VP or S it attaches to<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
    . after "After" "" "after the VP or S it attaches to<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
    . either "Either" "" "either before or after the VP or S it attaches to<br>"

      Radio subordinator-type "Subordinator Type" "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Is the free subordinator morpheme treated as the head of its clause or as and adverbial?:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" ""
     	. head "Head" "" "it is the head of the subordinate clause<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"  "toggle_element.call(this, 'adverb{i}', 'off')"
     	. adverb "Adverb" "" "it is an adverb (not the head of its clause)<br>" "toggle_element.call(this, 'adverb{i}', 'on')"
     
     	   Label "<div id='adverb{i}' style='display:none'>"

	   Radio adverb-attach "Adverb Attach" "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the subordinator is an adverb, does it attach to VP, S or both?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" ""
	   . vp "VP" "" "VP<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
          . s "S" "" "S<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
          . both "Both" "" "Both VP and S"

	   Label "</div>"

      BeginIter freemorph{j} "a Free Subordinator Morpheme" 0 1
        Label "<p>Free Subordinator Morpheme {j}:<br>"
          Text orth "subord {i} stem {j} spelling" "Spelling: " "" 30 "fill_pred('cms{i}_freemorph{j}', 'subord')"
          Text pred "subord {i} stem {j} predicate" " Predicate: " "" 30
      EndIter freemorph
       Label "</div>"

    Label "<div id='pair{i}' style='display:none'>"
      Radio subposition "Subordinator Position" "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Does the morpheme in the subordinate clause attach to the beginning or end of the clause?:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" ""
      . before "Before" "" "before the VP or S it attaches to<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
    . after "After" "" "after the VP or S it attaches to<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
    . either "Either" "" "either before or after the VP or S it attaches to<br>"

      Radio subordinator-type "Subordinator Type" "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Is the morpheme in the subordinate clause treated as the head of its clause or as and adverbial?:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" ""
     	. head "Head" "" "it is the head of the subordinate clause<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"  "toggle_element.call(this, 'pair-adverb{i}', 'off')"
     	. adverb "Adverb" "" "it is an adverb (not the head of its clause)<br>" "toggle_element.call(this, 'pair-adverb{i}', 'on')"
     
     	   Label "<div id='pair-adverb{i}' style='display:none'>"

	   Radio adverb-attach "Adverb Attach" "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the morpheme in the subordinate clause is an adverb, does it attach to VP, S or both?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" ""
	   . vp "VP" "" "VP<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
          . s "S" "" "S<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
          . both "Both" "" "Both VP and S"

	   Label "</div>"

    Radio matrix-subposition "Matrix Subordinator Position" "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Does the morpheme in the matrix clause attach to the beginning or end of the clause?:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" ""
    . before "Before" "" "before the VP or S it attaches to<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
    . after "After" "" "after the VP or S it attaches to<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
    . either "Either" "" "either before or after the VP or S it attaches to<br>"

    Radio matrix-adverb-attach "Matrix Adverb Attach" "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Does the morpheme in the matrix clause attach to VP, S or both?:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" ""
    . vp "VP" "" "VP<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
    . s "S" "" "S<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
    . both "Both" "" "Both VP and S"


      BeginIter morphpair{j} "a Free Subordinator Morpheme Pair" 0 1
        Label "<p>Free Subordinator Morpheme Pair{j}:<br>"
          Text matrixorth "adverb {i} stem {j} spelling" "Matrix Morpheme Spelling: " "" 30 "subpair_matrix_fill_pred('cms{i}_morphpair{j}', 'a')"
          Text matrixpred "adverb {i} stem {j} predicate" " Matrix Morpheme Predicate: " "" 30
          Text subordorth "subord {i} stem {j} spelling" "<br>Subordinate Morpheme Spelling: " "" 30 "subpair_subord_fill_pred('cms{i}_morphpair{j}', 'subord')"
          Text subordpred "subord {i} stem {j} predicate" " Subordinate Morpheme Predicate: " "" 30

      EndIter morphpair
    Label "</div>"

    Label "<div id='none{i}' style='display:none'>"
    Label "The clausal modifier strategy contributes the following predication. (Note: if you do not enter a predication, a generic _subord_rel predication will be added) <br>"
    Text pred "subord {i} stem {j} predicate" "Predicate: " "" 30<br>
    Label "</div>"

Label "<br><br>The clausal modifier has the following features<br> Note: Features can be defined on the Other Features page. If this morphological feature cannot head a matrix clause, it should be defined as a FORM feature.<br>"

BeginIter feat{k} "a Feature"

    Select name "Clausal Modifier Strategy {i} Embedded Verb Feature {k} Name" "Name: " ""
      fillnames2 c=verb
 
    MultiSelect value "Clausal Modifier Strategy {i} Embedded Verb Feature {k} Value" "Value: " ""
      fillvalues p=cms{i}_feat{k}_name

EndIter feat

Label "<br><br>Is the subject of the subordinate clause unexpressed and shared with the subject of the main clause?<br>"
Check shared-subj "Shared Subject" "" "Yes<br>"

EndIter cms


Section lexicon "Lexicon"

Cache nounlrs noun-pc[0-9]+(_lrt[0-9]+)?$ name
Cache verbpcs verb-pc[0-9]+$ name
Cache verblrs verb-pc[0-9]+(_lrt[0-9]+)?$ name
Cache adjlrs adj-pc[0-9]+(_lrt[0-9]+)?$ name
Cache detlrs det-pc[0-9]+(_lrt[0-9]+)?$ name
Cache qverblrs qverb-pc[0-9]+(_lrt[0-9]+)?$ name

Label "<p>On this page you will define <span class=\"dfn\">lexical
types</span> and <span class=\"dfn\">lexical items</span> within those
types.  For most lexical items you must provide both the spelling of
the stem and a <span class=\"dfn\">predicate</span> (or <span
class=\"dfn\">relation</span>) that identifies the stem's semantic
contribution (e.g. <span class=\"tt\">_cat_n_rel</span> for the noun relation
contributed by <i>cat</i> or <span class=\"tt\">_sleep_v_rel</span> for the verb
relation contributed by <i>sleep</i>).  If the predicate is empty
upon adding a spelling the page will create a predicate value based
on the <a href=http://wiki.delph-in.net/moin/RmrsPos>DELPH-IN</a>
standards. If you completed the Argument
Optionality page, be sure to specify whether each verb type allows
subject and or object dropping by selecting the correct value for the
<span class=\"feat\">opt</span> feature.</p>"


Label "<a id=\"toggle_all_lex_button\" onclick=\"toggle_all_display_lex(1)\">&#9660; all sections</a>"

Separator

Label "<h3 style='display:inline'>Noun Types</h3>"
Label "<span>| <a href='javascript:void(0);' onclick=\"draw_hierarchy('noun')\">visualize noun hierarchy</a> (experimental)</span><br />"

Check adj_incorp "adj_incorp" "<p>Some nouns in this language take adjectives as incorporated affixes: " "</p>"

BeginIter noun{i} "a Noun Type" 1 1

  Label "<b>Noun type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Noun {i} name" "Type name: " "<br /><br />" 20

  MultiSelect supertypes "Noun type {i}" "Supertypes: " "<br />"
  fillregex p=noun(?!{i}_)[0-9]+_name

  Check pron "Pronoun" "<br>" "This is a personal pronoun type<br>"
  Check inter "Question Pronoun" "<br>" "This is a question pronoun (like <i>who/what</i>)<br><br>"

  Label "Features:"

  BeginIter feat{j} "a Feature"

    Select name "Noun {i} feature {j} name" "Name: " " "
    fillnames c=noun

    MultiSelect value "Noun {i} feature {j} value" "Value: " ""
    fillvalues p=noun{i}_feat{j}_name

  EndIter feat

  Radio det "Noun {i} determiner" "<p>For nouns of this type, a determiner is: " "</p>"
  . obl "Obligatory" "" " obligatory"
  . opt "Optional" "" " optional"
  . imp "Impossible" "" " impossible"

  Label "Stems:"

  BeginIter stem{j} "a Stem" 0 1

    Text orth "Noun {i} stem {j} spelling" "Spelling: " "" 30 "fill_pred('noun{i}_stem{j}', 'n')"

    Text pred "Noun {i} stem {j} predicate" " Predicate: " "" 30

  EndIter stem

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Noun {i} Requires" "Noun {i} requires one of the following: " ""
    fillcache c=nounlrs

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Noun {i} Forbids" "Noun {i} forbids the following position class: " ""
    fillcache c=nounlrs

  EndIter forbid

  Label "</div>"

EndIter noun

Separator

Label "<h3 style='display:inline'>Verb Types</h3>"
Label "<span>| <a href='javascript:void(0);' onclick=\"draw_hierarchy('verb')\">visualize verb hierarchy</a> (experimental)</span><br />"

BeginIter verb{i} "a Verb Type" 1 2

  Label "<b>Verb type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Verb {i} name" "Type name: " "<br /><br />" 20

  MultiSelect supertypes "Verb type {i}" "Supertypes: " "<br /><br />"
  fillregex p=verb(?!{i}_)[0-9]+_name

  Label "Features:"

  BeginIter feat{j} "a Feature"

    Select name "Verb {i} feature {j} name" "Name: " " "
    fillnames c=both

    MultiSelect value "Verb {i} feature {j} value" "Value: " ""
    fillvalues p=verb{i}_feat{j}_name

    Select head "Verb {i} feature {j} head" "Specified on: " ""
    . verb "The verb" "the verb"
    . subj "The subject" "the subject NP"
    . obj "The object" "the object NP"
    . higher "Higher-ranked" "the higher-ranked NP"
    . lower "Lower-ranked" "the lower-ranked NP"

  EndIter feat

  Select valence "Verb {i} arguments" "<br /><br />Argument structure: " "<br />"
  fillverbpat

  Select bipartitepc "Verb {i} bipartite stems position class" "If this verb class includes bipartite stems, select the position class for the affix portion of the stems: " "<br />"
  fillcache c=verbpcs

  Label "Stems:"
  BeginIter stem{j} "a simple Stem" 0 1

    Text orth "Verb {i} stem {j} spelling" "Spelling: " "" 30 "fill_pred('verb{i}_stem{j}', 'v')"

    Text pred "Verb {i} stem {j} predicate" " Predicate: " "" 30

  EndIter stem

  BeginIter bistem{j} "a bipartite Stem"

    Text orth "Verb {i} bipartite stem {j} spelling" "Root spelling: " "" 30 "fill_pred('verb{i}_bistem{j}', 'v')"

    Text aff "Verb {i} bipartite stem {j} affix" "Affix spelling: " "" 30

    Text pred "Verb {i} bipartite stem {j} predicate" " Predicate: " "" 30

  EndIter bistem

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Verb {i} requires" "Verb {i} requires one of the following position classes: " ""
    fillcache c=verblrs

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Verb {i} forbids" "Verb {i} forbids the following position class: " ""
    fillcache c=verblrs

  EndIter forbid

  Label "</div>"

EndIter verb

Separator

Label "<h3 style='display:inline'>Question Verb Types</h3>"
Label "<span>| <a href='javascript:void(0);' onclick=\"draw_hierarchy('verb')\">visualize verb hierarchy</a> (experimental)</span><br />"

BeginIter qverb{i} "a Question Verb Type" 0 0

  Label "<b>Question Verb type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Question Verb {i} name" "Type name: " "<br /><br />" 20

  MultiSelect supertypes "Question Verb type {i}" "Supertypes: " "<br /><br />"
  fillregex p=qverb(?!{i}_)[0-9]+_name

  Label "Features:"

  BeginIter feat{j} "a Feature"

    Select name "Question Verb {i} feature {j} name" "Name: " " "
    fillnames c=both

    MultiSelect value "Question Verb {i} feature {j} value" "Value: " ""
    fillvalues p=qverb{i}_feat{j}_name

    Select head "Question Verb {i} feature {j} head" "Specified on: " ""
    . verb "The verb" "the verb"
    . subj "The subject" "the subject NP"
    . obj "The object" "the object NP"
    . higher "Higher-ranked" "the higher-ranked NP"
    . lower "Lower-ranked" "the lower-ranked NP"

  EndIter feat

  Label "<p>There is no predefined case frame for question verbs. Please specify the case for the subject above.</p>"

  Radio predtype "Question Verb {i} stem {j} second predicate type" "<p>The second
  predicate that this verb contributes is <br>" "</p>"
  . ref "Referential" "" " referential (<i>thing, person</i>) <br>"
  . loc "Location" "" " location in time/space (<i>when, where</i>)<br>"
  . manner "Manner" "" " manner (<i>how</i>)<br>"

  Label "Stems:"
  BeginIter stem{j} "a simple Stem" 0 0

    Text orth "Question Verb {i} stem {j} spelling" "Spelling: " "" 30

    Text verbpred "Question Verb {i} stem {j} verbpred" " Event predicate (e.g. <i>do</i>): " "" 30

    Text nounpred "Question Verb {i} stem {j} nounpred" "<br>Specify (e.g. <i>thing, place, time</i>): " "" 30

  EndIter stem

  BeginIter bistem{j} "a bipartite Stem"

    Text orth "Question Verb {i} bipartite stem {j} spelling" "Root spelling: " "" 30 "fill_pred('qverb{i}_bistem{j}', 'v')"

    Text aff "Question Verb {i} bipartite stem {j} affix" "Affix spelling: " "" 30

    Text pred "Question Verb {i} bipartite stem {j} predicate" " Predicate: " "" 30

  EndIter bistem

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Question Verb {i} requires" "Verb {i} requires one of the following position classes: " ""
    fillcache c=verblrs

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Question Verb {i} forbids" "Verb {i} forbids the following position class: " ""
    fillcache c=verblrs

  EndIter forbid

  Label "</div>"

EndIter qverb

Separator

Label "<h3 style='display:inline'>Adjective Types</h3>"
Label "<span>| <a href='javascript:void(0);' onclick=\"draw_hierarchy('adj')\">visualize adjective hierarchy</a> (experimental)</span><br />"

BeginIter adj{i} "an Adjective Type" 1

  Label "<b>Adjective type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Adjective {i} name" "Type name: " "<br /><br />" 20

  MultiSelect supertypes "Adjective type {i}" "Supertypes: " "<br />"
  fillregex p=adj(?!{i})[0-9]+_name

  Label "<p>Adjectives in constructions are described as <span class=\"dfn\">attributive</span>:
  those that modify nouns (e.g. \"the <b>big</b> dog\"); <br>
  and <span class=\"dfn\">predicative</span>, those that predicate their subject (e.g. \"the dog is <b>big</b>\").
  <br>Many adjectives in many languages can be both predicative or attributive.</p>"

  Radio mod "Adjective {i} structure" "<p>This type of adjective is " "</p>"
  . attr "attributive" "" "attributive "
  . pred "predicative" "" "predicative "
  . both "both" "" "both "
  . none "unspecified" "" "unspecified"

  Label "<p>Features:<br>  Specify agreement features of the adjective by selecting one of the argument choices;<br>  specify inflection for predicative adjectives by selecting a feature to be specified on \"the adjective\".<br></p>"

  BeginIter feat{j} "a Feature"

    Select name "Adjective {i} feature {j} name" "Name: " " "
    fillnames c=both

    MultiSelect value "Adjective {i} feature {j} value" "Value: " ""
    fillvalues p=adj{i}_feat{j}_name

    Select head "Adjective {i} feature {j} head" "Specified on: " "" "" "toggle_element.call(this, 'adj{i}_adj_pc_note', 'on', ['subj', 'mod']); check_radio_button.call(this, 'adj{i}_mod', 'last', ['subj', 'mod']);"
    . adj "The adjective" "the adjective"
    . subj "The subject" "the subject NP"
    . mod "The modified noun" "the modified NP"
    . xarg "Both positions" "both"

  EndIter feat

  Label "<p id='adj{i}_adj_pc_note' style='display:none;'>  NOTE: Specifying agreement features on \"the subject\" or \"the modified noun\" will create a new<br>  position class on the Morphology page with specified features on \"both positions\" and without an affix<br>  to facilitate this functionality.<br>  The type of this adjective has also been changed to 'unspecified' to support this. Specify adjective types<br>  on the Morphology page when using this feature.<br></p>"

  Radio modpos "Adjective {i} attributive structure" "<p>This type of adjective behaving
  attributively modifies items immediately <br>" "</p>"
  . after "After-modifying" "" " after the adjective <br>"
  . before "Before-modifying" "" " before the adjective <br>"
  . either "Either-modifying" "" " either position <br>"
  . other "Other-mod" "" " some other position: this option is not currently supported" "" x

  Check modunique "Adjective {i} unique modification" "" " This type of adjective behaving
  attributively must be the only modifier of its modificand"

  Radio predcop "Adjective {i} predicative structure" "<p>Adjectives of this type behaving predicatively appear as the complement of a copula:<br>" "</p>"
  . obl "Obligatorily" "" " obligatorily<br>"
  . opt "Optionally" "" " optionally<br>" "toggle_element.call(this, 'adj{i}_opt_note', 'on')"
  . imp "Impossibly" "" " impossibly<br>"

  Label "<p id='adj{i}_opt_note' style='display:none;'>  NOTE: Specifying adjectives as optionally appearing as a copula complement will create a<br>  new position class on the Morphology page with a \"copula complement\" lexical rule and <br>\"stative predicate\" lexical rule to facilitate this functionality.<br></p>"

  Label "Stems:"
  BeginIter stem{j} "a Stem" 0 1

    Text orth "Adjective {i} stem {j} spelling" "Spelling: " "" 30 "fill_pred('adj{i}_stem{j}', 'a')"

    Text pred "Adjective {i} stem {j} predicate" " Predicate: " "" 30

  EndIter stem

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Adjective {i} requires" "Adjective {i} requires one of the following position classes: " ""
    fillcache c=adjlrs

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Adjective {i} forbids" "Adjective {i} forbids the following position class: " ""
    fillcache c=adjlrs

  EndIter forbid

  Label "</div>"

EndIter adj

Separator

Label "<h3>"
Label auxlabel "Auxiliary Verb and Copula Types</h3>"

  Label "<p>Auxiliaries may contribute an independent predicate, e.g.,
  English modal <i>can</i>. If you define a type that contributes a
  predicate, you may also specify semantic feature values on the
  auxiliary, if desired. Alternatively, auxiliaries may contribute no
  predicate of their own, e.g., English auxiliary <i>be</i>. In this
  case, they do not directly contribute semantic values; instead, they
  may contribute indirectly by placing constraints on their
  complements.  Note that auxiliary features defined here place no
  constraints on the semantic values of the complement; constraints on
  the complement should be defined as complement features.</p>"

BeginIter aux{i} "an Auxiliary Type" 1

  Label "<b>Auxiliary type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Aux {i} type name" "Type name: " "<br>" 30

  Label "<br>This auxiliary type contributes:"

  Label "<div style=\"padding-left: 25px\">"

  Radio sem "Aux {i} semantics" "" ""
  . no-pred "No predicate" "" "No predicate.<br>"
  . add-pred "Predicate" "" "An independent predicate."

  Label "</div>"

  Label "<br>Auxiliary features:"

  BeginIter feat{j} "an auxiliary feature"

     Select name "Aux {i} feature {j} name" "Name: " ""
     fillnames c=both

     MultiSelect value "Aux {i} feature {j} value" "Value: " ""
     fillvalues p=aux{i}_feat{j}_name

     Select head "Aux {i} feature {j} head" "Specified on: " ""
     . verb "The auxiliary" "the auxiliary"
     . subj "The subject" "the subject NP"

  EndIter feat

  Label "<br><br>"

  Radio subj "Aux {i} subject" "If this auxiliary type takes a VP or V complement, select the subject type:<br>" ""
  . np "Noun phrase" "" "noun phrase without case restrictions <br>"
  . np-comp-case "NP comp case" "" "noun phrase bearing the case the verbal complement assigns to its subject <br>"
  . np-aux-case "NP aux case" "" "noun phrase, receiving the following case from its auxiliary: "

  Select subj_case "Aux {i} subject-case" "" ""
  fillvalues p=case l=1

  Radio subj "Aux {i} subject" "" ""
  . adp "Adpositional phrase" "<br>" "adpositional phrase<br><br>"

  Label complabel "Complement Features:&nbsp; &nbsp; &nbsp; &nbsp; (Note: A
  value for the feature FORM is required.)<br>"

  BeginIter compfeature{j} "a complement feature" 0 1

    Select name "Aux {i} complement feature {j} name" "Name: " ""
    fillnames c=verb

    MultiSelect value "Aux {i} complement feature {j} value" "Value: " ""
    fillvalues p=aux{i}_compfeature{j}_name

  EndIter compfeature

  Label "<br><br>Stems:"

  BeginIter stem{j} "a Stem" 0 1

    Text orth "Aux {i} stem {j} spelling" "Spelling: " "" 30 "aux_fill_pred('aux{i}', 'stem{j}', 'v')"

    Text pred "Aux {i} stem {j} predicate" "&nbsp;&nbsp;&nbsp;&nbsp;Predicate (if applicable): " "" 30

  EndIter stem

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Aux {i} requires" "Aux {i} requires one of the following position classes: " ""
    fillcache c=verblrs

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Aux {i} forbids" "Aux {i} forbids the following position class: " ""
    fillcache c=verblrs

  EndIter forbid

  Label "</div>"

EndIter aux

Label "<p>Define a copula to introduce complements.</p>"

Label "<span><a href='javascript:void(0);' onclick=\"draw_hierarchy('cop')\">visualize copula hierarchy</a> (experimental)</span><br /><br />"

BeginIter cop{i} "a Copula Type" 1

  Label "<b>Copula type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Cop {i} type name" "Type name: " "<br>" 30

  Label "<br />"

  MultiSelect supertypes "Copula type {i}" "Supertypes: " "<br />"
  fillregex p=cop(?!{i})[0-9]+_name

  Label "<br />Complement Type: What kind of complements does this copula allow?<br />"

  MultiSelect comptype "Cop {i} comptype" "Type: " ""
  fillvalues p=cop{i}_feat{j}_name
  . np "NPs" "NPs" "" x
  . pp "PPs" "PPs" "" x
  . ap  "APs" "APs"

  Label "<br /><br />Copula features:"

  BeginIter feat{j} "a copula feature"

     Select name "Cop {i} feature {j} name" "Name: " ""
     fillnames c=both

     MultiSelect value "Cop {i} feature {j} value" "Value: " ""
     fillvalues p=cop{i}_feat{j}_name

     Select head "Cop {i} feature {j} head" "Specified on: " ""
     . cop "The copula" "the copula"
     . subj "The subject" "the subject NP"
     . comp  "The complement" "the complement"

  EndIter feat

  Label "<br><br>Stems:"

  BeginIter stem{j} "a Stem" 0 1

    Text orth "Cop {i} stem {j} spelling" "Spelling: " "" 30 "aux_fill_pred('cop{i}', 'stem{j}', 'v')"

  EndIter stem

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Cop {i} requires" "Copula {i} requires one of the following position classes: " ""
    fillcache c=verblrs

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Aux {i} forbids" "Copula {i} forbids the following position class: " ""
    fillcache c=verblrs

  EndIter forbid

  Label "</div>"

EndIter cop

Separator

Label "<h3>Determiners</h3>"

BeginIter det{i} "a Determiner" 1

  Label "<b>Determiner type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Determiner {i} name" "Type name: " "<br>" 20

  Check inter "Interrogative Determiner" "<br>" "This is a question determiner (like <i>which</i>) <br><br>"

  BeginIter stem{j} "a Stem" 0 1

    Text orth "Determiner {i} spelling" "Spelling: " "" 30 "fill_pred('det{i}_stem{j}', 'q')"

    Text pred "Determiner {i} predicate" " Predicate: " "<br>" 30

  EndIter stem

  Label "<br><br>Features:"

  BeginIter feat{j} "a Feature"

    Select name "Determiner {i} feature {j} name" "Name: " " "
    fillnames c=noun

    MultiSelect value "Determiner {i} feature {j} value" "Value: " ""
    fillvalues p=det{i}_feat{j}_name

  EndIter feat

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Determiner {i} requires" "Determiner {i} requires one of the following position classes: " ""
    fillcache c=detlrs

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    MultiSelect others "Determiner {i} requires" "Determiner {i} requires one of the following position classes: " ""
    fillcache c=detlrs

  EndIter forbid

  Label "</div>"

EndIter det

Separator

Label "<h3>Adverbs</h3>"


BeginIter adv{i} "an Adverb" 1

  Label "<b>Adverb type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Adverb {i} name" "Type name: " "<br>" 20

  BeginIter stem{j} "a Stem" 0 1

    Text orth "Adverb {i} spelling" "Spelling: " "" 30 "fill_pred('adv{i}_stem{j}', 'a')"

    Text pred "Adverb {i} predicate" " Predicate: " "<br>" 30

  EndIter stem

  Check inter "Interrogative Adverb" "<br>" "This is a question adverb (like <i>where/when</i>) <br><br>"

      Radio type "Adverb {i} Type" "This is a " " adverb."
      . loc "Location in Time or Space" "" "location in time/space"
      . manner "Manner" "" "manner"

  Label "</div>"

EndIter adv

Label "<p>Note that the adverbs are not yet fully supported and will be underspecified as to where they attach.</p>"


Separator

Label "<h3>Adpositions</h3>"

BeginIter normadp{i} "an Adposition" 0

    BeginIter stem{j} "a Stem" 0 1

      Text orth "Adposition {i} spelling" "Spelling: " "" 30 "fill_pred('normadp{i}_stem{j}', 'p')"

      Text pred "Adposition {i} predicate" " Predicate: " "<br>" 30

      Select form "Adposition {i} Form {k} Value" "Form Value: " ""
        fillvalues p=form l=1

    EndIter stem

  Select order "Adposition {i} order" " <br><br> The adposition appears " " a noun phrase<br><br>Features:<br>"
  . after "After" "after"
  . before "Before" "before"
  . both "Before and After" "before and after"

  BeginIter feat{j} "a Feature on Adposition's Complement" 0 0

    Select name "Adposition {i} feature {j} name" "Name: " " "
    fillnames c=noun

    MultiSelect value "Adposition's Complement {i} feature {j} value" "Value: " ""
    fillvalues p=normadp{i}_feat{j}_name

  EndIter feat


EndIter normadp


BeginIter adp{i} "a Case-marking and/or Information Structural Adposition" 1

  Text orth "Adposition {i} spelling" "Spelling: " "" 20

  Check opt "Adposition {i} optional" ", which is " " optional"

  Select order "Adposition {i} order" " and appears " " a noun phrase<br><br>Features:<br>"
  . after "After" "after"
  . before "Before" "before"

  BeginIter feat{j} "a Feature" 0 1

    Select name "Adposition {i} feature {j} name" "Name: " " "
    fillnames c=noun

    MultiSelect value "Adposition {i} feature {j} value" "Value: " ""
    fillvalues p=adp{i}_feat{j}_name

  EndIter feat

EndIter adp



Section morphology "Morphology"

Cache nouns noun[0-9]+$ name
Cache verbs verb[0-9]+$ name
Cache qverbs qverb[0-9]+$ name
Cache auxes aux[0-9]+$ name
Cache dets q?det[0-9]+$ name
Cache adjs adj[0-9]+$ name
Cache cops cop[0-9]+$ name

Label "<p>Here you can define inflectional morphology for nouns, verbs, and
determiners.  To do so, first define one or more inflectional <span
class=\"dfn\">position classes</span>, which determine the order in which
morphemes appear, then define one or more <span class=\"dfn\">lexical rule
types</span> (LRTs) that can appear in each position class, along with the
<span class=\"dfn\">features</span> specified by each LRT.  To determine the
order of position classes, you must define one or more <span
class=\"dfn\">inputs</span> for each.  For LRTs that attach directly to stems,
the input will be a lexical type; for LRTs that attach to already-inflected
stems, the input will be another position class.</p>"

Label "<a id=\"toggle_all_lex_button\" onclick=\"toggle_all_display_lex(1)\">&#9660; all sections</a>"

Label "<h3>Noun Inflection</h3>"

BeginIter noun-pc{i} "a Position Class" 1 0

  Text name "Noun Position Class {i} Name" "<b>Noun Position Class {i}</b>:<br/>Position Class Name: " " " 20

  Check obligatory "Noun Position Class {i} Obligatory" "<br/>Obligatorily occurs:" ""

Select order "Noun Position Class {i} Order" "<br/>Appears as a prefix or suffix:" ""
. prefix "Prefix" "prefix"
. suffix "Suffix" "suffix"

  MultiSelect inputs "Noun Position Class {i} Input" "<br/>Possible inputs:" ""
  fillcache c=nouns
  fillregex p=(verb|noun)-pc[0-9]+(_lrt[0-9]+)?_name
  . noun "Any noun" "any noun"

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Noun Position Class {i} Requires" "Noun Position Class {i} requires one of the following: " ""
    fillcache c=nouns
    fillregex p=noun-pc[0-9]+(_lrt[0-9]+)?_name
    . noun "Any noun" "any noun"

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Noun Position Class {i} Forbids" "Noun Position Class {i} forbids the following: " ""
    fillcache c=nouns
    fillregex p=noun-pc[0-9]+(_lrt[0-9]+)?_name
    . noun "Any noun" "any noun"

  EndIter forbid

  Label "<p>Lexical Rule Types that appear in this Position Class:</p>"

  BeginIter lrt{j} "a Lexical Rule Type" 1 0

    Text name "Noun Position Class {i} Lexical Rule Type {j} Name" "<b>Lexical Rule Type {j}</b>:<br/>Name: " "" 20

    MultiSelect supertypes "Noun Position Class {i} Lexical Rule Type {j} Supertype" "<br/>Supertypes: " ""
    fillregex p=noun-pc{i}_lrt[0-9]+_name

    Label "<p>Features:<br>Note: most nominal features are inherent to the noun, and should therefore be marked as 'specified on itself.' However, in some possessive constructions, a noun will agree with its possessum or possessor in some features. This should be indicated in the 'specified on' field below. </p>"

    BeginIter feat{k} "a Feature"

      Select name "Noun Position Class {i} Lexical Rule Type {j} Feature {k} Name" "Name: " " "
      fillnames c=both

      MultiSelect value "Noun Position Class {i} Lexical Rule Type {j} Feature {k} Value" "Value: " ""
      fillvalues p=noun-pc{i}_lrt{j}_feat{k}_name

      Select head "Noun Position Class {i} Lexical Rule Type {j} Feature {k} Head" "Specified on: " ""
      . itself "Itself" "itself"
      . possessor "Possessor" "possessor"
      . possessum "Possessum" "possessum"

    EndIter feat

    Label "<p>Morphotactic Constraints:</p>"

    BeginIter require{k} "a Require constraint"

      MultiSelect others "Noun Position Class {i} Lexical Rule Type {j} Requires" "Lexical Rule Type {j} requires one of the following: " ""
      fillcache c=nouns
      fillregex p=noun-pc[0-9]+(_lrt[0-9]+)?_name
      . noun "Any noun" "any noun"

    EndIter require

    BeginIter forbid{k} "a Forbid constraint"

      Select others "Noun Position Class {i} Lexical Rule Type {j} forbids" "Lexical Rule Type {j} forbids the following: " ""
      fillcache c=nouns
      fillregex p=noun-pc[0-9]+(_lrt[0-9]+)?_name
      . noun "Any noun" "any noun"

    EndIter forbid

    Label "<p>Lexical Rule Instances:</p>"

    BeginIter lri{k} "a Lexical Rule Instance" 0 1

      Radio inflecting "Noun Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Has Orthography" "Instance {k}" ""
      . no "No" "" "No affix"
      . yes "Yes" "" "Affix spelled"

      Text orth "Noun Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Spelling" "" "" 20

    EndIter lri

  EndIter lrt

  BeginIter is-lrt{j} "an Incorporated Stem Lexical Rule Type" 1 0 "adj_incorp"

    Text name "Noun Position Class {i} Lexical Rule Type {j} Name" "<b>Incorporated Stem Lexical Rule Type {j}</b>:<br/>Name: " "" 20

    MultiSelect supertypes "Noun Position Class {i} Lexical Rule Type {j} Supertype" "<br/>Supertypes: " ""
    fillregex p=noun-pc{i}_is-lrt[0-9]+_name

    Label "<p>Features:</p>"

    BeginIter feat{k} "a Feature"

      Select name "Noun Position Class {i} Lexical Rule Type {j} Feature {k} Name" "Name: " " "
      fillnames c=noun

      MultiSelect value "Noun Position Class {i} Lexical Rule Type {j} Feature {k} Value" "Value: " ""
      fillvalues p=noun-pc{i}_is-lrt{j}_feat{k}_name

      Select head "Noun Position Class {i} Lexical Rule Type {j} Feature {k} Head" "Specified on: " ""
      . dtr "The noun" "the noun"
      . adj "The adjective" "the adjective"

    EndIter feat

    Label "<p>Morphotactic Constraints:</p>"

    BeginIter require{k} "a Require constraint"

      MultiSelect others "Noun Position Class {i} Lexical Rule Type {j} Requires" "Lexical Rule Type {j} requires one of the following: " ""
      fillcache c=nouns
      fillregex p=noun-pc[0-9]+(_is-lrt[0-9]+)?_name
      . noun "Any noun" "any noun"

    EndIter require

    BeginIter forbid{k} "a Forbid constraint"

      Select others "Noun Position Class {i} Lexical Rule Type {j} forbids" "Lexical Rule Type {j} forbids the following: " ""
      fillcache c=nouns
      fillregex p=noun-pc[0-9]+(_is-lrt[0-9]+)?_name
      . noun "Any noun" "any noun"

    EndIter forbid

    Label "<p>Lexical Rule Instances:</p>"

    BeginIter lri{k} "a Lexical Rule Instance" 0 1

      Radio inflecting "Noun Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Has Orthography" "Instance {k}<br>" ""
      . no "No" "" "No affix<br>"
      . yes "Yes" "" "Affix spelled"

      Text orth "Noun Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Spelling" "" "" 20 "fill_pred('noun-pc{i}_is-lrt{j}_lri{k}', 'a')"
      Text pred "Noun Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Predicate" "Predicate: " "" 20

    EndIter lri

  EndIter is-lrt

EndIter noun-pc

Separator

Label "<h3>Verb Inflection</h3>"

BeginIter verb-pc{i} "a Position Class" 1

  Text name "Verb Position Class {i} Name" "<b>Verb Position Class {i}</b>:<br/>Position Class Name: " " " 20

  Check obligatory "Verb Position Class {i} Obligatory" "<br/>Obligatorily occurs:" ""

  Select order "Verb Position Class {i} Order" "<br/>Appears as a prefix or suffix:" ""
  . prefix "Prefix" "prefix"
  . suffix "Suffix" "suffix"

  MultiSelect inputs "Verb Position Class {i} Input" "<br/>Possible inputs:" ""
  fillcache c=verbs
  fillcache c=qverbs
  fillcache c=auxes
  fillregex p=verb-pc[0-9]+(_lrt[0-9]+)?_name
  . verb "Any verb" "any verb"
  . iverb "Any intransitive verb" "any intransitive verb"
  . tverb "Any transitive verb" "any transitive verb"
  . aux "Any auxiliary verb" "any auxiliary verb"
  . qverb "Any question verb" "any question verb"

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Verb Position Class {i} Requires" "Verb Position Class {i} requires one of the following: " ""
    fillcache c=verbs
    fillcache c=auxes
    fillregex p=verb-pc[0-9]+(_lrt[0-9]+)?_name
    . verb "Any verb" "any verb"
    . iverb "Any intransitive verb" "any intransitive verb"
    . tverb "Any transitive verb" "any transitive verb"
    . aux "Any auxiliary verb" "any auxiliary verb"
    . qverb "Any question verb" "any question verb"

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Verb Position Class {i} Forbids" "Verb Position Class {i} forbids the following: " ""
    fillcache c=verbs
    fillcache c=auxes
    fillregex p=verb-pc[0-9]+(_lrt[0-9]+)?_name
    . verb "Any verb" "any verb"
    . iverb "Any intransitive verb" "any intransitive verb"
    . tverb "Any transitive verb" "any transitive verb"
    . aux "Any auxiliary verb" "any auxiliary verb"
    . qverb "Any question verb" "any question verb"

  EndIter forbid

  Label "<p>Lexical Rule Types that appear in this Position Class:</p>"

  BeginIter lrt{j} "a Lexical Rule Type" 1 1

    Text name "Verb Position Class {i} Lexical Rule Type {j} Name" "<b>Lexical Rule Type {j}</b>:<br/>Name: " "" 20

    MultiSelect supertypes "Verb Position Class {i} Lexical Rule Type {j} Supertype" "<br/>Supertypes: " ""
    fillregex p=verb-pc{i}_lrt[0-9]+_name

    Label "<p>Features:</p>"

    BeginIter feat{k} "a Feature"

      Select name "Verb Position Class {i} Lexical Rule Type {j} Feature {k} Name" "Name: " " "
      fillnames c=both

      MultiSelect value "Verb Position Class {i} Lexical Rule Type {j} Feature {k} Value" "Value: " ""
      fillvalues p=verb-pc{i}_lrt{j}_feat{k}_name

      Select head "Verb Position Class {i} Lexical Rule Type {j} Feature {k} Head" "Specified on: " ""
      . verb "The verb" "the verb"
      . subj "The subject" "the subject NP"
      . obj "The object" "the object NP"
      . newobj "The added object" "the added object NP"
      . higher "Higher-ranked" "the higher-ranked NP"
      . lower "Lower-ranked" "the lower-ranked NP"

    EndIter feat

    Label "<p>Valence-changing operations may modify the valence structure of<br/>
a verb by adding or removing either a subject or object, possibly <br/>
including changes to e.g. case frames or adding predicates. (<b>Experimental</b>)</p>"


    BeginIter valchg{k} "a valence-changing operation"

      Select operation "Verb Position Class {i} Lexical Rule Type {j} Valence-changing Operation {k} Type" "Type: " "<br/>" "" ""
      . subj-add "Subject-adding (e.g. causative)" "subject-adding"
      . subj-dem "Subject-demoting (e.g. passive)" "subject-demoting"
      . subj-rem "Subject-removing" "subject-removing"
      . obj-rem "Object-removing" "object-removing"
      . obj-add "Object-adding (e.g. applicative)" "object-adding"
      . obj-prom "Object-promoting" "object-promoting"

      Label "<p>Most valence-changing operations currently must operate on a known input valence. If both intransitive and transitive
inputs are possible, these need to be created as two separate lexical rule types. (This may change in the future).</p>"

      Select inputs  "Verb Position Class {i} Lexical Rule Type {j} Valence-changing Operation {k} Target Valence" "Should apply to: " " targets"
      . intrans "Intransitive" "intransitive"
      . trans "Transitive" "transitive"

      Label "<p>Object-adding operations currently only support strict transitive verbs as inputs.<br/>
        For subject- and object-adding operations, also specify (ignored for other operations):</P>"
      Text predname "Verb Position Class {i} Lexical Rule Type {j} Valence-changing Operation {k} Predicate Name" "Predicate: " "<br/> " 20

      Select argpos "Verb Position Class {i} Lexical Rule Type {j} Valence-changing Operation {k} Complement Position" "The added argument/erstwhile subject is at the: " " of the complements list.<br/>"
      . pre "front" "front"
      . post "end" "end" 


      Select argtype "Verb Position Class {i} Lexical Rule Type {j} Valence-changing Operation {k} Argument Type" "The added argument must be a(n): " ""
      . np "NP" "NP"
      . pp "PP" "PP"
      
    EndIter valchg

    Label "<p>Morphotactic Constraints:</p>"

    BeginIter require{k} "a Require constraint"

      MultiSelect others "Verb Position Class {i} Lexical Rule Type {j} Requires" "Lexical Rule Type {j} requires one of the following: " ""
      fillcache c=verbs
      fillcache c=auxes
      fillregex p=verb-pc[0-9]+(_lrt[0-9]+)?_name
      . verb "Any verb" "any verb"
      . iverb "Any intransitive verb" "any intransitive verb"
      . tverb "Any transitive verb" "any transitive verb"
      . aux "Any auxiliary verb" "any auxiliary verb"
      . qverb "Any question verb" "any question verb"

    EndIter require

    BeginIter forbid{k} "a Forbid constraint"

      Select others "Verb Position Class {i} Lexical Rule Type {j} forbids" "Lexical Rule Type {j} forbids the following: " ""
      fillcache c=verbs
      fillcache c=auxes
      fillregex p=verb-pc[0-9]+(_lrt[0-9]+)?_name
      . verb "Any verb" "any verb"
      . iverb "Any intransitive verb" "any intransitive verb"
      . tverb "Any transitive verb" "any transitive verb"
      . aux "Any auxiliary verb" "any auxiliary verb"
      . qverb "Any question verb" "any question verb"

    EndIter forbid

    Label "<p>Lexical Rule Instances:</p>"

    BeginIter lri{k} "a Lexical Rule Instance" 0 1

      Radio inflecting "Verb Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Has Orthography" "Instance {k}" ""
      . no "No" "" "No affix"
      . yes "Yes" "" "Affix spelled"

      Text orth "Verb Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Spelling" "" "" 20

    EndIter lri

  EndIter lrt

EndIter verb-pc

Separator

Label "<h3>Adjective Inflection</h3>"

BeginIter adj-pc{i} "a Position Class" 1

  Text name "Adjective Position Class {i} Name" "<b> Adjective Position Class {i}</b>:<br/>Position Class Name: " " " 20

  Check obligatory "Adjective Position Class {i} Obligatory" "<br/>Obligatorily occurs:" ""

  Select order "Adjective Position Class {i} Order" "<br/>Appears as a prefix or suffix:" ""
  . prefix "Prefix" "prefix"
  . suffix "Suffix" "suffix"

  MultiSelect inputs "Adjective Position Class {i} Input" "<br/>Possible inputs:" ""
  fillcache c=adjs
  fillregex p=adj-pc[0-9]+(_lrt[0-9]+)?_name
  . adj "Any Adjective" "any adjective"

  Check switching "Adjective Position Class {i} Switching" "<div>This position class constrains the syntactic behavior of its output: " "</div>"

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Adjective Position Class {i} Requires" "Adjective Position Class {i} requires one of the following: " ""
    fillcache c=adjs
    fillregex p=adj-pc[0-9]+(_lrt[0-9]+)?_name
    . adj "Any Adjective" "any adjective"

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Adjective Position Class {i} Forbids" "Adjective Position Class {i} forbids the following: " ""
    fillcache c=adjs
    fillregex p=adj-pc[0-9]+(_lrt[0-9]+)?_name
    . adj "Any Adjective" "any adjective"

  EndIter forbid

  Label "<p>Lexical Rule Types that appear in this Position Class:</p>"

  BeginIter lrt{j} "a Lexical Rule Type" 1 1

    Text name "Adjective Position Class {i} Lexical Rule Type {j} Name" "<b>Lexical Rule Type {j}</b>:<br/>Name: " "" 20

    MultiSelect supertypes "Adjective Position Class {i} Lexical Rule Type {j} Supertype" "<br/>Supertypes: " ""
    fillregex p=adj-pc{i}_lrt[0-9]+_name

    Label "<p>Features:<br>  Specify agreement features of the adjective by selecting one of the argument choices;<br>  specify inflection for predicative adjectives by selecting a feature to be specified on \"the adjective\".<br></p>"

    BeginIter feat{k} "a Feature"

      Select name "Adjective Position Class {i} Lexical Rule Type {j} Feature {k} Name" "Name: " " "
      fillnames c=both

      MultiSelect value "Adjective Position Class {i} Lexical Rule Type {j} Feature {k} Value" "Value: " ""
      fillvalues p=adj-pc{i}_lrt{j}_feat{k}_name

      Select head "Adjective Position Class {i} Lexical Rule Type {j} Feature {k} Head" "Specified on: " "" "" "toggle_element.call(this, 'adj-pc{i}_lrt{j}_adj_pc_note', 'on', ['subj', 'mod'])"
      . adj "The adjective" "the adjective"
      . subj "The subject" "the subject NP"
      . mod "The modified noun" "the modified NP"
      . xarg "Both positions" "both"

    EndIter feat

    Label "<p id='adj-pc{i}_lrt{j}_adj_pc_note' style='display:none;'>   NOTE: Specifying agreement features on \"the subject\" or \"the modified noun\" will create a new position<br>  class with specified features on \"both positions\" and without an affix to facilitate this functionality. If this<br>  is one of those position classes, make sure the \"specified on\" choice is set to \"both positions\"<br></p>"

    Radio mod "Adjective Position Class {i} Lexical Rule Type {j} structure" "<p>Instances of this Lexical Rule Type can be " "</p>" "adj-pc{i}_switching"
    . attr "Attributive" "" "attributive "
    . pred "Predicative" "" "predicative "
    . both "both" "" "both "

    Radio modpos "Adjective Position Class {i} Lexical Rule Type {j} modification direction" "<p>Instances of this Lexical Rule Type behaving attributively modify nouns directly<br>" "</p>" "adj-pc{i}_switching"
    . after "After-modifying" "" " after the adjective <br>"
    . before "Before-modifying" "" " before the adjective <br>"
    . either "Either-modifying" "" " either position <br>"
    . other "Other-mod" "" " some other position: this option is not currently supported" "" x

    Check predcop "Adjective Position Class {i} Lexical Rule Type {j} Stative Predicate or Copula Complement" "" " Instances of this Lexical Rule Type behaving predicatively appear as copula complements" "" "adj-pc{i}_switching"

    Label "<p>Morphotactic Constraints:</p>"

    BeginIter require{k} "a Require constraint"

      MultiSelect others "Adjective Position Class {i} Lexical Rule Type {j} Requires" "Lexical Rule Type {j} requires one of the following: " ""
      fillcache c=adjs
      fillregex p=adj-pc[0-9]+(_lrt[0-9]+)?_name
      . adj "Any adjective" "any adjective"

    EndIter require

    BeginIter forbid{k} "a Forbid constraint"

      Select others "Adjective Position Class {i} Lexical Rule Type {j} forbids" "Lexical Rule Type {j} forbids the following: " ""
      fillcache c=adjs
      fillregex p=adj-pc[0-9]+(_lrt[0-9]+)?_name
      . adj "Any adjective" "any adjective"

    EndIter forbid

    Label "<p>Lexical Rule Instances:</p>"

    BeginIter lri{k} "a Lexical Rule Instance" 0 1

      Radio inflecting "Adjective Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Has Orthography" "Instance {k}" ""
      . no "No" "" "No affix"
      . yes "Yes" "" "Affix spelled"

      Text orth "Adjective Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Spelling" "" "" 20

    EndIter lri

  EndIter lrt

EndIter adj-pc

Separator

Label "<h3>Copula Inflection</h3>"

BeginIter cop-pc{i} "a Position Class" 1

  Text name "Copula Position Class {i} Name" "<b> Copula Position Class {i}</b>:<br/>Position Class Name: " " " 20

  Check obligatory "Copula Position Class {i} Obligatory" "<br/>Obligatorily occurs:" ""

  Select order "Copula Position Class {i} Order" "<br/>Appears as a prefix or suffix:" ""
  . prefix "Prefix" "prefix"
  . suffix "Suffix" "suffix"

  MultiSelect inputs "Copula Position Class {i} Input" "<br/>Possible inputs:" ""
  fillcache c=cops
  fillregex p=cop-pc[0-9]+(_lrt[0-9]+)?_name
  . cop "Any Copula" "any copula"

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Copula Position Class {i} Requires" "Copula Position Class {i} requires one of the following: " ""
    fillcache c=cops
    fillregex p=cop-pc[0-9]+(_lrt[0-9]+)?_name
    . cop "Any Copula" "any copula"

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Copula Position Class {i} Forbids" "Copula Position Class {i} forbids the following: " ""
    fillcache c=cops
    fillregex p=cop-pc[0-9]+(_lrt[0-9]+)?_name
    . cop "Any Copula" "any copula"

  EndIter forbid

  Label "<p>Lexical Rule Types that appear in this Position Class:</p>"

  BeginIter lrt{j} "a Lexical Rule Type" 1 1

    Text name "Copula Position Class {i} Lexical Rule Type {j} Name" "<b>Lexical Rule Type {j}</b>:<br/>Name: " "" 20

    MultiSelect supertypes "Copula Position Class {i} Lexical Rule Type {j} Supertype" "<br/>Supertypes: " ""
    fillregex p=cop-pc{i}_lrt[0-9]+_name

    Label "<p>Features:</p>"

    BeginIter feat{k} "a Feature"

      Select name "Copula Position Class {i} Lexical Rule Type {j} Feature {k} Name" "Name: " " "
      fillnames c=both

      MultiSelect value "Copula Position Class {i} Lexical Rule Type {j} Feature {k} Value" "Value: " ""
      fillvalues p=cop-pc{i}_lrt{j}_feat{k}_name

      Select head "Copula Position Class {i} Lexical Rule Type {j} Feature {k} Head" "Specified on: " ""
      . cop "The copula" "the copula"
      . subj "The subject" "the subject NP"
      . mod "The complement" "the complement"

    EndIter feat

    Label "<p>Morphotactic Constraints:</p>"

    BeginIter require{k} "a Require constraint"

      MultiSelect others "Copula Position Class {i} Lexical Rule Type {j} Requires" "Lexical Rule Type {j} requires one of the following: " ""
      fillcache c=cops
      fillregex p=cop-pc[0-9]+(_lrt[0-9]+)?_name
      . cop "Any copula" "any copula"

    EndIter require

    BeginIter forbid{k} "a Forbid constraint"

      Select others "Copula Position Class {i} Lexical Rule Type {j} forbids" "Lexical Rule Type {j} forbids the following: " ""
      fillcache c=cops
      fillregex p=cop-pc[0-9]+(_lrt[0-9]+)?_name
      . cop "Any copula" "any copula"

    EndIter forbid

    Label "<p>Lexical Rule Instances:</p>"

    BeginIter lri{k} "a Lexical Rule Instance" 0 1

      Radio inflecting "Copula Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Has Orthography" "Instance {k}" ""
      . no "No" "" "No affix"
      . yes "Yes" "" "Affix"

      Text orth "Copula Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Spelling" "spelled" "" 20

    EndIter lri

  EndIter lrt

EndIter cop-pc

Separator

Label "<h3>Determiner Inflection</h3>"

BeginIter det-pc{i} "a Position Class" 1

  Text name "Determiner Position Class {i} Name" "<b>Determiner Position Class {i}</b>:<br/>Position Class Name: " " " 20

  Check obligatory "Determiner Position Class {i} Obligatory" "<br/>Obligatorily occurs:" ""

  Select order "Determiner Position Class {i} Order" "<br/>Appears as a prefix or suffix:" ""
  . prefix "Prefix" "prefix"
  . suffix "Suffix" "suffix"

  MultiSelect inputs "Determiner Position Class {i} Input" "<br/>Possible inputs:" ""
  fillcache c=dets
  fillregex p=det-pc[0-9]+(_lrt[0-9]+)?_name
  . det "Any determiner" "any determiner"

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Determiner Position Class {i} Requires" "Determiner Position Class {i} requires one of the following: " ""
    fillcache c=dets
    fillregex p=det-pc[0-9]+(_lrt[0-9]+)?_name
    . det "Any determiner" "any determiner"

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Determiner Position Class {i} Forbids" "Determiner Position Class {i} forbids the following: " ""
    fillcache c=dets
    fillregex p=det-pc[0-9]+(_lrt[0-9]+)?_name
    . det "Any determiner" "any determiner"

  EndIter forbid

  Label "<p>Lexical Rule Types that appear in this Position Class:</p>"

  BeginIter lrt{j} "a Lexical Rule Type" 1 1

    Text name "Determiner Position Class {i} Lexical Rule Type {j} Name" "<b>Lexical Rule Type {j}</b>:<br/>Name: " "" 20

    MultiSelect supertypes "Determiner Position Class {i} Lexical Rule Type {j} Supertype" "<br/>Supertypes: " ""
    fillregex p=det-pc{i}_lrt[0-9]+_name

    Label "<p>Features:</p>"

    BeginIter feat{k} "a Feature"

      Select name "Determiner Position Class {i} Lexical Rule Type {j} Feature {k} Name" "Name: " " "
      fillnames c=noun

      MultiSelect value "Determiner Position Class {i} Lexical Rule Type {j} Feature {k} Value" "Value: " ""
      fillvalues p=det-pc{i}_lrt{j}_feat{k}_name

      Select head "Determiner Position Class {i} Lexical Rule Type {j} Feature {k} Head" "Specified on " ""
      . noun "The noun" "the noun"

    EndIter feat

    Label "<p>Morphotactic Constraints:</p>"

    BeginIter require{k} "a Require constraint"

      MultiSelect others "Determiner Position Class {i} Lexical Rule Type {j} Requires" "Lexical Rule Type {j} requires one of the following: " ""
      fillcache c=dets
      fillregex p=det-pc[0-9]+(_lrt[0-9]+)?_name
      . det "Any determiner" "any determiner"

    EndIter require

    BeginIter forbid{k} "a Forbid constraint"

      Select others "Determiner Position Class {i} Lexical Rule Type {j} forbids" "Lexical Rule Type {j} forbids the following: " ""
      fillcache c=dets
      fillregex p=det-pc[0-9]+(_lrt[0-9]+)?_name
      . det "Any determiner" "any determiner"

    EndIter forbid

    Label "<p>Lexical Rule Instances:</p>"

    BeginIter lri{k} "a Lexical Rule Instance" 0 1

      Radio inflecting "Determiner Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Has Orthography" "Instance {k}" ""
      . no "No" "" "No affix"
      . yes "Yes" "" "Affix"

      Text orth "Determiner Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Spelling" "spelled" "" 20

    EndIter lri

  EndIter lrt

EndIter det-pc

Separator

Section toolbox-import "Import Toolbox Lexicon"

Label "<p><a href=\"http://www.sil.org/computing/toolbox\">Toolbox</a>
is a tool provided by SIL and used by many field linguists. This page
allows you to automatically create lexical entries for your Grammar
Matrix grammar on the basis of lexical entries in a Toolbox lexicon.
This page allows you to guide the import process by defining one
or more configurations (called Toolbox Import Configurations).
You may import from multiple Toolbox files (by
selecting multiple files on this page), but every time you do an
import, all previously imported lexical entries will be dropped.  If
your Toolbox files use the same set of tags, you may add them all to
the same Toolbox Import Configuration.  If they use different tags
(for lexical entry ids, stems, and glosses), you will need to define
separate Toolbox Import Configurations.</p><p>For each Toolbox Import
Configuration, you will need to specify the file or files you are
importing from, the tags used in those files for entry ids, stems, and
glosses.  Within each Toolbox Import Configuration you can specify one
or more Import Classes, which map Toolbox tag/value pairs to lexical
classes defined on the Lexicon page.  The Toolbox Import
Configurations become part of your choices file when you click the
Submit or Import Lexicon buttons.</p><p> Once you have imported a
lexicon, you can check the entries that were imported for each class <a
href=\"matrix.cgi?subpage=ToolboxLexicon\">here</a>.
If you find errors, you can edit the Import Classes and
re-import.</p><p>In order to import information from a Toolbox lexicon
to your choices file, the Toolbox files must be transferred to our
servers.  We will NOT store these files permanently.  They will be
deleted immediately after being processed.</p>"

BeginIter toolboximportconfig{i} "a Toolbox Import Configuration" 1 1

  Text idtag "id tag" "Toolbox tag for lex entry ids: " "" 10

  Text glosstag "gloss tag" " Toolbox tag for glosses: " "" 10

  Text starttag "start tag" "<br /><br />Toolbox tag which starts lexical database entries: " "" 10

  Text stemtag "stem tag" "<br /><br />Toolbox tag for stem: " "" 10

  Text bistemtag "bistem tag" " (Optional) Toolbox tag for affix portion of bipartite stems: " "" 10

  BeginIter repeat{j} " a Toolbox tag which can repeat in a database entry"

    Text tag "repeatable tag" " Repeatable Tag {j}: " "" 10

  EndIter repeat

  Radio tbpredvalues "pred values" "<p>Every lexical entry requires a semantic predicate.  For entries imported from Toolbox, we can construct these predicates from the stem, from the gloss (which could be long), or from the first word of the gloss.  If either of the gloss options is chosen but some entries lack glosses, lexical entries will be constructed from the stem for those entries.  Predicates should be constructed from: <br />" ""
  . stem "Stem" "" " the stem value<br>"
  . gloss "Gloss" "" " the gloss (if available)<br>"
  . glossfw "Gloss first word" "" " the first word of the gloss (if available)"

  BeginIter toolboxfile{j} "a Toolbox File" 0 1

    File tbfilename "file name" "Toolbox file {j}: " ""

  EndIter toolboxfile

  BeginIter importclass{j} "an Import Class" 1 1

    Text importlextype "lexical type" "Lexical type for imported entries " "" 20

    BeginIter toolboxtag{k} "a Toolbox tag-value pair" 0 1

      Text tbtag "toolboxtag" "Toolbox tag (e.g., for part of speech): " "" 10

      Text tbvalue "toolboxvalue" " Value for the Toolbox tag: " "" 10

    EndIter toolboxtag

  EndIter importclass

EndIter toolboximportconfig

Button "Import Toolbox Lexicon" "<br /><br />" "" "import_toolbox_lexicon()"

Section test-sentences "Test Sentences"

Label "<p>In this section, you can provide example sentences that will
appear in the file <span class=\"tt\">test_sentences</span> in your grammar, as defaults
in the LKB's parse dialog, and in the [incr tsdb()] database skeleton
in the tsdb/skeletons directory of your grammar. Please use only the
vocabulary defined in the Lexicon section. If the sentence is
ungrammatical, please check the \"Starred\" checkbox</p>"

BeginIter sentence{i} "a Sentence"

  Text orth "Sentence {i}" "<b>Sentence {i}</b>: " "" 100
  Check star "Grammatical {i}" "Starred: " ""

EndIter sentence

Section gen-options "Test by Generation Options"

Label "<p>In this section, select the templates you wish to generate from,
and the features you which to specify on those templates</p>"

Separator

Label "<p>Select which templates you would like to use in generation.  If nothing is selected, the simple transitive and intransitive templates will be used, with no features specified</p>"

Check itv "Intransitive" "" "Simple intransitive verb phrase<br>"

Label "Features:"

BeginIter itv-feat{j} "a Feature"

    Select name "Feature {j} name" "Name: " " "
    fillnames c=verb

    Select value "Feature {j} value" "Value: " ""
    fillvalues p=itv-feat{j}_name

    Select location "Feature {j} location" "Specified on: " ""
    . NOUN1 "Subject" "the subject NP"
    . ITR-VERB1 "Verb" "the verb"

EndIter itv-feat

Separator

Check stv "Transitive" "" "Simple transitive verb phrase<br>"

Label "Features:"

BeginIter stv-feat{j} "a Feature"

    Select name "Feature {j} name" "Name: " " "
    fillnames c=verb

    Select value "Feature {j} value" "Value: " ""
    fillvalues p=stv-feat{j}_name

    Select location "Feature {j} location" "Specified on: " ""
    . NOUN1 "Subject" "the subject NP"
    . TR-VERB1 "Verb" "the verb"
    . NOUN2 "Object" "the object NP"

EndIter stv-feat

Section ToolboxLexicon "Toolbox Lexicon" 0

Label "<p> Imported Toolbox Lexical items are displayed here, if any of these are incorrect
we recommend changing your import configurations and reimporting your files instead of
directly correcing the entries.</p>"

Separator

BeginIter imported-entry{i} "an imported Entry"

    Text lextype "Imported-Entry {i} LexType" "Lexical Type:" "<br />" 20

    Text orth "Imported-Entry {i} Orthogrphy" "Spelling:" "<br />" 20

    Text pred "Imported-Entry {i} Predicate" "Predicate:" "<br />" 20

    Text aff "Imported-Entry {i} Affix" "Affix:" "<br />" 20

EndIter imported-entry

