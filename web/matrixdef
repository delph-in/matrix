### $Id: matrixdef,v 1.37 2008-09-30 23:50:02 lpoulson Exp $

Section general "General Information"

Label "<h3>Language</h3>"

Text language "Language name" "<p>Name of your language: " "<br>" 50
Text iso-code "ISO code" "<a href=\"http://www.sil.org/iso639-3/codes.asp\">ISO code</a> for your language: " " (optional) </p>" 6

Label "<h3>String-processing</h3><p>Your grammar will include a basic tokenizer file for string-level processing (<span class='tt'>vanilla.rpp</span>, see <a href='http://moin.delph-in.net/ReppTop/'>ReppTop</a> documentation).  We have three default options for this file.  If you do not answer, your grammar will include a tokenizer which will discard most ascii punctuation (except the hyphen, colon, and equals [-,:,=]).<br />"

Radio punctuation-chars "Punctuation characters" "<br />" ""
. discard-all "discard-all" "" "split on, and then discard all punctuation characters found in this default list (all lower ascii punctuation except \x22 \"): <span class='tt'>!#$%&#38;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~\</span><!--we can't currently do anything about the unicode characters... maybe later 。！？…．　○●◎＊☆★◇◆--><br />"
. keep-all "keep-all" "" "only split space and tab characters, all other characters can occur in tokens<br />"
. keep-list "keep-list" "" "place characters into a list of characters that can occur within tokens (you can copy and paste from the default list above; do not use any commas or spaces to delimit characters)."

Text punctuation-chars-list "Punctuation characters" "&nbsp;&nbsp;Punctuation characters to parse:" "<br />" 50

Label "<h3>Archiving and Version Control</h3>"

Label "<p>The developers of the Grammar Matrix project would like to
retain your answers to this questionnaire in an archive.  We hope
that, as the number of linguistic phenomena covered by the
questionnaire grows, these archived sets of answers can be used as the
basis for a database that will be useful to linguistic typological
research. We welcome answers from users of all experience levels.</p>"

Radio archive "Archive" "<p>May we retain your answers to this questionnaire?<br>" ""
. yes "Yes" "" " yes (recommended)<br>"
. no "No" "" " no</p>"

Label "<p>If you answered \"yes\", we ask that you also (optionally)
provide the information below.  This information will be used to
distinguish multiple linguists working on the same language, to help
us improve the Grammar Matrix, and possibly to contact you in the
future.  We will not share your answers or identifying information
outside the project, unless required by law.</p>"

Text email "Email address" "<table id='feedback'><tr><td>Your email address: <td>" "</tr>" 40
one-name
Text affiliation "Affiliation" "<tr><td>Your affiliation: <td>" "</tr>" 40

Text motivation "Motivation" "<tr><td>Your reason for using this system: <td>" "<br>(e.g. descriptive linguistic research, for a class)</tr>" 80

TextArea comment "Comments" "<tr><td>Comments on your implementation of the grammar: <td>" "<br>(e.g. Choice of analyses, sources of information, etc.)</tr></table>" 80x6

Label "<p>We recommend that you use version control for your grammar development, and aim to facilitate that in two ways.  First, you can choose to have your grammar's code initialized into a Git or Mercurial repository.  Please see <a href=\"http://wiki.delph-in.net/moin/VersionControlForGrammarDevelopment\">this wiki page</a> for information on how to use these systems. The wiki also includes information on how to use Subversion (svn) with your grammar.</p>"

Radio vcs "Version Control System" "<p>Version Control System.<br>" ""
. none "None" "" " None<br>"
. hg "Mercurial (hg)" "" " Mercurial (hg)<br>"
. git "Git" "" " Git<br>"

Label "<p>You may also wish to have your repository hosted through an open source hosting service (e.g., Google Code or GitHub).  This provides off-site back-up and facilitates sharing your grammar and collaborating with others.  The wiki (linked above) includes information on how to set that up.  Note that Google Code can host Mercurial or Subversion repositories, and GitHub hosts Git repositories. If you do host your grammar on one of these sites, please let us know that you have, by emailing matrix-dev -at- uw.edu.</p>"

Section word-order "Word Order"

Label "<p>"

Radio word-order "Basic word order" "Please indicate which pattern best describes the basic word order of your language in matrix (main) clauses:<br>" "</p>"
. sov "Subject, Object, Verb" "" "SOV<br>"
. svo "Subject, Verb, Object" "" "SVO<br>"
. vso "Verb, Subject, Object" "" "VSO<br>"
. osv "Object, Subject, Verb" "" "OSV<br>"
. ovs "Object, Verb, Subject" "" "OVS<br>"
. vos "Verb, Subject, Object" "" "VOS<br>"
. v-final "Verb-final" "" "V-final<br>"
. v-initial "Verb-initial" "" "V-initial<br>"
. free "Free word order" "" "free (pragmatically determined word order)<br>"
. v2 "v2 word order" "" "finite verb or auxiliary in second position, else free word order"

Label "<p>Note: Modules for V2 order (finite verb second, non-finite
verb clause-finally) and differing word order between matrix and
subordinate clauses are currently under development.</p>"

Separator

Radio has-dets "Has determiners" "Does your language have determiners (as independent words)?" ""
. yes "Yes" "" "yes"
. no "No" "" "no<br>"

Radio noun-det-order "Order of determiners and nouns" "If so, what is the order of determiners with respect to nouns?" ""
. noun-det "Noun-Det" "" "Noun-Det"
. det-noun "Det-Noun" "" "Det-Noun<br><br>"

Separator

Radio has-aux "Has auxiliaries" "Does your language have auxiliary verbs?" ""
. yes "Yes" "" "yes"
. no "No" "" "no<br>"

Label "<p>If so, please specify the following auxiliary properties:</p>"
Label "<div style=\"padding-left: 30px\">"

  Radio aux-comp-order "Order of auxiliary and complement" "<b>Word Order:</b> Does an auxiliary verb appear before or after its complement?<br>" ""
  . before "Before" "" "before <br>"
  . after "After" "" "after <br><br>"

  Radio aux-comp "Aux {i} complement" "<b>Complements:</b> The complements of auxiliaries are:<br>" ""
  . s "S" "" "saturated sentences<br>"
  . vp "VP" "" "VPs, raising the subject<br>"
  . v "V" "" "Vs, raising all of its arguments (argument composition)<br><br>"

Label "(If you work with a language where the complement type (V, VP,
or S) varies depending on the auxiliary please let us know.)<br><br>"

  Radio multiple-aux "multiple auxiliaries" "Can there be more than one auxiliary in a clause?<br>" ""
  . yes "Yes" "" "yes<br>"
  . no "No" "" "no<br><br>"

Label "NOTE: If your language has free word order and allows more than one auxiliary per clause, we assume that the verbal group forms a cluster (i.e. that all verbal forms are adjacent to each other). If your language reveals different behavior, please let us know."


Label "<p><span style=\"color:red\">NOTE: As Modules for V2 order are
still under development, relative order of auxiliaries and their
complements have not been implemented yet.</span></p>"

Separator 

Label "<p>The word order in subordinate clauses is:</p>"

  Radio subord-word-order "Clausal Complement Type {i} clause word order" "" ""
  . same "same as in indicative" "" "Same as in the matrix clause<br>" 
  . vfinal "Verb Final" "" "Verb-final (assuming matrix order is V2, like in German)"
  
Label "<p> NOTE: We assume that the order in all subordinate clauses 
(e.g. clausal modifiers and clausal complements)
is the same. If your language reveals different behavior, 
please let us know.</p>"

Label "</div>"

Section number "Number"

Label "<p><span class=\"dfn\">Number</span> is a grammatical category
that distinguishes between different numbers of real-world entities.
For example, many languages distinguish a <span
class=\"dfn\">singular</span> number from a <span
class=\"dfn\">plural</span>, the former begin associated with one
entity and the latter with more than one.  Other languages distinguish
still more number values, including a <span class=\"dfn\">dual</span>
(two entities) and a <span class=\"dfn\">paucal</span> (a few
entities).  It is important to distinguish between number, described
here, and numerals, which cannot currently be described in this
questionnaire.  The answers you provide on this page will determine
the values available on the lexicon page for the <span
class=\"feat\">number</span> feature (or the <span
class=\"feat\">pernum</span> feature, about which see the Person
section of the questionnaire for more details).</p>"

Label "<p>Please describe the number hierarchy in your language.  Add
all the values of number that the language's grammar distinguishes.
For each you may provide one or more supertypes, using the other
number values you have defined or the root type
<span class=\"tt\">number</span> (which
will be assumed if no supertype is provided).  If your language does
not have number as a grammatical category, leave this section
blank.</p>"

BeginIter number{i} "a Number" 1

  Text name "Number {i} name" "Number name: " "" 20

  BeginIter supertype{j} "a Supertype"

    Select name "Number {i} supertype {j} name" "Supertype: " ""
    fillregex p=number[0-9]+_name n=1
    . number "Number" "number"

  EndIter supertype

EndIter number


Section person "Person"

Label "<p><span class=\"dfn\">Person</span> is a grammatical category
that distinguishes between different discourse participants.  Natural
languages generally distinguish up to three discourse participants:
the speaker (the <span class=\"dfn\">first person</span>), the person
spoken to (the <span class=\"dfn\">second person</span>), and anyone
else (the <span class=\"dfn\">third person</span>).  Some languages
are analyzed as having an additional <span class=\"dfn\">fourth
person</span> category, whose meaning varies from language to
language.  The answers you provide on this page will determine what
values are available later in the questionnaire for the <span
class=\"feat\">person</span> feature (or the <span
class=\"feat\">pernum</span> feature; see below).</p>"

Radio person "Person" "<p>Which values of person are distinguished in your language?<br>" ""
. none "None" "" "none<br>"
. 1-2-3 "First, second, and third" "" "First, second, and third<br>"
. 1-2-3-4 "First, second, third, and fourth" "" "First, second, third, and fourth<br>"
. 1-non-1 "First and non-first" "" "First and non-first<br>"
. 2-non-2 "Second and non-second" "" "Second and non-second<br>"
. 3-non-3 "Third and non-third" "" "Third and non-third</p>"

Label "<p>Some languages are best analyzed as having subtypes of the
first person for some values of the <span class=\"feat\">number</span>
feature.  For example, <span class=\"dfn\">inclusive/exclusive</span>
languages make a distinction in the non-singular between the first
person <span class=\"dfn\">exclusive</span>, which does not include
the person spoken to, and the first person <span
class=\"dfn\">inclusive</span>, which does.  In <span
class=\"dfn\">minimal/augmented</span> languages, three distinctions
are made: speaker and one person spoken to, speaker and one other
(third) person, and speaker and more than one other person.</p>"

Radio first-person "First person" "<p>What subtypes does your language distinguish in the first person?<br>" ""
. none "None" "" " none<br>"
. incl-excl "Inclusive/exclusive" "" " inclusive and exclusive"

MultiSelect incl-excl-number "Inclusive/exclusive number" " in the: " "<br>"
fillnumbers


Radio first-person "First person" "" ""
. other "Other" "" " other:</p>"

Label "<div style=\"padding-left: 16px\">"

Label "Please provide names for the subtypes distinguished by your
language.  The names you provide below will be prefixed with the
appropriate person and number value; for example, if you enter a
subtype named \"excl\" of the first person for the number values
<span class=\"tt\">dual</span> and <span class=\"tt\">plural</span>, the system will produce two
subtypes named <span class=\"tt\">1dual_excl</span> and <span class=\"tt\">1plural_excl</span>.)<br>"

BeginIter person-subtype{i} "a Subtype"

  Text name "Subtype {i} name" "Name: " "" 20

  MultiSelect number "Subtype {i} number" " in the first person: " ""
  fillnumbers

EndIter person-subtype

Label "</div>"


Section gender "Gender"

Label "<p>Hockett (1958) defines grammatical <span
class=\"dfn\">gender</span>s as \"classes of nouns reflected in the
behavior of associated words.\" Gender is, therefore, a phenomenon
that appears in patterns of agreement.  Some languages have no
genders, others divide nouns into two genders (e.g. <span
class=\"dfn\">masculine</span> and <span
class=\"dfn\">feminine</span>, <span class=\"dfn\">animate</span> and
<span class=\"dfn\">inanimate</span>, or <span
class=\"dfn\">rational</span> and <span
class=\"dfn\">non-rational</span>), while still others have more.
Some languages have genders that are subtypes of other genders; for
example, a language may distinguish between inanimate nouns and
animate nouns, and within the animate nouns, between masculine and
feminine.  Any number of genders and the relationship between them can
be described by creating a type hierarchy, below.  The hierarchy you
define will determine what values of the <span
class=\"feat\">gender</span> feature are available later in the
questionnaire.</p>"

Label "<p>Please describe the gender hierarchy in your language.  Add
all the values of gender that the language's grammar distinguishes.
For each you may provide one or more supertypes, using the other
gender values you have defined or the root type <span class=\"tt\">gender</span>
(which will be assumed if no supertype is provided).  If your language does
not have gender as a grammatical category, leave this section
blank.</p>"

BeginIter gender{i} "a Gender" 1

  Text name "Gender {i} name" "Gender name: " "" 20

  BeginIter supertype{j} "a Supertype"

    Select name "Gender {i} supertype {j} name" "Supertype: " ""
    fillregex p=gender[0-9]+_name n=1
    . gender "Gender" "gender"

  EndIter supertype

EndIter gender

Label "<h4>References</h4>"
Label "<div style=\"font-size:2\">"
Label "<p>Hockett, Charles F. 1958. A Course in Modern
Linguistics. New York: Macmillan.</p>"
Label "</div>"


Section case "Case"

Label "<p>Blake (2001) defines <span class=\"dfn\">case</span> as
&quot;a system of marking dependent nouns for the type of relationship
they bear to their heads.&quot; For example, case commonly marks the
subject or the direct object of a verb. The marking might consist of
affixation or some other morpholological process that marks words, or
it might be an adposition that marks whole noun phrases.</p>"

Label "<p>This questionnaire allows you to describe <span
class=\"dfn\">core case marking</span> in your language; that is, the
pattern of cases marking the mandatory arguments of transitive and
intransitive verbs.  Following Dixon (1968), we refer to the
grammatical relations commonly expressed by case using the following
abbreviations: A refers to the agent of a transitive verb; O refers to
the patient (or object) of a transitive verb; and S refers to the lone
argument (or subject) of intransitive verbs.</p>"

Radio case-marking "Core case marking" "<p>What type of core case marking does your language exhibit?</p>" ""
. none "None" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>None</b><br>(Verbal argument roles are determined only by word order, by intonation, or pragmatically.)</p>"
. nom-acc "Nominative-accusative" "<p style=\"margin-left:20px;margin-bottom:0px;text-indent:-20px\">" "<b>Nominative-accusative</b><br></p>"

Label "<p style=\"margin-left:20px;margin-top:0px\">"
Text nom-acc-nom-case-name "Nominative case name" "S and A take a case named the " " (e.g. nominative, subjective)<br>" 20
Text nom-acc-acc-case-name "Accusative case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20
Label "</p>"


Radio case-marking "Core case marking" "" ""
. erg-abs "Ergative-absolutive" "<p style=\"margin-left:20px;margin-bottom:0px;text-indent:-20px\">" "<b>Ergative-absolutive</b><br></p>"

Label "<p style=\"margin-left:20px;margin-top:0px\">"
Text erg-abs-erg-case-name "Ergative case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20
Text erg-abs-abs-case-name "Absolutive case name" "S and O take a case named the " " (e.g. absolutive, nominative)<br>" 20
Label "</p>"


Radio case-marking "Core case marking" "" ""
. tripartite "Tripartite" "<p style=\"margin-left:20px;margin-bottom:0px;text-indent:-20px\">" "<b>Tripartite</b><br></p>"

Label "<p style=\"margin-left:20px;margin-top:0px\">"
Text tripartite-s-case-name "S case name" "S takes a case named the " " (e.g. nominative, subjective)<br>" 20
Text tripartite-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, agentive)<br>" 20
Text tripartite-o-case-name "O case name" "O takes a case named the " " (e.g. absolutive, patientive)<br>" 20
Label "</p>"


Radio case-marking "Core case marking" "" ""
. split-s "Split-S" "<p style=\"margin-left:20px;margin-bottom:0px;text-indent:-20px\">" "<b>Split-S</b><br></p>"

Label "<p style=\"margin: 0px 0px 0px 20px\">(The S argument of some intransitive verbs is marked by the
same case as the agent of transitives, while for other verbs the S
argument is marked by the same case as the patient.)</p>"

Label "<p style=\"margin-left:20px;margin-top:0px\">"
Text split-s-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, agentive)<br>" 20
Text split-s-o-case-name "O case name" "O takes a case named the " " (e.g. absolutive, patientive)<br>" 20
Label "</p>"


Radio case-marking "Core case marking" "" ""
. fluid-s "Fluid-S" "<p style=\"margin-left:20px;margin-bottom:0px;text-indent:-20px\">" "<b>Fluid-S</b><br></p>"

Label "<p style=\"margin: 0px 0px 0px 20px\">(The S argument of some intransitive verbs is marked by the
same case as the agent of transitives, while for other verbs the S
argument is marked by the same case as the patient, and for still
other verbs the S argument can be marked by either case, depending on
pragmatic factors (e.g. whether the S is perceived as being in control
of the action.)</p>"

Label "<p style=\"margin-left:20px;margin-top:0px\">"
Text fluid-s-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, agentive)<br>" 20
Text fluid-s-o-case-name "O case name" "O takes a case named the " " (e.g. absolutive, patientive)<br>" 20
Label "</p>"


Radio case-marking "Core case marking" "" ""
. split-n "Split N" "<p style=\"margin-left:20px;margin-bottom:0px;text-indent:-20px\">" "<b>Split conditioned on features of the noun phrase arguments</b><br></p>"

Label "<p style=\"margin: 0px 0px 0px 20px\">(Some classes of noun phrases (e.g. pronouns) show a
nominative-accusative pattern, while others (e.g. common nouns) show
an ergative-absolutive pattern.  You will have an opportunity to
define these classes on the Lexicon page.)</p>"

Label "<p style=\"margin-left:20px;margin-top:0px\">"
Text split-n-nom-case-name "Nominative case name" "S and A take a case named the " " (e.g. nominative, subjective)<br>" 20
Text split-n-acc-case-name "Accusative case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20
Text split-n-erg-case-name "Ergative case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20
Text split-n-abs-case-name "Absolutive case name" "S and O take a case named the " " (e.g. absolutive, nominative)<br>" 20
Label "</p>"


Radio case-marking "Core case marking" "" ""
. split-v "Split V" "<p style=\"margin-left:20px;margin-bottom:0px;text-indent:-20px\">" "<b>Split conditioned on features of the verb</b><br></p>"

Label "<p style=\"margin: 0px 0px 0px 20px\">(Depending on some feature of the verb (e.g. tense or aspect),
the core arguments are sometimes marked in a nominative-accusative
pattern and other times in an ergative-absolutive pattern.  You will
have an opportunity to define these features on the Lexicon
page.)</p>"

Label "<p style=\"margin-left:20px;margin-top:0px\">"
Text split-v-nom-case-name "Nominative case name" "S and A take a case named the " " (e.g. nominative, subjective)<br>" 20
Text split-v-acc-case-name "Accusative case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20
Text split-v-erg-case-name "Ergative case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20
Text split-v-abs-case-name "Absolutive case name" "S and O take a case named the " " (e.g. absolutive, nominative)<br>" 20
Label "</p>"


Radio case-marking "Core case marking" "" ""
. focus "Focus" "<p style=\"margin-left:20px;margin-bottom:0px;text-indent:-20px\">" "<b>Focus-case</b><br></p>"

Label "<p style=\"margin: 0px 0px 0px 20px\">(A number of Austronesian languages, including several
Philippine languages, have a system where A and O are marked by cases.
An additional case, sometimes called the <span
class=\"dfn\">focus</span>, is mandatory in every clause and has its
grammatical role assigned by the morphology of the verb.  You will
have an opportunity to define this morphology on the Morphology
page.)</p>"

Label "<p style=\"margin-left:20px;margin-top:0px\">"
Text focus-focus-case-name "Focus case name" "The focus case is named the " "<br>" 20
Text focus-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20
Text focus-o-case-name "O case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20
Label "</p>"


Label "<p><b>Additional Cases</b></p><p>If your language has any
additional cases not covered above that occur in simple intransitive
or transitive clauses (e.g. if you language has verbs whose O is
marked by the dative), define those cases here:</p>"

BeginIter case{i} "a Case"

  Text name "Case {i} name" "Name: " "" 20

EndIter case

Label "<h4>References</h4>"
Label "<div style=\"font-size:2\">"
Label "<p>Blake, Barry J. 2001. Case. Cambridge: Cambridge University
Press.</p>"
Label "<p>Dixon, R. M. W. 1968. The Dyirbal Language of North
Queensland. Ph.D. thesis, University of London.</p>"
Label "</div>"


Section direct-inverse "Direct-inverse"

Label "<p>In some languages, the pattern of marking of verbal
arguments (or verbs themselves) is sensitive to a grammatical <span
class=\"dfn\">scale</span> that ranks argument noun phrases according
to how natural they are in the role of agent; for example, a language
might rank animate NPs as more natural agents than inanimate NPs.  In
such languages, transitive sentences in which the agent outranks the
patient are marked differently from those in which the patient
outranks the agent.  Such sentences are said to differ in <span
class=\"dfn\">direction</span>.  Sentences where the agent outranks
the patient are called <span class=\"dfn\">direct</span>, while
sentences where the patient outranks the agent are called <span
class=\"dfn\">inverse</span>.  The difference between direct and
inverse sentences may be marked by a different verb form, by different
cases on the argument NPs, or both.  Creating a direct-inverse scale
here will make available, on the Lexicon page, argument structures for
verbs that are sensitive to the scale, and also the <span
class=\"feat\">direction</span> feature for use in verbal
inflection.</p>"

Label "<p>If your language shows the direct-inverse pattern, please
describe the features that define the scale below.  The scale entries
should be entered in order from the highest (most agent-like) to the
lowest (most patient-like).</p>"

BeginIter scale{i} "a Scale Entry" 1

  Label "<b>Scale entry {i}</b><br>Features:"

  BeginIter feat{j} "a Feature" 0 1

    Select name "Scale entry {i} feature {j} name" "Name: " " "
    fillnames c=noun

    Select value "Scale entry {i} feature {j} value" "Value: " ""
    fillvalues p=scale{i}_feat{j}_name

  EndIter feat

EndIter scale

Select scale-equal "Direction when equal" "<p>When the agent and patient have the same scale value, the main verb is " "<br>(The other form may be something like a reflexive.  If you select \"some other form\", the resulting grammar will not parse sentences where the agent and patient are equally ranked.  You will need to edit the starter grammar manually to add the other form.)</p>"
. direct "Direct" "direct"
. other "Some other form" "some other form"


Section tense-aspect-mood "Tense, Aspect and Mood"

Label "<p>You may define semantic features directly related to
tense, aspect and mood on this page as well as a syntactic feature related
to verb forms. If additional features are needed for defining tense, aspect or mood  in your language,e.g., for defining arbitrary or
quasi-semantic verb classes, you may define them on the Other Features
page.</p>"

Label "<h3>Semantic Features</h3>"
Label "<div style=\"padding-left: 16px\">"

Label "<h4><span class=\"feat\">tense</span></h4>"

Label "Comrie (1985:9) defines <span class=\"dfn\">tense</span> as
\"... grammaticalized expression of location in time\". Which
categories of tense are grammaticalized varies across languages. You
may create a hierarchy of values for the feature <span
class=\"feat\">tense</span> as appropriate for your language. If your
language does not have tense as a grammatical category, leave this
section blank."

Label "You may define a hierarchy of values for the <span
class=\"feat\">tense</span> feature in one of two ways:"

Label "<ul><li>Select among the following common hierarchy elements
and supplement with subtypes as needed, or <li>Build your own
hierarchy.</ul>"

Radio tense-definition "Tense hierarchy definition style" "" ""
. choose "Choose" "" "<strong>Select among common hierarchy elements</strong><br>"

Label "<div style=\"padding-left: 35px\">"

Label "<br>Which of the following are tense hierarchy elements in your
language?<br><br>"

Check past "Past" "" "<b>past</b><br>"
  BeginIter past-subtype{i} "a subtype"
    Text name "Past subtype {i} name" "Subtype: " "" 20
  EndIter past-subtype

Check present "Present" "<br><br>" "<b>present</b><br>"
  BeginIter present-subtype{i} "a subtype"
    Text name "Present subtype {i} name" "Subtype: " "" 20
  EndIter present-subtype

Check future "Future" "<br><br>" "<b>future</b><br>"
  BeginIter future-subtype{i} "a subtype"
    Text name "Future subtype {i} name" "Subtype: " "" 20
  EndIter future-subtype

Check nonpast "Non-Past" "<br><br>" "<b>nonpast</b> &nbsp;&nbsp;&nbsp;&nbsp; <span style=\"font-size:-1\">(note: If present and/or future are also selected they are assumed to be subtypes of nonpast.)<br></span>"
  BeginIter nonpast-subtype{i} "a subtype"
    Text name "Non-Past subtype {i} name" "Subtype: " "" 20
  EndIter nonpast-subtype

Check nonfuture "Non-Future" "<br><br>" "<b>nonfuture</b> &nbsp;&nbsp;&nbsp;&nbsp; <span style=\"font-size:-1\">(note: If present and/or past are also selected they are assumed to be subtypes of nonfuture.)<br></span>"
  BeginIter nonfuture-subtype{i} "a subtype"
    Text name "Non-Future subtype {i} name" "Subtype: " "" 20
  EndIter nonfuture-subtype

Label "</div>"

Radio tense-definition "Tense hierarchy definition style" "" ""
. build "Build" "" "<strong>Build your own <span class=\"feat\">tense</span> hierarchy</strong><br>"

Label "<div style=\"padding-left: 35px\">"
Label "<br>Build your hierarchy from the top down starting with
subtypes of the supertype: tense.<br>"

BeginIter tense{i} "a tense type" 1

  Text name "tense {i} name" "Tense name: " "" 20
  BeginIter supertype{j} "a Supertype" 0 1

    Select name "Tense {i} supertype {j} name" "Supertype: " ""
    fillregex p=tense[0-9]+_name n=1
    . tense "Tense" "tense"

  EndIter supertype

EndIter tense
Label "</div>"

Label "<h4><span class=\"feat\">aspect</span></h4>"

Label "<p>According to Kibort (2008), \"The term 'aspect' designates
the perspective taken on the internal temporal organisation of the
situation, and so 'aspects' distinguish different ways of viewing the
internal temporal constituency of the same situation (Comrie
1976:3ff,...; Bybee 2003:157). The 'situation' is meant here as [a]
general term covering events, processes, states, etc., as expressed by
the verb phrase or the construction. Unlike tense, which is
situation-external time, aspect is situation-internal and non-deictic,
as it is not concerned with relating the time of the situation to any
other time point.\""

Label "<p>\"Aspectual meaning of a clause can be broken up into two
independent aspectual components (Smith 1991/1997): Aspectual
viewpoint [and] Situation type ... .\" Aspectual viewpoint conveys
\"the temporal perspective from which the situation is presented.\"
Situation type \"classifies the situation according to its temporal
properties.\" (Kibort 2008)"

Label "<p>See references below, especially Kibort (2008), for more
detail."

Label "<div style=\"padding-left: 35px\">"

Label "<p><b>Viewpoint Aspect</b>"

Label "<p>Viewpoint aspect is also commonly referred to as grammatical
aspect.  The most common viewpoint opposition is
perfective/imperfective.You may create a hierarchy consisting of only this opposition or you may create a hierarchy of your own, as appropriate for your language. If your language does not have viewpoint aspect (also commonly referred to as grammatical aspect) as a grammatical category, leave this section blank.<br><br>"

Check perimper "Perfective/Imperfective" "" "Create a hierarchy consisting of just the values <b>perfective</b> and <b>imperfective</b> as subtypes of aspect."

Label "<p>Build your own hierarchy of values for the feature <span class=\"feat\">aspect</span>. Note: this is an alternative to choosing the binary opposition above -- if hierarchy elements are defined below the choice above is overridden."

BeginIter aspect{i} "an aspect type" 1

  Text name "aspect {i} name" "Aspect name: " "" 20
  BeginIter supertype{j} "a Supertype" 0 1

    Select name "Aspect {i} supertype {j} name" "Supertype: " ""
    fillregex p=aspect[0-9]+_name n=1
    . aspect "Aspect" "aspect"

  EndIter supertype

EndIter aspect

Label "<p><b>Situation Aspect</b>"

Label "<p>The term \"situation aspect\" overlaps with, or subsumes,
lexical aspect, inherent aspect and some uses of the term
Aktionsart. Situation aspect values may be conveyed by the meaning of
the verb or through overt morphological marking however situation
aspect values may depend on qualities of verbal arguments or
sentential adjuncts (for example). In this case the values are
compositionally derived."

Label "<p><span style=\"color:red\">Note: The implementation of
situation aspect is still under development; There is, as yet, no
implementation of compositionally derived situation aspect. Currently
the <span class=\"feat\">situation</span> feature may be used to
represent inherent lexical qualities or those conveyed through overt
morphological marking. This more accurately reflects uses of the term
\"lexical aspect\".</span></p>"

Label "<p>You may create a hierarchy of values for the feature <span
class=\"feat\">situation</span>, reflecting inherent or
morphologically marked situation aspect. If this is not appropriate
for your language, leave this section blank."

BeginIter situation{i} "a situation type" 1

  Text name "situation {i} name" "Situation name: " "" 20
  BeginIter supertype{j} "a Supertype" 0 1

    Select name "Situation {i} supertype {j} name" "Supertype: " ""
    fillregex p=situation[0-9]+_name n=1
    . situation "Situation" "situation"

  EndIter supertype

EndIter situation

Label "</div>"
Label "</div>"

Label "<div style=\"padding-left: 16px\">"
Label "<h4><span class=\"feat\">mood</span></h4>"

Label "According to Palmer (1986), the term 'mood' is generally used to refer to modality reflected in verbal inflection. The broader category modality is a somewhat vague grammatical category that is quite language specific. However, modality may be roughly described as relating to the opinions or attitudes of the speaker. Modality may include mood (e.g., subjunctive), modal systems and notions of hearsay or evidentiality. While we call this feature <span class=\"feat\">mood</span> it may be used to define values of the broader category of modality, if desired."

Label "You may define values for the feature <span class=\"feat\">mood</span> below. You may select a simple set of values for the feature, reflecting a subjunctive/indicative contrast, or you may define a hierarchy of values for the feature as appropriate for your language. If you would like, you may leave this section blank.<br><br>"

Check subjind "Subjunctive/Indicative" "" "Create a hierarchy consisting of just the values <b>subjunctive</b> and <b>indicative</b> as subtypes of mood."

Label "<p>Build your own hierarchy of values for the feature <span class=\"feat\">mood</span>. Note: this is an alternative to choosing the binary opposition above -- if hierarchy elements are defined below the choice above is overridden."

BeginIter mood{i} "a mood type" 1

  Text name "mood {i} name" "Mood name: " "" 20
  BeginIter supertype{j} "a Supertype" 0 1

     Select name "Mood {i} supertype {j} name" "Supertype: " ""
     fillregex p=mood[0-9]+_name n=1
     . mood "Mood" "mood"

  EndIter supertype

EndIter mood

Label "</div>"

Label "<h4>References</h4>"
Label "<div style=\"font-size:2\">"
Label "<p>Bybee, Joan L. 2003. Aspect. In: Frawley, W.J. (ed.)
International Encyclopedia of Linguistics. Second Edition. Oxford:
OUP. 157-158."
Label "<p>Comrie, Bernard. 1976. Aspect. Cambridge: CUP."
Label "<p>Comrie, Bernard. 1985. Tense. Cambridge: CUP."
Label "<p>Kibort, Anna. \"Aspect.\" Grammatical Features. 7 January
2008. <a
href=\"http://www.features.surrey.ac.uk/features/aspect.html\">http://www.features.surrey.ac.uk/features/aspect.html</a>."
Label "<p>Palmer, Frank R. 1986. Mood and Modality. Cambridge: CUP."
Label "<p>Smith, Carlota. 1997. The Parameter of Aspect. (Second
Edition). Dordrecht: Kluwer Academic Publishers. (Revised version of
Smith, Carlota. 1991. The Parameter of Aspect. Dordrecht: Kluwer
Academic Publishers)."
Label "</div>"

Section other-features "Other Features"

Label "<p>If your language has other features beyond those that can be
defined elsewhere in this questionnaire, you can define those features
here.  For example, if your language has merged features (e.g. <span
class=\"feat\">pernum</span> instead of <span
class=\"feat\">person</span> and <span class=\"feat\">number</span>,
<span class=\"feat\">gendnum</span> instead of <span
class=\"feat\">gender</span> and <span class=\"feat\">number</span>),
they can be defined below.
<br><br>
</p>"

Label "<h3>Syntactic FORM Feature for verbs</h3>"

Label "<p>To start, your
grammar may utilize a syntactic feature characterizing the form the
verb takes. The <span class=\"feat\">form</span> feature distinguishes
finite from non-finite forms and can be used to constrain auxiliary
complement forms and for marking clausal complements (e.g. via morphology).
If not applicable, you may leave this section
blank.</p>"

Label "<p>If you have indicated on the word order page that your
language has auxiliary verbs, your grammar must include
<span class=\"tt\">finite</span> and <span class=\"tt\">nonfinite</span> as values of <span
class=\"feat\">form</span>. If your language does not have auxiliaries
you may still include <span class=\"tt\">finite</span> and <span class=\"tt\">nonfinite</span> as values
of <span class=\"feat\">form</span> in your grammar:<br><br>"

Check form-fin-nf "Finite-nonfinite" "" "Add finite/non-finite FORM feature distinction.</p>"

Label "<p>It is often the case that languages have multiple non-finite
forms, e.g., English: infinitive, past participle, present
participle. If applicable, you may expand the hierarchy of verb <span
class=\"feat\">form</span> values in your grammar by providing
subtypes of <span class=\"tt\">finite</span> and <span class=\"tt\">nonfinite</span>:</p>"


BeginIter form-subtype{i} "a Subtype for FORM"

  Text name "Feature FORM Subtype {i} name" "Name: " "" 20

  MultiSelect supertype "FORM Subtype {i} supertype" " Supertype: " ""
  fillforms

EndIter form-subtype

Label "<p>(Hint: Click Save and Stay to see the supertypes.)</p>"

Label "<h3>Other Syntactic and Semantic Features</h3>"

Label "<p>For each additional feature, you will define a type hierarchy, which
consists of a root type you will name (e.g. <span
class=\"feat\">pernum</span>), and then a series of other values of
the feature, each of which is the subtype of at least one of the other
values, possibly the root.</p>"


Label "<input type=\"hidden\" name=\"existing_value_type1_name\"  value=\"bool\">
<input type=\"hidden\" name=\"existing_value_type2_name\"  value=\"luk\">"

BeginIter feature{i} "a Feature" 1

  Text name "Feature {i} name" "Feature name: " "<br>" 20

  Radio type "Feature {i} type" "Is this feature:<br>" ""
  . head "Head" "" " a syntactic feature (which will go under <span class=\"feat\">head</span>)?<br>"
  . index "Index" "" " a semantic feature (which will go under <span class=\"feat\">index</span>)?<br><br>"

  Radio cat "Feature {i} cat" "Is this feature for:<br>" ""
  . noun "noun" "" " nominal categories?<br>"
  . verb "verb" "" " verbal categories?<br>"
  . both "both" "" " both categories?<br><br>"

  Label "Values in the feature hierarchy:<br>"

  Radio new "Value {i} type" "" ""
  . no "existing" "" " use an existing value type: " "remove_element_all('feature{i}', 'value');"

  Select existing "existing" "" "<br>" "remove_element_all('feature{i}', 'value'); check_radio_button('feature{i}_new', 'no');"
  fillregex p=(existing_value_type[0-9]+_name) n=1
  fillnames2 c=both

  Radio new "Value {i} type" "" ""
  . yes "new" "" " define a new value type<br>" "empty_value('feature{i}_existing', 0);"

  Label "<div id='feature{i}_region'>"

  BeginIter value{j} "a Value" 1

   Text name "Feature {i} Value {j} name" "Value name: " "" 20

    BeginIter supertype{k} "a Supertype" 0 1

      Select name "Feature {i} Value {j} supertype {k} name" "Supertype: " ""
      fillregex p=(feature{i}_name|feature{i}_value[0-9]+_name) n=1

    EndIter supertype

  EndIter value

  Label "</div>"

EndIter feature


Section sentential-negation "Sentential Negation"

Cache verbpcs verb-pc[0-9]+$ name

Label "<p>On this page you can select a strategy that your language uses for sentential negation.
In most cases, morpheme classes that you can further modify will be created on the morphology page.</p>"

Label "<p>Sentential negation constructions can be classified based on the number
of overt morphemes required by the construction.
What's the morphosyntactic exponence of the negation construction you'd like to model?<p>"


Radio neg-exp "neg exp" "" ""
. 0 "0" "" "zero" "set_negexp('0')"
. 1 "1" "" "simple" "set_negexp('1')"
. 2 "2" "" "bipartite" "set_negexp('2')"
. 3 "3" "" "tripartite" "set_negexp('3')"
. more "n" "" "more?!" "set_negexp('more')"

Label "<hr /><a id='anobutton' onclick='toggle_display_lex(\"asymmetric_negation_options\",\"anobutton\")'>&#9658;
asymmetric negation options</a><div id='asymmetric_negation_options' style='display:none'>"


Label "<div id='anhdiv'><a id='anhbutton'
onclick='toggle_display_lex(\"asymmetric_negation_help\", \"anhbutton\")'>&#9658;
asymmetric negation help</a>
<div id='asymmetric_negation_help' style='display:none'><p>Negation
is marked with respect to affirmation (Givón 1984).
In many languages, there are certain tenses/moods/aspects
which are not compatible with negation.
You might model this by enabling a HEAD feature,
[NEGATED luk], set this to '+' on negated verbs and have certain constructions
and/or lexical types specify an incompatible value.</p>

<p>Alternatively, you can have negation specify the values for particular features,
and use an agreement mechanism to trigger the presence of any appropriate marking.
For example, in Maung [mph],  irrealis marking is obligatory with negation.
So you might have the negator specify an AGR feature of irrealis,
then make sure that the head that it is attaching to agrees.</p>

<pre>
ŋi-udba
1sg.3-put
'I put.'

ŋi-udba-ji
1SG.3-put-IRR.NPST
'I can put.'

marig ŋi-udba-ji
NEG 1SG.3-put-IRR.NPST
'I do not put.', 'I cannot put.'

*marig  ŋi-udba
NEG 1SG.3-put
I do not put.
</pre>

</div></div>"
Check neg-head-feature "enable negated head feature" "<p>" "Enable a HEAD feature
([NEGATED luk]) which is appropriate for heads of type verb.<br />"
Label "</div><hr />"


Label "<div id='zero-neg' class='neg_exp_switch' style='display:none'>
<p>Negation without an overt marker.  In some south Dravidian languages such as
(Historical Kannada [kan]), sentential negation was marked by the <em>absence</em>
of the tense marking morpheme that appeared in the corresponding affirmative.
This sort of phenomenon is typologically rare.</p><p>You can model omissive
negation as a phonologically empty inflectional rule ('lexical rule type/instance')
which targets a particular position class in your morphotactic system.
You'll then have to specify at least one other morpheme that canuoccur
in this position class so that negation is indicated by the lack of phonological
material in this position.</p>"

#Select vpc-0-neg "0 neg vpc" "<p>I can create a phonologically
#empty negation affix for you here.  Choose a position class from the verbal
#position classes that you've defined (on the morphology page),
#or choose \"create\" to create a new pc for use with zero neg:" "
#You'll see the result of this choice as a lexical rule instance with no affix and a
#feature called [NEGATION] with the value \"plus\".
#This 'feature' is not a grammatical one---it won't appear in your grammar,
#it only indicates to the customization system that negative semantics should be added
#to this morpheme at customize time.</p>"
#fillcache c=verbpcs
#. create "Create" "create new pc"

Label "</div>"


Label "<div id='uni-neg' class='neg_exp_switch' style='display:none'><p>
Negation can be indicated by the presence of a single negative morpheme.
Your negative morpheme might be bound (negation by inflection) or it might be free
(one of the other choices). Your free negator might be a syntactic head (a verb),
or it might be a dependent (a complement or a modifier).  Specify it's syntax below.</p>"

Check infl-neg "Negation by inflection" "<p>" "Inflectional negation:
Checking this box enables a feature called <span class=\"feat\">negation</span>
with possible value <span class=\"tt\">plus</span> for use in defining morphemes
on the morphology page.  Defining morphemes that specify [<span class=\"feat\">negation</span>
<span class=\"tt\">plus</span>] will produce lexical rules that add the semantics of negation.</p>"

Check neg-aux "Negation by auxiliary verb" "<p>" "Negative auxiliary verb:
Checking this box creates a neg-aux type which contributes a neg_rel that
outscopes it's complement's handle.  This lexical type will show up on the
lexicon page where you'll need to further specify its syntax.</p>"

Text neg-aux-index "index for neg aux" "<span style='display:none'>" "</span>" 1

Check adv-neg "Adverbial negation" "" "An adverb which is a modifier of:<br />"

Radio neg-mod "Negative adverb modifies" "" ""
. s "S" "" "S "
. vp "VP" "" "VP "
. v "V" "" "V "

Radio neg-order "Negative adverb order" "and appears " ""
. before "before" "" "before "
. after "after" "" "after "
. either "either" "" "on either side of the category it modifies.<br>"

Text neg-adv-orth "Negative adverb spelling" "...and which is spelled: " "" 20

Check comp-neg "Negation by selected complement" "<p>" "An adverb like particle
which is a selected complement.  This option will create a non-inflecting lexical
rule that maps plain Vs to Vs which select for negation in addition to their regular COMPS.</p>" "neg_comp()"

Label "<div style='margin-left:10px'>"
Radio comp-neg-head "neg selected by" "Is neg selected by" "<br />"
. aux "aux" "" "a (sub-)class of aux-verbs" "neg_comp()"
. v   "v"   "" "any (finite) verb" "neg_comp()"

Radio comp-neg-order "neg ordered" "How is neg ordered with respect to other COMPS?" "<br />(NB:
After other complements order is only available for non-argument composing auxiliaries.)<br />"
. before "before" "" "before "
. after "after" "" "after "

Text comp-neg-orth "neg spelling" "What's the ORTH value for neg?" "" 20


Label "</div></div>"

Label "<div id='bi-neg' class='neg_exp_switch' style='display:none'>
<p> Negation can be indicated by the required presence of two negative morphemes.
You'll have to specify their morphosyntax and their interactions.</p>"

Hidden bineg-type "bineg type"

Label "<p>We can label the two morphemes NEG1 and NEG2 and ask about the syntactic
properties of each.  Perhaps in your language one of the two negative morphemes
is more closely associated with the contribution of negative force to the sentence,
and the other functions as a resumptive or specifying marker.  Call the primary
indicator of negation NEG1 and the secondary one NEG2.  Please choose the morpheme
type for each exponent of negation:</p>"

Radio neg1-type "NEG1 type" "NEG1" "<br />"
. b "bound" "" "bound" "display_neg_form()"
. fh "free-H" "" "free, syntactic head" "display_neg_form()"
. fc "free-comp" "" "free, syntactic complement" "display_neg_form()"
. fm "free-mod" "" "free, syntactic modifier" "display_neg_form()"



Radio neg2-type "NEG2 type" "NEG2" ""
. b "bound" "" "bound" "display_neg_form()"
. fh "free-H" "" "free, syntactic head" "display_neg_form()"
. fc "free-comp" "" "free, syntactic complement" "display_neg_form()"
. fm "free-mod" "" "free, syntactic modifier" "display_neg_form()"


Label "<div id=\"infl-infl-neg\" class='bineg_switch' style='display:none'>
<p>If both NEG1 and NEG2 are bound to the same root, you can set up the dendency
using the morphotactics system on the morphology page. Only specify that one of your
LRIs is 'negation plus' (you only need one <em>neg_rel</em>), and set up a requires
relation between the two morphemes.</p><p>If NEG1 is bound to an auxiliary and NEG2
is bound to a lexical verb, check the box below.  This will enable several options
for you as you define your lexical rules for NEG1 and NEG2 on the morphology page.
A value for FORM 'negform' will be added to your grammar (as a subtype of nonfinite).
Indicate the lexical rule corresponding to NEG1 by setting [NEGATION +] (this adds the
negative semantics) and the requirement that the complement be [FORM negform].
For the second negator, you can create it in the normal way using the morphology page.
Be sure that the FORM value for your NEG2 morpheme is set to negform.
This will set up the NEG2 lexical rule to change the FORM value on its head to negform.
In this way, auxiliary verbs inflected by NEG1 will require their complement to be headed
by a verb which has been inflected by NEG2.</p>"
Check neg1b-neg2b "neg1 bound to aux requires neg2 bound to lexical verb" "neg1 bound
to aux requires neg2 bound to lexical verb" "</div>"

Label "<div id='infl-head-neg' class='bineg_switch' style='display:none'>
<p>You have selected a negation construction with a negative auxiliary verb
and an inflectional rule.  When you save this page, the negative auxiliary will be
created for you on the lexicon page (where you can further define and constrain its syntax.
A subtype of nonfinite (part of the FORM value hierarchy) called 'negform' has
also been created and your negative auxiliary should select for a complement
which is [FORM negform].  Indicate your negation lexical rule by marking
it as [negation plus] on the morphology subpage.  This rule will change the FORM of
verbs to which it attaches to [FORM negform].</p></div>"

Label "<div id='infl-comp-neg' class='bineg_switch' style='display:none'><p>You have
selected a construction with a negative inflectional rule and a negative selected complement.
Define your lexical rule on the morphology subpage and indicate it with [negation plus].
Please provide some specifics about the negative complement here:</p>"

Radio comp-neg-head-infl-comp-neg "neg selected by" "Is neg selected by" "<br />"
. aux "aux" "" "a (sub-)class of aux-verbs" "neg_comp()"
. v   "v"   "" "any (finite) verb" "neg_comp()"

Radio comp-neg-order-infl-head "neg ordered" "How is neg ordered with resepct
to other COMPS?" "<br />(NB: After other complements order is only available
for non-argument composing auxiliaries.)<br />"
. before "before" "" "before "
. after "after" "" "after "

Text comp-neg-orth "neg spelling" "What's the ORTH value for neg?" "" 20
Label "</div>"

Label "<div id='infl-mod-neg' class='bineg_switch' style='display:none'>
<p>You have selected a negation construction with a negative inflectional
rule and a negative word attached through a head-modifier rule.
Define your lexical rule on the morphology subpage and indicate it with [negation plus].
Please provide some further information about the negative modifier here:</p><p>"

Radio neg-mod-infl-mod-neg "negative adv modifies" "NEG adverb modifies:" "<br />"
. s "S" "" "S "
. vp "VP" "" "VP "
. v "V" "" "V "

Radio neg-mod-order-infl-mod-neg "negative adverb order" "NEG adverb is ordered: " ""
. before "before" "" "before "
. after "after" "" "after "
. either "either" "" "on either side of the category it modifies.<br>"

Text neg-mod-orth "negative adverb spelling" "NEG adverb is spelled: " "" 20
Label "</div>"

Label "<div id='head-head-neg' class='bineg_switch' style='display:none'><p>Two negative heads is not available.  Please contact matrix-dev if you believe this is the best analysis for your language.</p></div>"
Label "<div id='head-comp-neg' class='bineg_switch' style='display:none'><p>You have selected a negative construction with a negative auxiliary verb and a negative selected complement.  When you save the page, the negative auxiliary verb will be created for you on the lexicon page where you can further define its syntax.  Please provide some more information about the negative complement here:</p><p>"

## in head-comp neg, the comp should be a comp of the head (an auxiliary),
## so we don't need this choice
# Radio comp-neg-head "neg selected by" "Is NEG complement selected by" "<br />"
# . aux "aux" "" "a (sub-)class of aux-verbs" "neg_comp()"
# . v   "v"   "" "any (finite) verb" "neg_comp()"

Radio comp-neg-order-head-comp "neg ordered" "How is NEG complement ordered with resepct to other COMPS?" "<br />(NB: After other complements order is only available for non-argument composing auxiliaries.)<br />"
. before "before" "" "before "
. after "after" "" "after "

Text comp-neg-orth "neg spelling" "What's the ORTH value for NEG complement?" "</p>" 20
Label "</div>"

Label "<div id='head-mod-neg' class='bineg_switch' style='display:none'><p>You have selected a negation construction with a negative auxiliary verb and a negative adverb attached through a head-modifier rule.  The negative auxiliary verb will be created for you on the lexicon page where you can further specify its syntax.  Please provide some further information about the negative modifier here:</p>"

Radio neg-mod-head-mod-neg "negative adv modifies" "NEG adverb modifies:" "<br />"
. s "S" "" "S "
. vp "VP" "" "VP "
. v "V" "" "V "

Radio neg-mod-order-head-mod-neg "negative adverb order" "NEG adverb is ordered: " ""
. before "before" "" "before "
. after "after" "" "after "
. either "either" "" "on either side of the category it modifies.<br>"

Text neg-mod-orth "negative adverb spelling" "NEG adverb is spelled: " "" 20
Label "</div>"

Label "<div id='comp-comp-neg' class='bineg_switch' style='display:none'><p>You have selected a construction with two negative complements.  Please provide some further information about the two complements here:</p><p>"

Radio comp-neg1-head "neg1 selected by" "Is NEG1 selected by" "<br />"
. aux "aux" "" "a (sub-)class of aux-verbs" "neg_comp()"
. v   "v"   "" "any (finite) verb" "neg_comp()"

Radio comp-neg1-order "neg1 ordered" "How is NEG1 ordered with resepct to other COMPS?" "<br />(NB: After other complements order is only available for non-argument composing auxiliaries.)<br />"
. before "before" "" "before "
. after "after" "" "after "

Text comp-neg1-orth "neg1 spelling" "What's the ORTH value for NEG1?" "</p><p>" 20

Radio comp-neg2-head "neg2 selected by" "Is NEG2 selected by" "<br />"
. aux "aux" "" "a (sub-)class of aux-verbs" "neg_comp()"
. v   "v"   "" "any (finite) verb" "neg_comp()"

Radio comp-neg2-order "neg2 ordered" "How is NEG2 ordered with resepct to other COMPS?" "<br />(NB: After other complements order is only available for non-argument composing auxiliaries.)<br />"
. before "before" "" "before "
. after "after" "" "after "

Text comp-neg2-orth "neg2 spelling" "What's the ORTH value for NEG2?" "</p>" 20
Label "</div>"

Label "<div id='comp-mod-neg' class='bineg_switch' style='display:none'><p>You have selected a negation construction with a negative complement and a negative modifier.  Please provide some further information here:</p><p>"

Radio comp-neg-head-comp-mod "neg selected by" "Is NEG complement selected by" "<br />"
. aux "aux" "" "a (sub-)class of aux-verbs" "neg_comp()"
. v   "v"   "" "any (finite) verb" "neg_comp()"

Radio comp-neg-order-comp-mod "neg ordered" "How is NEG ordered with resepct to other COMPS?" "<br />(NB: After other complements order is only available for non-argument composing auxiliaries.)<br />"
. before "before" "" "before "
. after "after" "" "after "

Text comp-neg-orth "neg spelling" "What's the ORTH value for the NEG complement?" "</p><p>" 20

Radio neg-mod-comp-mod-neg "negative adv modifies" "NEG adverb modifies:" "<br />"
. s "S" "" "S "
. vp "VP" "" "VP "
. v "V" "" "V "

Radio neg-mod-order-comp-mod-neg "negative adverb order" "NEG adverb is ordered: " ""
. before "before" "" "before "
. after "after" "" "after "
. either "either" "" "on either side of the category it modifies.<br>"

Text neg-mod-orth "negative adverb spelling" "NEG adverb is spelled: " "</p>" 20
Label "</div>"

Label "<div id='mod-mod-neg' class='bineg_switch' style='display:none'><p>You have selected a negation construction with two negative modifiers.  Please provide some further information here:</p><p>"

Radio neg1-mod "negative adv modifies" "NEG1 modifies:" "<br />"
. s "S" "" "S "
. vp "VP" "" "VP "
. v "V" "" "V "

Radio neg1-mod-order "negative adverb order" "NEG1 is ordered: " ""
. before "before" "" "before "
. after "after" "" "after "
. either "either" "" "on either side of the category it modifies.<br>"

Text neg1-mod-orth "negative adverb spelling" "NEG1 is spelled: " "</p>" 20

Radio neg2-mod "negative adv modifies" "NEG2 modifies:" "<br />"
. s "S" "" "S "
. vp "VP" "" "VP "
. v "V" "" "V "

Radio neg2-mod-order "negative adverb order" "NEG2 is ordered: " ""
. before "before" "" "before "
. after "after" "" "after "
. either "either" "" "on either side of the category it modifies.<br>"

Text neg2-mod-orth "negative adverb spelling" "NEG2 is spelled: " "" 20
Label "</div>"

Label "<div id=\"bineg_fb\"></div></div>"

Label "<div id='tri-neg' class='neg_exp_switch' style='display:none'><p> Negation by three morphemes has been reported in some languages of Vanuatu like Lewo [lww].</p></div>"

Label "<div id='x-neg' class='neg_exp_switch' style='display:none'><p>We're not aware of natural languages reported to require more than 3 morphemes as an integral part of a negation construction.  Please send e-mail about this language to the matrix-dev mailing list.</p></div>"

Label "<hr /><p>Notes: This section is under construction.  Expect problems.  Currently, some menu options (under bipartite negation) are only present as previews of future implementations and as of now provide no functionality.</p>"

Label "<h5>References</h5>
<ol>
<li>Givón, Talmy. 1984. <em>Syntax: a typological-functional introduction [vol. III].</em>  John Benjamins. Amsterdam, Philidelphia.</li>
</ol>"



Section coordination "Coordination"

Cache pats (fr|dconj)[0-9]+$ name

Label "<p>Languages can have multiple strategies for marking
coordination that differ among the various parts of speech. The Matrix
supports both lexical and morphological marking of coordination and
several different marking patterns, including:</p>"

Label "<div style=\"padding-left: 16px\"><p><span
class=\"dfn\">Monosyndeton</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;A B
and C&quot; (last coordinand is marked; also allows &quot;A and B and
C&quot;)<br><span
class=\"dfn\">Polysyndeton</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;A
and B and C&quot; (all coordinands but the first are marked)<br><span
class=\"dfn\">Omnisyndeton</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;and
A and B and C&quot; (all coordinands are marked)<br><span
class=\"dfn\">Asyndeton</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;A B
C&quot; (no marking; also known as <span
class=\"dfn\">juxtaposition</span>)</div>"

Label "<p>You may define any number of coordination strategies below.
You may also leave this section blank, in which case the starter
grammar produced will not support coordination.</p>"

BeginIter cs{i} "a Coordination Strategy" 1

  Label "<p>Coordination Strategy {i}:<br>&nbsp;&nbsp;&nbsp;&nbsp;in which"

  Check n "Coordination Strategy {i} coordinates Ns" "" "nouns "
  Check np "Coordination Strategy {i} coordinates NPs" "" "NPs "
  Check vp "Coordination Strategy {i} coordinates VPs" "" "VPs "
  Check s "Coordination Strategy {i} coordinates Ss" "" "sentences<br>"

  Radio pat "Coordination Strategy {i} pattern" "&nbsp;&nbsp;&nbsp;&nbsp;are marked in a " ""
  . mono "Monosyndeton" "" "monosyndeton "
  . poly "Polysyndeton" "" "polysyndeton "
  . omni "Omnisyndeton" "" "omnisyndeton "
  . a "Asyndeton" "" "asyndeton &nbsp; pattern<br>"

  Radio mark "Coordination Strategy {i} mark" "&nbsp;&nbsp;&nbsp;&nbsp;by a " ""
  . word "Word" "" "word "
  . affix "Affix" "" "affix spelled "

  Text orth "Coordination Strategy {i} spelling" "" "" 10

  Radio order "Coordination Strategy {i} order" "that comes " ""
  . before "Before" "" "before "
  . after "After" "" "after the coordinand<br>"

  BeginIter csap{j} "an agreement pattern (optional)" 1

    Select pat "Coordination Strategy {i} agreement name" "&nbsp;&nbsp;&nbsp;&nbsp;and uses the " ""
    fillcache c=pats

    Select target "Coordination Strategy {i} agreement target" "agreement pattern for " ""
      . all "all arguments" "all"
      . subj "subjects only" "subj"
      . obj "objects only" "obj"

  EndIter csap

  Label "</p>"

EndIter cs

Label "<h3 style='display:inline'>Agreement Features in Coordinated Phrases</h3>"

Label "<p>You may describe how agreement features work in coordinated structures. You can then link coordination strategies with a defined agreement pattern. You may also leave this section blank and not attach any agreement patterns to a coordination Type, in which case the top node of coordinated phrases will be underspecified for agreement features.</p>"

Label "<b>Feature Resolution</b>"

Label "<p>In a <b>feature resolution</b> pattern, the feature value of a coordinated phrase is derived from the values of both the child nodes. <p>For example, in many languages, person values follow a hierarchy in which any coordinated phrase with a 1st person conjunct will have 1st person value in the top node, phrases with a 2nd person conjunct (but no 1st person conjunct) will be 2nd person, and phrases with only 3rd person conjuncts will be 3rd person. You may also define feature resolution patterns for features such as gender and number. <p> You'll have to specify the rules that apply to each feature you wish to model.</p>"

BeginIter fr{i} "a feature resolution pattern" 1
  
  Label "<p>(Optionally) give this pattern a name: "
  
  Text name "Feature resolution agreement pattern {i}'s name: " "" "" 10

  Label "<p>This feature resolution pattern uses the following features: <br> "

  BeginIter feat{j} "a Feature"

    Select name "Feature resolution pattern {i} feature {j} name" "Feature: " " "
    fillnames c=noun
    
    BeginIter rule{k} "a Rule"

      MultiSelect left "Feature resolution pattern {i} feature {j} value" "Child 1: " ""
      fillvalues p=fr{i}_feat{j}_name 
        . any "any" "any"  
	. same "the same" "the same" 

      Select right "Feature resolution pattern {i} feature {j} value" "Child 2:" ""
      fillvalues p=fr{i}_feat{j}_name
        . any "any" "any" 
	. same "the same" "the same"  
	. nonmatching "any non-matching value in that list" "any non-matching value in that list"

      Select par "Feature resolution pattern {i} feature {j} value" "Parent: " ""
      fillvalues p=fr{i}_feat{j}_name
        . any "any" "any" 
	. same "the same" "the same"  

    EndIter rule

  EndIter feat

EndIter fr

Label "<p><b>Distinguished Conjunct</b>"

Label "<p>In a <b>distinguished conjunct</b> pattern, the feature value of a coordinated phrase is the same as the value of a particular conjunct. Typically, this conjunct is either the closest one to the verb (closest conjunct), or always in a particular position (first or last conjunct)."

BeginIter dconj{i} "a distinguished conjunct pattern" 1
  
  Label "<p>(Optionally) give this pattern a name: "

  Text name "Distinguished conjunct pattern {i}'s name: " "" "" 10

  Label "<p>This agreement pattern uses agreement features from the<br> "

  Radio order "Coordination Strategy {i} order" "" ""
  . first "Before" "" "first "
  . last "After" "" "last conjunct"
  . closest "After" "" "closest conjunct to the verb"

EndIter dconj


Section matrix-yes-no "Matrix Yes/No Questions"

Label "<p>Please indicate which strategy your language uses to form
matrix yes-no questions.  You may leave this section blank, in which
case your grammar will not include a question-forming strategy.</p>"

Check q-part "Yes/No question particle" "" "A separate question particle: "

Radio q-part-order "Question particle order" "" ""
. before "Before" "" "sentence initial "
. after "After" "" "sentence final<br>"

Text q-part-orth "Question particle spelling" "&nbsp;&nbsp;&nbsp;&nbsp;Spelling of question particle: " "<br>" 40

Check q-infl "Inflection" "<p>" "Verbal inflection: Checking this box enables a feature called <span class=\"feat\">question</span> with possible value <span class=\"tt\">plus</span> for use in defining lexical rules on the morphology page.  Defining lexical rules that specify [<span class=\"feat\">question</span> <span class=\"tt\">plus</span>] will produce lexical rules in the grammar that add the semantics of questions.</p>"

Check q-inv "Subject-verb inversion" "" "Subject-verb inversion: "

Radio q-inv-verb "Inverted verb in questions" "" ""
. main "Main" "" "main verbs only "
. aux "Auxiliary" "" "auxiliaries only "
. main-aux "Main and auxiliary" "" "any verb<br>"




Section info-str "Information Structure"

Label "<p> Information structure, consisting of topic (what an
utterance is about) and focus (the new information an utterance
provides), refers to how speakers structure the content they wish to
convey to listeners. Different languages use different phonological,
morphological, and syntactic means of marking information structure in
sentences. <br><br>
Note: Modules for constraining positions of information structural components in FREE word order languages are currently under development. If your language uses free word order and multiple positions are checked, the grammar may not work properly. </p>"

Label	"<input type=\"hidden\" name=\"cat_type1_name\" value=\"nouns\">
     	 <input type=\"hidden\" name=\"cat_type2_name\" value=\"verbs\">
         <input type=\"hidden\" name=\"pos_type1_name\" value=\"before\">
         <input type=\"hidden\" name=\"pos_type2_name\" value=\"after\">"

Label "<h3>Focus</h3>"

Radio focus-pos "Focus position" "My language places focused constituents in a specific position. The position is<br>" ""
  . clause-initial "clause-initial" "&nbsp;&nbsp;&nbsp;&nbsp;" "clause-initial.<br> "
  . clause-final "clause-final" "&nbsp;&nbsp;&nbsp;&nbsp;" "clause-final.<br> "
  . preverbal "preverbal" "&nbsp;&nbsp;&nbsp;&nbsp;" "preverbal.<br> "
  . postverbal "postverbal" "&nbsp;&nbsp;&nbsp;&nbsp;" "postverbal.<br> "


BeginIter focus-marker{i} "a Focus Marker" 1

Radio type "Focus {i} marker" "This marker is<br>" ""
  . affix "Affix" "" "an affix (You should create this affix on Morphology.)<br>"
  . adp "Adposition" "" "an adposition (You should create this adposition on Lexicon.)<br>"
  . modifier "Modifier" "" "a modifier"

  MultiSelect pos "Focus {i} marker pos" "and appears" ""
  fillregex p=(pos_type[0-9]_name) n=1

  MultiSelect cat "Focus {i} marker cat" "" ""
  fillregex p=(cat_type[0-9]_name) n=1

  Text orth "Focus {i} marker orth" " Spelling: " "<br>" 10

EndIter focus-marker


Label "<h3>Topic</h3>"

Check topic-first "Specific position for topic" "" "Topic always occurs sentence-initially in my language.<br> "

BeginIter topic-marker{i} "a Topic Marker" 1

Radio type "Topic {i} marker" "This marker is<br>" ""
  . affix "Affix" "" "an affix (You should create this affix on Morphology.)<br>"
  . adp "Adposition" "" "an adposition (You should create this adposition on Lexicon.)<br>"
  . modifier "Modifier" "" "a modifier"

  MultiSelect pos "Topic {i} marker pos" "that appears" ""
  fillregex p=(pos_type[0-9]_name) n=1

  MultiSelect cat "Topic {i} marker cat" "" ""
  fillregex p=(cat_type[0-9]_name) n=1

  Text orth "Topic {i} marker orth" " Spelling: " "<br>" 10

EndIter topic-marker


Label "<h3>Contrastive Focus</h3>"


Check c-focus "Contrastive focus" "" "My language uses the same position to express contrastive focus as non-contrastive focus.<br>" "uncheck_all('c-focus-pos');"

Radio c-focus-pos "Contrastive focus position" "<br>My language places contrastively focused constituents in a specific position. The position is<br>" ""
  . clause-initial "clause-initial" "&nbsp;&nbsp;&nbsp;&nbsp;" "clause-initial.<br> " "uncheck_all('c-focus');"
  . clause-final "clause-final" "&nbsp;&nbsp;&nbsp;&nbsp;" "clause-final.<br> " "uncheck_all('c-focus');"
  . preverbal "preverbal" "&nbsp;&nbsp;&nbsp;&nbsp;" "preverbal.<br> " "uncheck_all('c-focus');"
  . postverbal "postverbal" "&nbsp;&nbsp;&nbsp;&nbsp;" "postverbal.<br> " "uncheck_all('c-focus');"

BeginIter c-focus-marker{i} "a Contrastive Focus Marker" 1

Radio type "Contrastive focus {i} marker" "This marker is<br>" ""
  . affix "Affix" "" "an affix (You should create this affix on Morphology.)<br>"
  . adp "Adposition" "" "an adposition (You should create this adposition on Lexicon.)<br>"
  . modifier "Modifier" "" "a modifier"

  MultiSelect pos "Contrastive focus {i} marker pos" "that appears" ""
  fillregex p=(pos_type[0-9]_name) n=1

  MultiSelect cat "Contrastive focus {i} marker cat" "" ""
  fillregex p=(cat_type[0-9]_name) n=1

  Text orth "Contrastive focus {i} marker orth" " Spelling: " "<br>" 10

EndIter c-focus-marker


Label "<h3>Contrastive Topic</h3>"

BeginIter c-topic-marker{i} "a Contrastive Topic Marker" 1

Radio type "Contrastive topic {i} marker" "This marker is<br>" ""
  . affix "Affix" "" "an affix (You should create this affix on Morphology.)<br>"
  . adp "Adposition" "" "an adposition (You should create this adposition on Lexicon.)<br>"
  . modifier "Modifier" "" "a modifier"

  MultiSelect pos "Contrastive topic {i} marker pos" "that appears" ""
  fillregex p=(pos_type[0-9]_name) n=1

  MultiSelect cat "Contrastive topic {i} marker cat" "" ""
  fillregex p=(cat_type[0-9]_name) n=1

  Text orth "Contrastive topic {i} marker orth" " Spelling: " "<br>" 10

EndIter c-topic-marker


Label "<h4>References</h4>"
Label "<font size=\"2\">"
Label "<p>Lambrecht, Knud. 1996. Information Structure and Sentence Form: Topic, Focus, and the Mental Representations of Discourse Referents. Cambridge, UK: Cambridge University Press.</p>"
Label "<p>Gundel, Jeanette K. 1999. On Different Kinds of Focus. In Peter Bosch and Rob van der Sandt (eds.), Focus: Linguistic, Cognitive, and Computational Perspectives, pages 293-305, Cambridge: Cambridge University Press.</p>"
Label "<p>Krifka, Manfred. 2008. Basic Notions of Information Structure. Acta Linguistica Hungarica 55(3), 243-276.</p>"
Label "<p>Fery, Caroline and Krifka, Manfred. 2008. Information Structure: Notional Distinctions, Ways of Expression. Unity and Diversity of Languages pages 123-136.</p>"
Label "<p>Song, Sanghoun and Bender, Emily M. 2011. Using Information Structure to Improve Transfer-based MT. Proceedings of the 18th International Conference on Head-Driven Phrase Structure Grammar, pages 348-368, Stanford: CSLI Publications.</p>"
Label "<p>Song, Sanghoun and Bender, Emily M. 2012. Individual Constraints for Information Structure. Proceedings of the 19th International Conference on Head-Driven Phrase Structure Grammar, pages 330–348, Stanford: CSLI Publications.</p>"
Label "</font>"



Section arg-opt "Argument Optionality"

Label "<p> Languages place different restrictions on argument
optionality.  Some require that subjects (and objects of transitive
verbs) always be overtly realized as separate words. Others allow
subjects and/or objects to be dropped for all verbs or only for
certain verbs or in particular contexts.  For example, English always
requires overt subjects (<i>I studied</i>) whereas in Arabic the
corresponding sentence does not require a pronoun (<i>darastu</i>).
In languages which allow arugment dropping a marker is often attached
to the verb that contains all of the information that a pronoun
would--person, number, and gender.  This is not always the case,
however.  Japanese for instance allows subject dropping but does not
mark the verb for person, number or gender (Dryer 2008).</p>"

Label "<p>Does your language allow argument optionality?  If so,
choose the option that best describes your language.  If not, leave
this page blank.</p>"
Label "<p> NOTE: The questionnaire is only able to handle subject and
object marking that occurs on the verb.  It is unable to handle
clitics which can attach to words other than the verb.</p>"

Label "<h3>Subject Dropping</h3>"
Label "<p>In some languages subjects can always be dropped and in
others they can only be dropped for certain verbs or in certain
contexts.  Tamil generally allows subject dropping but does not allow
verbs relating to the weather to drop their subjects (Asher 1985).
Arabic allows subjects to be dropped for all verbs, tenses and persons
whereas Hebrew does not allow subjects to be dropped in the present
tense (Vainikka and Levy 1999).  If your language only allows subjects
to be dropped for certain combinations of verb tenses/aspects and
persons/number, please choose the feature values for those
combinations.</p>"

Radio subj-drop "Subject Drop" "<p>Subject dropping can occur </p>" ""
. subj-drop-all "Subj Drop Always" "" "with any verb<br>"
. subj-drop-lex "Subj Drop Some" "" "only with certain verbs"

Label "<p>NOTE: When completing the lexicon page, for each verb type
which does not allow subject dropping, select the feature <span
class=\"feat\">OPT</span> - and marked on the subject.</p>"

Radio subj-mark-drop "Subj Mark Drop" "<p>When a subject is dropped, a subject marker on the verb is</p>" ""
. subj-mark-drop-req "Subj Mark Req" "" "required<br>"
. subj-mark-drop-opt "Subj Mark Opt" "" "optional<br>"
. subj-mark-drop-not "Subj Mark Not" "" "not permitted"

Radio subj-mark-no-drop "Subj Mark No Drop" "<p>When a subject is overt (not dropped), a subject marker on the verb is</p>" ""
. subj-mark-no-drop-req "Subj Mark Req" "" "required<br>"
. subj-mark-no-drop-opt "Subj Mark Opt" "" "optional<br>"
. subj-mark-no-drop-not "Subj Mark Not" "" "not permitted"

Label "<p>NOTE: When completing the morphology page, for each morpheme
that is optional or required when a subject is dropped and not
permitted when an overt subject is present, select <span
class=\"feat\">overt-arg</span> not permitted and marked on the
subject.</p>"

Label "<p> For each morpheme that is not permitted when a subject is
dropped and required or optional when an overt subject is present,
select <span class=\"feat\">drp-arg</span> not permitted and marked on
the subject.</p>"

Label "<p> For each morpheme that is optional when a subject is
dropped and required when an overt subject is present, select
<span class=\"feat\">dropped-arg</span>  permitted and marked
on the subject.</p>"

Label "<p>For each morpheme that is required when a subject is dropped and
optional when an overt subject is present, select
<span class=\"feat\">overt-arg</span> permitted and marked on the subject.</p>"

Radio subj-con  "Subject Context" "<p>Subject dropping occurs in </p>" ""
. subj-con-always "Subj Context All" "" "all contexts<br>"
. subj-con-some "Subj Context Some" "" "some contexts"

Label "<p><b>Contexts</b></p>"

BeginIter context{i} "a Context" 1
  Label "<b>Context {i}</b><br>"
  Label "Features:"

  BeginIter feat{j} "a Feature" 0 1

    Select name "Context {i} feature {j} name" "Name: " " "
    fillnames c=both

    MultiSelect value "Context {i} feature {j} value" "Value: " ""
    fillvalues p=context{i}_feat{j}_name

    Select head "Context {i} feature {j} head" "Specified on: " ""
    . verb "The verb" "the verb"
    . subj "The subject" "the subject NP"
    . obj "The object" "the object NP"
    . higher "Higher-ranked" "the higher-ranked NP"
    . lower "Lower-ranked" "the lower-ranked NP"

  EndIter feat

EndIter context

Label "<h3>Object Dropping</h3>"
Label "<p>Some languages allow all transitive verbs to drop their
objects. In other languages object dropping is restricted to certain
verbs.  English is an example of the latter.  In general transitive
verbs must have an overt object, but there are a few verbs such as eat
which allow object dropping.</p>"

Radio obj-drop "Object Drop" "<p>Object dropping is </p>" ""
. obj-drop-all "Obj Drop Always" "" "always allowed<br>"
. obj-drop-lex "Obj Drop Lex" "" "lexically licensed"

Label "<p>NOTE: When completing the lexicon page, for each verb which does not allow object dropping, select the feature <span
class=\"feat\">OPT</span> - and marked on the object.</p>"

Radio obj-mark-drop "Obj Mark Drop" "<p>When an object is dropped, an object marker on the verb is  </p>" ""
. obj-mark-drop-req "Obj Mark Req" "" "required<br>"
. obj-mark-drop-opt "Obj Mark Opt" "" "optional<br>"
. obj-mark-drop-not "Obj Mark Not" "" "not permitted<br>"

Radio obj-mark-no-drop "Obj Mark Drop" "<p>When an object is overt (not dropped), an object marker on the verb is</p>" ""
. obj-mark-no-drop-req "Obj Mark Req" "" "required<br>"
. obj-mark-no-drop-opt "Obj Mark Opt" "" "optional<br>"
. obj-mark-no-drop-not "Obj Mark Not" "" "not permitted<br>"

Label "<p>NOTE: When completing the morphology page, for each morpheme
that is optional or required when an object is dropped and not
permitted when an overt object is present, select <span
class=\"feat\">overt-arg</span> not permitted and marked on the
object.</p>"

Label "<p> For each morpheme that is not permitted when an object is
dropped and required or optional when an overt object is present,
select <span class=\"feat\">drp-arg</span> not permitted and marked on
the object.</p>"

Label "<p> For each morpheme that is optional when an object is
dropped and required when an overt object is present, select
<span class=\"feat\">dropped-arg</span>  permitted and marked
on the object.</p>"

Label "<p>For each morpheme that is required when an object is dropped and
optional when an overt object is present, select
<span class=\"feat\">overt-arg</span> permitted and marked on the object.</p>"


Label "<h4>References</h4>"
Label "<div style=\"font-size:2\">"
Label "<p>Asher, R.E. 1985. Tamil. London:Croom-Helm.</p>"
Label "<p>Dryer, M. 2008. \"Expression of Pronominal Subjects.\"
WALS. <a
href=\"http://wals.info/feature/description/101\">http://wals.info/feature/description/101</a></p>"
Label "<p> Vainikka, A and Levy, Y. 1999. \"Empty Subjects in Finnish
and Hebrew.\" Natural Language and Linguistic Theory 17: 614-71.</p>"
Label "</div>"

Section nominalclause "Nominalized Clauses"

Label "<p>If your language uses nominalization in the context of clausal complements
and/or clausal modifiers, define the nomminalization strategies here. They will then be available on the Clausal Complements, Clausal Modifers, and Morphology pages.</p>"

BeginIter ns{i} "a Nominalization Strategy" 1

  Text name "Nominalization Strategy {i} Name" "<b>Nominalization Strategy {i}</b>:<br/>Nominalization Strategy Name: " " " 20

    Radio level "Nominalization Strategy {i} Level" "<br><b>The nominalization of the clause happens:</b><br>" ""
  . low "Low" "" "at V"
  . mid "Mid" "" "at VP"
  . high "High" "" "at S"

  Radio nmzRel "Nominalization Strategy {i} Relation" "<br><br><b>If nominalization happens at the clause level (if you selected S above), is the nominalization syntactic only or should it also be reflected in the semantics?
  </b><br>" ""
    . no "No" "" "Nominalization is syntactic only<br>"
    . yes "Yes" "" "Nominalization should be reflected in the semantics<br>"

EndIter ns

Section clausal-comp "Clausal Complements"

Define strategies for <b>sentential,
or clausal, complements</b> here.<br><br>

Label "<p><b>New section! Report bugs to Olga Zamaraeva.</b></p>"

Label "<p>You may define several types of object clausal complements below.
You may also leave this section blank, in which case the starter
grammar produced will not support clausal complements. 
<br><br>Specify a clausal verb type
for each strategy in the Lexicon section. Choose the argument structure option
corresponding to the complementation strategy. (There will be three options for
the case frame: case unspecified; subject case -- object unspecified; both subject and
object case specified. In most cases, you will want the second option. The third option
is meant for verbs taking nominalized complements).
</p>"

Cache otherfeatures feature[0-9]+$ name

BeginIter comps{i} "a Clausal Complement Type" 1

  Label "<p>Clausal Complement Type {i}:<br>&nbsp;&nbsp;&nbsp;&nbsp;in which object complement clauses are placed:<br>"

  Check clause-pos-same "Clause Same Position" "" "in the same position as regular noun complements <br>"
  Check clause-pos-extra "Clause Extraposed" "" "in the extraposed position at the end of sentence.<br>"
  
  Label "<p>The complement clauses are marked by
  a (semantically empty) complementizer that comes "

  Check comp-pos-before "Complementizer Position Before" "" "before"
  Check comp-pos-after "Complementizer Position After" "" "or after the complement clause"<br>

  Radio comp "Clausal Complement Type {i} comp" " and is " ""
  . opt "Optional Complementizer" "" "optional or"
  . oblig "Obligatory Complementizer" ""  "obligatory."

        BeginIter complementizer{j} "a Complementizer spelling" 0

                Text orth "comp {i} stem {j} spelling" "Spelling: " "" 30 ""

        EndIter complementizer

        Label "<p> You can put a FORM feature on the obligatory complementizer if you want to constrain the clausal
        verb in terms of which complementizers it can go with. (Note that all complementizers here
        are still assumed to be semantically empty.)</p>"

        #BeginIter cform{k} "a Complementizer Form"

           Select cformvalue "Clausal Complement Type {i} Complementizer Form {k} Value" "Form Value: " ""
           fillvalues p=form l=1

        #EndIter cform


  Label "<p> The embedded verb
  has the following features
  e.g. finite, nonfinite form (define in Other Features; we assume that mostly FORM and MOOD will be used;
  you can use custom syntactic but not semantic features; note that subject raising is not yeet supported,
  so be careful with infinitives: you will not get the right semantics),
   nominalization (define in Nominalized Clauses):</p>"
  
    BeginIter feat{l} "a Feature"

      Select name "Clausal Complement Type {i} Embedded Verb Feature {l} Name" "Name: " ""
	  fillnames2 c=verb
 
      MultiSelect value "Clausal Complement Type {i} Embedded Verb Feature {l} Value" "Value: " ""
      fillvalues p=comps{i}_feat{l}_name

    EndIter feat

EndIter comps

Separator

Label "<p>
NOTES:
</p>"

Label "<p>
1. The current version
of the questionnaire only covers objectival clausal complements.
</p>"

Label "<p>2. You will need to specify the word order in the complement
clauses on the Word Order page. Currently, only one experimental
case is supported:
V2 order in the matrix and V-final in the subordinate clause, across all
types of subordinate clauses.</p>"

Label "<p>
3. Sorry, no extraposition to sentence-initial position yet! (e.g. SOV becomes OSV).
</p>"


Label "<p>
4. You will need to specify the position classes for the verbal morphology
in the Morphology section.
You will need to specify which verbs can take which type of complement in the Lexicon section.
</p>"

Label "<p>
5. The number of various combinations of choices becomes really large
when more than one complementation strategy is defined. You can specify multiple strategies,
but one-strategy scenario was tested better.
</p>"

Label "<p>
6. You can use different nominalization strategies in different complementation strategies,
but the distinction will have no effect unless there are other things that distinguish
the complementation strategies from each other. Using only nominalization type
to create different complementation strategies is currently not supported. Let us
know if your language does this!
</p>"

Label "<p>
7. The only case frame change that is currently supported is via nominalization.
 It is possible to mock up case change by leaving underlying verbs undespecified for case.
</p>"

Label "<p>
8. More than one complementizer is not yet supported.
</p>"

Label "<p>
9. Participial complements (where the participle is modifying the subject) are not yet supported.
</p>"

Label "<p>
10. Subject raising, equi-deletion are not yet supported.
</p>"

Separator

Label "<p>
Reference: Noonan, Michael. Complementation. 
In: Language typology and syntactic description, vol. 2: Complex constructions, 
ed. by Timothy Shopen, 42-140. (2007 (1985)).
</p>"



Section lexicon "Lexicon"

Cache nounlrs noun-pc[0-9]+(_lrt[0-9]+)?$ name
Cache verbpcs verb-pc[0-9]+$ name
Cache verblrs verb-pc[0-9]+(_lrt[0-9]+)?$ name
Cache adjlrs adj-pc[0-9]+(_lrt[0-9]+)?$ name
Cache detlrs det-pc[0-9]+(_lrt[0-9]+)?$ name

Label "<p>On this page you will define <span class=\"dfn\">lexical
types</span> and <span class=\"dfn\">lexical items</span> within those
types.  For most lexical items you must provide both the spelling of
the stem and a <span class=\"dfn\">predicate</span> (or <span
class=\"dfn\">relation</span>) that identifies the stem's semantic
contribution (e.g. <span class=\"tt\">_cat_n_rel</span> for the noun relation
contributed by <i>cat</i> or <span class=\"tt\">_sleep_v_rel</span> for the verb
relation contributed by <i>sleep</i>).  If the predicate is empty
upon adding a spelling the page will create a predicate value based
on the <a href=http://wiki.delph-in.net/moin/RmrsPos>DELPH-IN</a>
standards. If you completed the Argument
Optionality page, be sure to specify whether each verb type allows
subject and or object dropping by selecting the correct value for the
<span class=\"feat\">opt</span> feature.</p>"


Label "<a id=\"toggle_all_lex_button\" onclick=\"toggle_all_display_lex(1)\">&#9660; all sections</a>"

Separator

Label "<h3 style='display:inline'>Noun Types</h3>"
Label "<span>| <a href='javascript:void(0);' onclick=\"draw_hierarchy('noun')\">visualize noun hierarchy</a> (experimental)</span><br />"

Check adj_incorp "adj_incorp" "<p>Some nouns in this language take adjectives as incorporated affixes: " "</p>"

BeginIter noun{i} "a Noun Type" 1 1

  Label "<b>Noun type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Noun {i} name" "Type name: " "<br /><br />" 20

  MultiSelect supertypes "Noun type {i}" "Supertypes: " "<br />"
  fillregex p=noun(?!{i}_)[0-9]+_name

  Label "Features:"

  BeginIter feat{j} "a Feature"

    Select name "Noun {i} feature {j} name" "Name: " " "
    fillnames c=noun

    MultiSelect value "Noun {i} feature {j} value" "Value: " ""
    fillvalues p=noun{i}_feat{j}_name

  EndIter feat

  Radio det "Noun {i} determiner" "<p>For nouns of this type, a determiner is: " "</p>"
  . obl "Obligatory" "" " obligatory"
  . opt "Optional" "" " optional"
  . imp "Impossible" "" " impossible"

  Label "Stems:"

  BeginIter stem{j} "a Stem" 0 1

    Text orth "Noun {i} stem {j} spelling" "Spelling: " "" 30 "fill_pred('noun{i}_stem{j}', 'n')"

    Text pred "Noun {i} stem {j} predicate" " Predicate: " "" 30

  EndIter stem

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Noun {i} Requires" "Noun {i} requires one of the following: " ""
    fillcache c=nounlrs

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Noun {i} Forbids" "Noun {i} forbids the following position class: " ""
    fillcache c=nounlrs

  EndIter forbid

  Label "</div>"

EndIter noun

Separator

Label "<h3 style='display:inline'>Verb Types</h3>"
Label "<span>| <a href='javascript:void(0);' onclick=\"draw_hierarchy('verb')\">visualize verb hierarchy</a> (experimental)</span><br />"

BeginIter verb{i} "a Verb Type" 1 2

  Label "<b>Verb type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Verb {i} name" "Type name: " "<br /><br />" 20

  MultiSelect supertypes "Verb type {i}" "Supertypes: " "<br /><br />"
  fillregex p=verb(?!{i}_)[0-9]+_name

  Label "Features:"

  BeginIter feat{j} "a Feature"

    Select name "Verb {i} feature {j} name" "Name: " " "
    fillnames c=both

    MultiSelect value "Verb {i} feature {j} value" "Value: " ""
    fillvalues p=verb{i}_feat{j}_name

    Select head "Verb {i} feature {j} head" "Specified on: " ""
    . verb "The verb" "the verb"
    . subj "The subject" "the subject NP"
    . obj "The object" "the object NP"
    . higher "Higher-ranked" "the higher-ranked NP"
    . lower "Lower-ranked" "the lower-ranked NP"

  EndIter feat

  Select valence "Verb {i} arguments" "<br /><br />Argument structure: " "<br />"
  fillverbpat

  Select bipartitepc "Verb {i} bipartite stems position class" "If this verb class includes bipartite stems, select the position class for the affix portion of the stems: " "<br />"
  fillcache c=verbpcs

  Label "Stems:"
  BeginIter stem{j} "a simple Stem" 0 1

    Text orth "Verb {i} stem {j} spelling" "Spelling: " "" 30 "fill_pred('verb{i}_stem{j}', 'v')"

    Text pred "Verb {i} stem {j} predicate" " Predicate: " "" 30

  EndIter stem

  BeginIter bistem{j} "a bipartite Stem"

    Text orth "Verb {i} bipartite stem {j} spelling" "Root spelling: " "" 30 "fill_pred('verb{i}_bistem{j}', 'v')"

    Text aff "Verb {i} bipartite stem {j} affix" "Affix spelling: " "" 30

    Text pred "Verb {i} bipartite stem {j} predicate" " Predicate: " "" 30

  EndIter bistem

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Verb {i} requires" "Verb {i} requires one of the following position classes: " ""
    fillcache c=verblrs

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Verb {i} forbids" "Verb {i} forbids the following position class: " ""
    fillcache c=verblrs

  EndIter forbid

  Label "</div>"

EndIter verb

Separator

Label "<h3 style='display:inline'>Adjective Types</h3>"
Label "<span>| <a href='javascript:void(0);' onclick=\"draw_hierarchy('adj')\">visualize adjective hierarchy</a> (experimental)</span><br />"

BeginIter adj{i} "an Adjective Type" 1

  Label "<b>Adjective type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Adjective {i} name" "Type name: " "<br /><br />" 20

  MultiSelect supertypes "Adjective type {i}" "Supertypes: " "<br />"
  fillregex p=adj(?!{i})[0-9]+_name

  Label "<p>Adjectives in constructions are described as <span class=\"dfn\">attributive</span>:
  those that modify nouns (e.g. \"the <b>big</b> dog\"); <br>
  and <span class=\"dfn\">predicative</span>, those that predicate their subject (e.g. \"the dog is <b>big</b>\").
  <br>Many adjectives in many languages can be both predicative or attributive.</p>"

  Radio mod "Adjective {i} structure" "<p>This type of adjective is " "</p>"
  . attr "attributive" "" "attributive "
  . pred "predicative" "" "predicative "
  . both "both" "" "both "
  . none "unspecified" "" "unspecified"

  Label "<p>Features:<br>  Specify agreement features of the adjective by selecting one of the argument choices;<br>  specify inflection for predicative adjectives by selecting a feature to be specified on \"the adjective\".<br></p>"

  BeginIter feat{j} "a Feature"

    Select name "Adjective {i} feature {j} name" "Name: " " "
    fillnames c=both

    MultiSelect value "Adjective {i} feature {j} value" "Value: " ""
    fillvalues p=adj{i}_feat{j}_name

    Select head "Adjective {i} feature {j} head" "Specified on: " "" "" "toggle_element.call(this, 'adj{i}_adj_pc_note', 'on', ['subj', 'mod']); check_radio_button.call(this, 'adj{i}_mod', 'last', ['subj', 'mod']);"
    . adj "The adjective" "the adjective"
    . subj "The subject" "the subject NP"
    . mod "The modified noun" "the modified NP"
    . xarg "Both positions" "both"

  EndIter feat

  Label "<p id='adj{i}_adj_pc_note' style='display:none;'>  NOTE: Specifying agreement features on \"the subject\" or \"the modified noun\" will create a new<br>  position class on the Morphology page with specified features on \"both positions\" and without an affix<br>  to facilitate this functionality.<br>  The type of this adjective has also been changed to 'unspecified' to support this. Specify adjective types<br>  on the Morphology page when using this feature.<br></p>"

  Radio modpos "Adjective {i} attributive structure" "<p>This type of adjective behaving
  attributively modifies items immediately <br>" "</p>"
  . after "After-modifying" "" " after the adjective <br>"
  . before "Before-modifying" "" " before the adjective <br>"
  . either "Either-modifying" "" " either position <br>"
  . other "Other-mod" "" " some other position: this option is not currently supported" "" x

  Check modunique "Adjective {i} unique modification" "" " This type of adjective behaving
  attributively must be the only modifier of its modificand"

  Radio predcop "Adjective {i} predicative structure" "<p>Adjectives of this type behaving predicatively appear as the complement of a copula:<br>" "</p>"
  . obl "Obligatorily" "" " obligatorily<br>"
  . opt "Optionally" "" " optionally<br>" "toggle_element.call(this, 'adj{i}_opt_note', 'on')"
  . imp "Impossibly" "" " impossibly<br>"

  Label "<p id='adj{i}_opt_note' style='display:none;'>  NOTE: Specifying adjectives as optionally appearing as a copula complement will create a<br>  new position class on the Morphology page with a \"copula complement\" lexical rule and <br>\"stative predicate\" lexical rule to facilitate this functionality.<br></p>"

  Label "Stems:"
  BeginIter stem{j} "a Stem" 0 1

    Text orth "Adjective {i} stem {j} spelling" "Spelling: " "" 30 "fill_pred('adj{i}_stem{j}', 'a')"

    Text pred "Adjective {i} stem {j} predicate" " Predicate: " "" 30

  EndIter stem

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Adjective {i} requires" "Adjective {i} requires one of the following position classes: " ""
    fillcache c=adjlrs

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Adjective {i} forbids" "Adjective {i} forbids the following position class: " ""
    fillcache c=adjlrs

  EndIter forbid

  Label "</div>"

EndIter adj

Separator

Label "<h3>"
Label auxlabel "Auxiliary Verb and Copula Types</h3>"

  Label "<p>Auxiliaries may contribute an independent predicate, e.g.,
  English modal <i>can</i>. If you define a type that contributes a
  predicate, you may also specify semantic feature values on the
  auxiliary, if desired. Alternatively, auxiliaries may contribute no
  predicate of their own, e.g., English auxiliary <i>be</i>. In this
  case, they do not directly contribute semantic values; instead, they
  may contribute indirectly by placing constraints on their
  complements.  Note that auxiliary features defined here place no
  constraints on the semantic values of the complement; constraints on
  the complement should be defined as complement features.</p>"

BeginIter aux{i} "an Auxiliary Type" 1

  Label "<b>Auxiliary type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Aux {i} type name" "Type name: " "<br>" 30

  Label "<br>This auxiliary type contributes:"

  Label "<div style=\"padding-left: 25px\">"

  Radio sem "Aux {i} semantics" "" ""
  . no-pred "No predicate" "" "No predicate.<br>"
  . add-pred "Predicate" "" "An independent predicate."

  Label "</div>"

  Label "<br>Auxiliary features:"

  BeginIter feat{j} "an auxiliary feature"

     Select name "Aux {i} feature {j} name" "Name: " ""
     fillnames c=verb

     MultiSelect value "Aux {i} feature {j} value" "Value: " ""
     fillvalues p=aux{i}_feat{j}_name

     Select head "Aux {i} feature {j} head" "Specified on: " ""
     . verb "The auxiliary" "the auxiliary"
     . subj "The subject" "the subject NP"
     . obj  "The object"  "the object NP"
     . higher "Higher-ranked"  "the higher-ranked NP"
     . lower "Lower-ranked" "the lower-ranked NP"

  EndIter feat

  Label "<br><br>"

  Radio subj "Aux {i} subject" "If this auxiliary type takes a VP or V complement, select the subject type:<br>" ""
  . np "Noun phrase" "" "noun phrase without case restrictions <br>"
  . np-comp-case "NP comp case" "" "noun phrase bearing the case the verbal complement assigns to its subject <br>"
  . np-aux-case "NP aux case" "" "noun phrase, receiving the following case from its auxiliary: "

  Select subj_case "Aux {i} subject-case" "" ""
  fillvalues p=case l=1

  Radio subj "Aux {i} subject" "" ""
  . adp "Adpositional phrase" "<br>" "adpositional phrase<br><br>"

  Label complabel "Complement Features:&nbsp; &nbsp; &nbsp; &nbsp; (Note: A
  value for the feature FORM is required.)<br>"

  BeginIter compfeature{j} "a complement feature" 0 1

    Select name "Aux {i} complement feature {j} name" "Name: " ""
    fillnames c=verb

    MultiSelect value "Aux {i} complement feature {j} value" "Value: " ""
    fillvalues p=aux{i}_compfeature{j}_name

  EndIter compfeature

  Label "<br><br>Stems:"

  BeginIter stem{j} "a Stem" 0 1

    Text orth "Aux {i} stem {j} spelling" "Spelling: " "" 30 "aux_fill_pred('aux{i}', 'stem{j}', 'v')"

    Text pred "Aux {i} stem {j} predicate" "&nbsp;&nbsp;&nbsp;&nbsp;Predicate (if applicable): " "" 30

  EndIter stem

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Aux {i} requires" "Aux {i} requires one of the following position classes: " ""
    fillcache c=verblrs

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Aux {i} forbids" "Aux {i} forbids the following position class: " ""
    fillcache c=verblrs

  EndIter forbid

  Label "</div>"

EndIter aux

Label "<p>Define a copula to introduce complements.</p>"

Label "<span><a href='javascript:void(0);' onclick=\"draw_hierarchy('cop')\">visualize copula hierarchy</a> (experimental)</span><br /><br />"

BeginIter cop{i} "a Copula Type" 1

  Label "<b>Copula type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Cop {i} type name" "Type name: " "<br>" 30

  Label "<br />"

  MultiSelect supertypes "Copula type {i}" "Supertypes: " "<br />"
  fillregex p=cop(?!{i})[0-9]+_name

  Label "<br />Complement Type: What kind of complements does this copula allow?<br />"

  MultiSelect comptype "Cop {i} comptype" "Type: " ""
  fillvalues p=cop{i}_feat{j}_name
  . np "NPs" "NPs" "" x
  . pp "PPs" "PPs" "" x
  . ap  "APs" "APs"

  Label "<br /><br />Copula features:"

  BeginIter feat{j} "a copula feature"

     Select name "Cop {i} feature {j} name" "Name: " ""
     fillnames c=both

     MultiSelect value "Cop {i} feature {j} value" "Value: " ""
     fillvalues p=cop{i}_feat{j}_name

     Select head "Cop {i} feature {j} head" "Specified on: " ""
     . cop "The copula" "the copula"
     . subj "The subject" "the subject NP"
     . comp  "The complement" "the complement"

  EndIter feat

  Label "<br><br>Stems:"

  BeginIter stem{j} "a Stem" 0 1

    Text orth "Cop {i} stem {j} spelling" "Spelling: " "" 30 "aux_fill_pred('cop{i}', 'stem{j}', 'v')"

  EndIter stem

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Cop {i} requires" "Copula {i} requires one of the following position classes: " ""
    fillcache c=verblrs

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Aux {i} forbids" "Copula {i} forbids the following position class: " ""
    fillcache c=verblrs

  EndIter forbid

  Label "</div>"

EndIter cop

Separator

Label "<h3>Determiners</h3>"

BeginIter det{i} "a Determiner" 1

  Label "<b>Determiner type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Determiner {i} name" "Type name: " "<br>" 20

  BeginIter stem{j} "a Stem" 0 1

    Text orth "Determiner {i} spelling" "Spelling: " "" 30 "fill_pred('det{i}_stem{j}', 'q')"

    Text pred "Determiner {i} predicate" " Predicate: " "<br>" 30

  EndIter stem

  Label "<br><br>Features:"

  BeginIter feat{j} "a Feature"

    Select name "Determiner {i} feature {j} name" "Name: " " "
    fillnames c=noun

    MultiSelect value "Determiner {i} feature {j} value" "Value: " ""
    fillvalues p=det{i}_feat{j}_name

  EndIter feat

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Determiner {i} requires" "Determiner {i} requires one of the following position classes: " ""
    fillcache c=detlrs

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    MultiSelect others "Determiner {i} requires" "Determiner {i} requires one of the following position classes: " ""
    fillcache c=detlrs

  EndIter forbid

  Label "</div>"

EndIter det

Separator

Label "<h3>Case-marking and/or Information Structural Adpositions</h3>"

BeginIter adp{i} "an Adposition" 1

  Text orth "Adposition {i} spelling" "Spelling: " "" 20

  Check opt "Adposition {i} optional" ", which is " " optional"

  Select order "Adposition {i} order" " and appears " " a noun phrase<br><br>Features:<br>"
  . after "After" "after"
  . before "Before" "before"

  BeginIter feat{j} "a Feature" 0 1

    Select name "Adposition {i} feature {j} name" "Name: " " "
    fillnames c=noun

    MultiSelect value "Adposition {i} feature {j} value" "Value: " ""
    fillvalues p=adp{i}_feat{j}_name

  EndIter feat

EndIter adp

Section morphology "Morphology"

Cache nouns noun[0-9]+$ name
Cache verbs verb[0-9]+$ name
Cache auxes aux[0-9]+$ name
Cache dets det[0-9]+$ name
Cache adjs adj[0-9]+$ name
Cache cops cop[0-9]+$ name

Label "<p>Here you can define inflectional morphology for nouns, verbs, and
determiners.  To do so, first define one or more inflectional <span
class=\"dfn\">position classes</span>, which determine the order in which
morphemes appear, then define one or more <span class=\"dfn\">lexical rule
types</span> (LRTs) that can appear in each position class, along with the
<span class=\"dfn\">features</span> specified by each LRT.  To determine the
order of position classes, you must define one or more <span
class=\"dfn\">inputs</span> for each.  For LRTs that attach directly to stems,
the input will be a lexical type; for LRTs that attach to already-inflected
stems, the input will be another position class.</p>"

Label "<a id=\"toggle_all_lex_button\" onclick=\"toggle_all_display_lex(1)\">&#9660; all sections</a>"

Label "<h3>Noun Inflection</h3>"

BeginIter noun-pc{i} "a Position Class" 1 0

  Text name "Noun Position Class {i} Name" "<b>Noun Position Class {i}</b>:<br/>Position Class Name: " " " 20

  Check obligatory "Noun Position Class {i} Obligatory" "<br/>Obligatorily occurs:" ""

  Select order "Noun Position Class {i} Order" "<br/>Appears as a prefix or suffix:" ""
  . prefix "Prefix" "prefix"
  . suffix "Suffix" "suffix"

  MultiSelect inputs "Noun Position Class {i} Input" "<br/>Possible inputs:" ""
  fillcache c=nouns
  fillregex p=(verb|noun)-pc[0-9]+(_lrt[0-9]+)?_name
  . noun "Any noun" "any noun"

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Noun Position Class {i} Requires" "Noun Position Class {i} requires one of the following: " ""
    fillcache c=nouns
    fillregex p=noun-pc[0-9]+(_lrt[0-9]+)?_name
    . noun "Any noun" "any noun"

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Noun Position Class {i} Forbids" "Noun Position Class {i} forbids the following: " ""
    fillcache c=nouns
    fillregex p=noun-pc[0-9]+(_lrt[0-9]+)?_name
    . noun "Any noun" "any noun"

  EndIter forbid

  Label "<p>Lexical Rule Types that appear in this Position Class:</p>"

  BeginIter lrt{j} "a Lexical Rule Type" 1 0

    Text name "Noun Position Class {i} Lexical Rule Type {j} Name" "<b>Lexical Rule Type {j}</b>:<br/>Name: " "" 20

    MultiSelect supertypes "Noun Position Class {i} Lexical Rule Type {j} Supertype" "<br/>Supertypes: " ""
    fillregex p=noun-pc{i}_lrt[0-9]+_name

    Label "<p>Features:</p>"

    BeginIter feat{k} "a Feature"

      Select name "Noun Position Class {i} Lexical Rule Type {j} Feature {k} Name" "Name: " " "
      fillnames c=both

      MultiSelect value "Noun Position Class {i} Lexical Rule Type {j} Feature {k} Value" "Value: " ""
      fillvalues p=noun-pc{i}_lrt{j}_feat{k}_name

    EndIter feat

    Label "<p>Morphotactic Constraints:</p>"

    BeginIter require{k} "a Require constraint"

      MultiSelect others "Noun Position Class {i} Lexical Rule Type {j} Requires" "Lexical Rule Type {j} requires one of the following: " ""
      fillcache c=nouns
      fillregex p=noun-pc[0-9]+(_lrt[0-9]+)?_name
      . noun "Any noun" "any noun"

    EndIter require

    BeginIter forbid{k} "a Forbid constraint"

      Select others "Noun Position Class {i} Lexical Rule Type {j} forbids" "Lexical Rule Type {j} forbids the following: " ""
      fillcache c=nouns
      fillregex p=noun-pc[0-9]+(_lrt[0-9]+)?_name
      . noun "Any noun" "any noun"

    EndIter forbid

    Label "<p>Lexical Rule Instances:</p>"

    BeginIter lri{k} "a Lexical Rule Instance" 0 1

      Radio inflecting "Noun Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Has Orthography" "Instance {k}" ""
      . no "No" "" "No affix"
      . yes "Yes" "" "Affix spelled"

      Text orth "Noun Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Spelling" "" "" 20

    EndIter lri

  EndIter lrt

  BeginIter is-lrt{j} "an Incorporated Stem Lexical Rule Type" 1 0 "adj_incorp"

    Text name "Noun Position Class {i} Lexical Rule Type {j} Name" "<b>Incorporated Stem Lexical Rule Type {j}</b>:<br/>Name: " "" 20

    MultiSelect supertypes "Noun Position Class {i} Lexical Rule Type {j} Supertype" "<br/>Supertypes: " ""
    fillregex p=noun-pc{i}_is-lrt[0-9]+_name

    Label "<p>Features:</p>"

    BeginIter feat{k} "a Feature"

      Select name "Noun Position Class {i} Lexical Rule Type {j} Feature {k} Name" "Name: " " "
      fillnames c=noun

      MultiSelect value "Noun Position Class {i} Lexical Rule Type {j} Feature {k} Value" "Value: " ""
      fillvalues p=noun-pc{i}_is-lrt{j}_feat{k}_name

      Select head "Noun Position Class {i} Lexical Rule Type {j} Feature {k} Head" "Specified on: " ""
      . dtr "The noun" "the noun"
      . adj "The adjective" "the adjective"

    EndIter feat

    Label "<p>Morphotactic Constraints:</p>"

    BeginIter require{k} "a Require constraint"

      MultiSelect others "Noun Position Class {i} Lexical Rule Type {j} Requires" "Lexical Rule Type {j} requires one of the following: " ""
      fillcache c=nouns
      fillregex p=noun-pc[0-9]+(_is-lrt[0-9]+)?_name
      . noun "Any noun" "any noun"

    EndIter require

    BeginIter forbid{k} "a Forbid constraint"

      Select others "Noun Position Class {i} Lexical Rule Type {j} forbids" "Lexical Rule Type {j} forbids the following: " ""
      fillcache c=nouns
      fillregex p=noun-pc[0-9]+(_is-lrt[0-9]+)?_name
      . noun "Any noun" "any noun"

    EndIter forbid

    Label "<p>Lexical Rule Instances:</p>"

    BeginIter lri{k} "a Lexical Rule Instance" 0 1

      Radio inflecting "Noun Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Has Orthography" "Instance {k}<br>" ""
      . no "No" "" "No affix<br>"
      . yes "Yes" "" "Affix spelled"

      Text orth "Noun Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Spelling" "" "" 20 "fill_pred('noun-pc{i}_is-lrt{j}_lri{k}', 'a')"
      Text pred "Noun Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Predicate" "Predicate: " "" 20

    EndIter lri

  EndIter is-lrt

EndIter noun-pc

Separator

Label "<h3>Verb Inflection</h3>"

BeginIter verb-pc{i} "a Position Class" 1

  Text name "Verb Position Class {i} Name" "<b>Verb Position Class {i}</b>:<br/>Position Class Name: " " " 20

  Check obligatory "Verb Position Class {i} Obligatory" "<br/>Obligatorily occurs:" ""

  Select order "Verb Position Class {i} Order" "<br/>Appears as a prefix or suffix:" ""
  . prefix "Prefix" "prefix"
  . suffix "Suffix" "suffix"

  MultiSelect inputs "Verb Position Class {i} Input" "<br/>Possible inputs:" ""
  fillcache c=verbs
  fillcache c=auxes
  fillregex p=verb-pc[0-9]+(_lrt[0-9]+)?_name
  . verb "Any verb" "any verb"
  . iverb "Any intransitive verb" "any intransitive verb"
  . tverb "Any transitive verb" "any transitive verb"
  . aux "Any auxiliary verb" "any auxiliary verb"

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Verb Position Class {i} Requires" "Verb Position Class {i} requires one of the following: " ""
    fillcache c=verbs
    fillcache c=auxes
    fillregex p=verb-pc[0-9]+(_lrt[0-9]+)?_name
    . verb "Any verb" "any verb"
    . iverb "Any intransitive verb" "any intransitive verb"
    . tverb "Any transitive verb" "any transitive verb"
    . aux "Any auxiliary verb" "any auxiliary verb"

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Verb Position Class {i} Forbids" "Verb Position Class {i} forbids the following: " ""
    fillcache c=verbs
    fillcache c=auxes
    fillregex p=verb-pc[0-9]+(_lrt[0-9]+)?_name
    . verb "Any verb" "any verb"
    . iverb "Any intransitive verb" "any intransitive verb"
    . tverb "Any transitive verb" "any transitive verb"
    . aux "Any auxiliary verb" "any auxiliary verb"

  EndIter forbid

  Label "<p>Lexical Rule Types that appear in this Position Class:</p>"

  BeginIter lrt{j} "a Lexical Rule Type" 1 1

    Text name "Verb Position Class {i} Lexical Rule Type {j} Name" "<b>Lexical Rule Type {j}</b>:<br/>Name: " "" 20

    MultiSelect supertypes "Verb Position Class {i} Lexical Rule Type {j} Supertype" "<br/>Supertypes: " ""
    fillregex p=verb-pc{i}_lrt[0-9]+_name

    Label "<p>Features:</p>"

    BeginIter feat{k} "a Feature"

      Select name "Verb Position Class {i} Lexical Rule Type {j} Feature {k} Name" "Name: " " "
      fillnames c=both

      MultiSelect value "Verb Position Class {i} Lexical Rule Type {j} Feature {k} Value" "Value: " ""
      fillvalues p=verb-pc{i}_lrt{j}_feat{k}_name

      Select head "Verb Position Class {i} Lexical Rule Type {j} Feature {k} Head" "Specified on: " ""
      . verb "The verb" "the verb"
      . subj "The subject" "the subject NP"
      . obj "The object" "the object NP"
      . higher "Higher-ranked" "the higher-ranked NP"
      . lower "Lower-ranked" "the lower-ranked NP"

    EndIter feat

    Label "<p>Valence-changing operations may modify the valence structure of<br/>
a verb by adding or removing either a subject or object, possibly <br/>
including changes to e.g. case frames or adding predicates. (<b>Experimental</b>)</p>"


    BeginIter valchg{k} "a valence-changing operation"

      Select operation "Verb Position Class {i} Lexical Rule Type {j} Valence-changing Operation {k} Type" "Type: " "<br/>" "" ""
      . subj-rem "Subject-removing" "subject-removing"
      . obj-rem "Object-removing" "object-removing"
      . obj-add "Object-adding" "object-adding"

      Label "<p>Object-adding operations currently only support strict transitive verbs as inputs.<br/>
        For object-adding operations, also specify (ignored for other operations):</P>"
      Text predname "Verb Position Class {i} Lexical Rule Type {j} Valence-changing Operation {k} Predicate Name" "Predicate: " "<br/> " 20

      Select argpos "Verb Position Class {i} Lexical Rule Type {j} Valence-changing Operation {k} Complement Position" "The added argument is at the: " " of the complements list.<br/>"
      . pre "front" "front"
      . post "end" "end" 


      Select argtype "Verb Position Class {i} Lexical Rule Type {j} Valence-changing Operation {k} Argument Type" "The added argument must be a(n): " ""
      . np "NP" "NP"
      . pp "PP" "PP"
      
    EndIter valchg

    Label "<p>Morphotactic Constraints:</p>"

    BeginIter require{k} "a Require constraint"

      MultiSelect others "Verb Position Class {i} Lexical Rule Type {j} Requires" "Lexical Rule Type {j} requires one of the following: " ""
      fillcache c=verbs
      fillcache c=auxes
      fillregex p=verb-pc[0-9]+(_lrt[0-9]+)?_name
      . verb "Any verb" "any verb"
      . iverb "Any intransitive verb" "any intransitive verb"
      . tverb "Any transitive verb" "any transitive verb"
      . aux "Any auxiliary verb" "any auxiliary verb"

    EndIter require

    BeginIter forbid{k} "a Forbid constraint"

      Select others "Verb Position Class {i} Lexical Rule Type {j} forbids" "Lexical Rule Type {j} forbids the following: " ""
      fillcache c=verbs
      fillcache c=auxes
      fillregex p=verb-pc[0-9]+(_lrt[0-9]+)?_name
      . verb "Any verb" "any verb"
      . iverb "Any intransitive verb" "any intransitive verb"
      . tverb "Any transitive verb" "any transitive verb"
      . aux "Any auxiliary verb" "any auxiliary verb"

    EndIter forbid

    Label "<p>Lexical Rule Instances:</p>"

    BeginIter lri{k} "a Lexical Rule Instance" 0 1

      Radio inflecting "Verb Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Has Orthography" "Instance {k}" ""
      . no "No" "" "No affix"
      . yes "Yes" "" "Affix spelled"

      Text orth "Verb Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Spelling" "" "" 20

    EndIter lri

  EndIter lrt

EndIter verb-pc

Separator

Label "<h3>Adjective Inflection</h3>"

BeginIter adj-pc{i} "a Position Class" 1

  Text name "Adjective Position Class {i} Name" "<b> Adjective Position Class {i}</b>:<br/>Position Class Name: " " " 20

  Check obligatory "Adjective Position Class {i} Obligatory" "<br/>Obligatorily occurs:" ""

  Select order "Adjective Position Class {i} Order" "<br/>Appears as a prefix or suffix:" ""
  . prefix "Prefix" "prefix"
  . suffix "Suffix" "suffix"

  MultiSelect inputs "Adjective Position Class {i} Input" "<br/>Possible inputs:" ""
  fillcache c=adjs
  fillregex p=adj-pc[0-9]+(_lrt[0-9]+)?_name
  . adj "Any Adjective" "any adjective"

  Check switching "Adjective Position Class {i} Switching" "<div>This position class constrains the syntactic behavior of its output: " "</div>"

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Adjective Position Class {i} Requires" "Adjective Position Class {i} requires one of the following: " ""
    fillcache c=adjs
    fillregex p=adj-pc[0-9]+(_lrt[0-9]+)?_name
    . adj "Any Adjective" "any adjective"

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Adjective Position Class {i} Forbids" "Adjective Position Class {i} forbids the following: " ""
    fillcache c=adjs
    fillregex p=adj-pc[0-9]+(_lrt[0-9]+)?_name
    . adj "Any Adjective" "any adjective"

  EndIter forbid

  Label "<p>Lexical Rule Types that appear in this Position Class:</p>"

  BeginIter lrt{j} "a Lexical Rule Type" 1 1

    Text name "Adjective Position Class {i} Lexical Rule Type {j} Name" "<b>Lexical Rule Type {j}</b>:<br/>Name: " "" 20

    MultiSelect supertypes "Adjective Position Class {i} Lexical Rule Type {j} Supertype" "<br/>Supertypes: " ""
    fillregex p=adj-pc{i}_lrt[0-9]+_name

    Label "<p>Features:<br>  Specify agreement features of the adjective by selecting one of the argument choices;<br>  specify inflection for predicative adjectives by selecting a feature to be specified on \"the adjective\".<br></p>"

    BeginIter feat{k} "a Feature"

      Select name "Adjective Position Class {i} Lexical Rule Type {j} Feature {k} Name" "Name: " " "
      fillnames c=both

      MultiSelect value "Adjective Position Class {i} Lexical Rule Type {j} Feature {k} Value" "Value: " ""
      fillvalues p=adj-pc{i}_lrt{j}_feat{k}_name

      Select head "Adjective Position Class {i} Lexical Rule Type {j} Feature {k} Head" "Specified on: " "" "" "toggle_element.call(this, 'adj-pc{i}_lrt{j}_adj_pc_note', 'on', ['subj', 'mod'])"
      . adj "The adjective" "the adjective"
      . subj "The subject" "the subject NP"
      . mod "The modified noun" "the modified NP"
      . xarg "Both positions" "both"

    EndIter feat

    Label "<p id='adj-pc{i}_lrt{j}_adj_pc_note' style='display:none;'>   NOTE: Specifying agreement features on \"the subject\" or \"the modified noun\" will create a new position<br>  class with specified features on \"both positions\" and without an affix to facilitate this functionality. If this<br>  is one of those position classes, make sure the \"specified on\" choice is set to \"both positions\"<br></p>"

    Radio mod "Adjective Position Class {i} Lexical Rule Type {j} structure" "<p>Instances of this Lexical Rule Type can be " "</p>" "adj-pc{i}_switching"
    . attr "Attributive" "" "attributive "
    . pred "Predicative" "" "predicative "
    . both "both" "" "both "

    Radio modpos "Adjective Position Class {i} Lexical Rule Type {j} modification direction" "<p>Instances of this Lexical Rule Type behaving attributively modify nouns directly<br>" "</p>" "adj-pc{i}_switching"
    . after "After-modifying" "" " after the adjective <br>"
    . before "Before-modifying" "" " before the adjective <br>"
    . either "Either-modifying" "" " either position <br>"
    . other "Other-mod" "" " some other position: this option is not currently supported" "" x

    Check predcop "Adjective Position Class {i} Lexical Rule Type {j} Stative Predicate or Copula Complement" "" " Instances of this Lexical Rule Type behaving predicatively appear as copula complements" "" "adj-pc{i}_switching"

    Label "<p>Morphotactic Constraints:</p>"

    BeginIter require{k} "a Require constraint"

      MultiSelect others "Adjective Position Class {i} Lexical Rule Type {j} Requires" "Lexical Rule Type {j} requires one of the following: " ""
      fillcache c=adjs
      fillregex p=adj-pc[0-9]+(_lrt[0-9]+)?_name
      . adj "Any adjective" "any adjective"

    EndIter require

    BeginIter forbid{k} "a Forbid constraint"

      Select others "Adjective Position Class {i} Lexical Rule Type {j} forbids" "Lexical Rule Type {j} forbids the following: " ""
      fillcache c=adjs
      fillregex p=adj-pc[0-9]+(_lrt[0-9]+)?_name
      . adj "Any adjective" "any adjective"

    EndIter forbid

    Label "<p>Lexical Rule Instances:</p>"

    BeginIter lri{k} "a Lexical Rule Instance" 0 1

      Radio inflecting "Adjective Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Has Orthography" "Instance {k}" ""
      . no "No" "" "No affix"
      . yes "Yes" "" "Affix spelled"

      Text orth "Adjective Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Spelling" "" "" 20

    EndIter lri

  EndIter lrt

EndIter adj-pc

Separator

Label "<h3>Copula Inflection</h3>"

BeginIter cop-pc{i} "a Position Class" 1

  Text name "Copula Position Class {i} Name" "<b> Copula Position Class {i}</b>:<br/>Position Class Name: " " " 20

  Check obligatory "Copula Position Class {i} Obligatory" "<br/>Obligatorily occurs:" ""

  Select order "Copula Position Class {i} Order" "<br/>Appears as a prefix or suffix:" ""
  . prefix "Prefix" "prefix"
  . suffix "Suffix" "suffix"

  MultiSelect inputs "Copula Position Class {i} Input" "<br/>Possible inputs:" ""
  fillcache c=cops
  fillregex p=cop-pc[0-9]+(_lrt[0-9]+)?_name
  . cop "Any Copula" "any copula"

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Copula Position Class {i} Requires" "Copula Position Class {i} requires one of the following: " ""
    fillcache c=cops
    fillregex p=cop-pc[0-9]+(_lrt[0-9]+)?_name
    . cop "Any Copula" "any copula"

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Copula Position Class {i} Forbids" "Copula Position Class {i} forbids the following: " ""
    fillcache c=cops
    fillregex p=cop-pc[0-9]+(_lrt[0-9]+)?_name
    . cop "Any Copula" "any copula"

  EndIter forbid

  Label "<p>Lexical Rule Types that appear in this Position Class:</p>"

  BeginIter lrt{j} "a Lexical Rule Type" 1 1

    Text name "Copula Position Class {i} Lexical Rule Type {j} Name" "<b>Lexical Rule Type {j}</b>:<br/>Name: " "" 20

    MultiSelect supertypes "Copula Position Class {i} Lexical Rule Type {j} Supertype" "<br/>Supertypes: " ""
    fillregex p=cop-pc{i}_lrt[0-9]+_name

    Label "<p>Features:</p>"

    BeginIter feat{k} "a Feature"

      Select name "Copula Position Class {i} Lexical Rule Type {j} Feature {k} Name" "Name: " " "
      fillnames c=both

      MultiSelect value "Copula Position Class {i} Lexical Rule Type {j} Feature {k} Value" "Value: " ""
      fillvalues p=cop-pc{i}_lrt{j}_feat{k}_name

      Select head "Copula Position Class {i} Lexical Rule Type {j} Feature {k} Head" "Specified on: " ""
      . cop "The copula" "the copula"
      . subj "The subject" "the subject NP"
      . mod "The complement" "the complement"

    EndIter feat

    Label "<p>Morphotactic Constraints:</p>"

    BeginIter require{k} "a Require constraint"

      MultiSelect others "Copula Position Class {i} Lexical Rule Type {j} Requires" "Lexical Rule Type {j} requires one of the following: " ""
      fillcache c=cops
      fillregex p=cop-pc[0-9]+(_lrt[0-9]+)?_name
      . cop "Any copula" "any copula"

    EndIter require

    BeginIter forbid{k} "a Forbid constraint"

      Select others "Copula Position Class {i} Lexical Rule Type {j} forbids" "Lexical Rule Type {j} forbids the following: " ""
      fillcache c=cops
      fillregex p=cop-pc[0-9]+(_lrt[0-9]+)?_name
      . cop "Any copula" "any copula"

    EndIter forbid

    Label "<p>Lexical Rule Instances:</p>"

    BeginIter lri{k} "a Lexical Rule Instance" 0 1

      Radio inflecting "Copula Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Has Orthography" "Instance {k}" ""
      . no "No" "" "No affix"
      . yes "Yes" "" "Affix"

      Text orth "Copula Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Spelling" "spelled" "" 20

    EndIter lri

  EndIter lrt

EndIter cop-pc

Separator

Label "<h3>Determiner Inflection</h3>"

BeginIter det-pc{i} "a Position Class" 1

  Text name "Determiner Position Class {i} Name" "<b>Determiner Position Class {i}</b>:<br/>Position Class Name: " " " 20

  Check obligatory "Determiner Position Class {i} Obligatory" "<br/>Obligatorily occurs:" ""

  Select order "Determiner Position Class {i} Order" "<br/>Appears as a prefix or suffix:" ""
  . prefix "Prefix" "prefix"
  . suffix "Suffix" "suffix"

  MultiSelect inputs "Determiner Position Class {i} Input" "<br/>Possible inputs:" ""
  fillcache c=dets
  fillregex p=det-pc[0-9]+(_lrt[0-9]+)?_name
  . det "Any determiner" "any determiner"

  Label "<p>Morphotactic Constraints:</p>"

  BeginIter require{j} "a Require constraint"

    MultiSelect others "Determiner Position Class {i} Requires" "Determiner Position Class {i} requires one of the following: " ""
    fillcache c=dets
    fillregex p=det-pc[0-9]+(_lrt[0-9]+)?_name
    . det "Any determiner" "any determiner"

  EndIter require

  BeginIter forbid{j} "a Forbid constraint"

    Select others "Determiner Position Class {i} Forbids" "Determiner Position Class {i} forbids the following: " ""
    fillcache c=dets
    fillregex p=det-pc[0-9]+(_lrt[0-9]+)?_name
    . det "Any determiner" "any determiner"

  EndIter forbid

  Label "<p>Lexical Rule Types that appear in this Position Class:</p>"

  BeginIter lrt{j} "a Lexical Rule Type" 1 1

    Text name "Determiner Position Class {i} Lexical Rule Type {j} Name" "<b>Lexical Rule Type {j}</b>:<br/>Name: " "" 20

    MultiSelect supertypes "Determiner Position Class {i} Lexical Rule Type {j} Supertype" "<br/>Supertypes: " ""
    fillregex p=det-pc{i}_lrt[0-9]+_name

    Label "<p>Features:</p>"

    BeginIter feat{k} "a Feature"

      Select name "Determiner Position Class {i} Lexical Rule Type {j} Feature {k} Name" "Name: " " "
      fillnames c=noun

      MultiSelect value "Determiner Position Class {i} Lexical Rule Type {j} Feature {k} Value" "Value: " ""
      fillvalues p=det-pc{i}_lrt{j}_feat{k}_name

    EndIter feat

    Label "<p>Morphotactic Constraints:</p>"

    BeginIter require{k} "a Require constraint"

      MultiSelect others "Determiner Position Class {i} Lexical Rule Type {j} Requires" "Lexical Rule Type {j} requires one of the following: " ""
      fillcache c=dets
      fillregex p=det-pc[0-9]+(_lrt[0-9]+)?_name
      . det "Any determiner" "any determiner"

    EndIter require

    BeginIter forbid{k} "a Forbid constraint"

      Select others "Determiner Position Class {i} Lexical Rule Type {j} forbids" "Lexical Rule Type {j} forbids the following: " ""
      fillcache c=dets
      fillregex p=det-pc[0-9]+(_lrt[0-9]+)?_name
      . det "Any determiner" "any determiner"

    EndIter forbid

    Label "<p>Lexical Rule Instances:</p>"

    BeginIter lri{k} "a Lexical Rule Instance" 0 1

      Radio inflecting "Determiner Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Has Orthography" "Instance {k}" ""
      . no "No" "" "No affix"
      . yes "Yes" "" "Affix"

      Text orth "Determiner Position Class {i} Lexical Rule Type {j} Lexical Rule Instance {k} Spelling" "spelled" "" 20

    EndIter lri

  EndIter lrt

EndIter det-pc

Section toolbox-import "Import Toolbox Lexicon"

Label "<p><a href=\"http://www.sil.org/computing/toolbox\">Toolbox</a>
is a tool provided by SIL and used by many field linguists. This page
allows you to automatically create lexical entries for your Grammar
Matrix grammar on the basis of lexical entries in a Toolbox lexicon.
This page allows you to guide the import process by defining one
or more configurations (called Toolbox Import Configurations).
You may import from multiple Toolbox files (by
selecting multiple files on this page), but every time you do an
import, all previously imported lexical entries will be dropped.  If
your Toolbox files use the same set of tags, you may add them all to
the same Toolbox Import Configuration.  If they use different tags
(for lexical entry ids, stems, and glosses), you will need to define
separate Toolbox Import Configurations.</p><p>For each Toolbox Import
Configuration, you will need to specify the file or files you are
importing from, the tags used in those files for entry ids, stems, and
glosses.  Within each Toolbox Import Configuration you can specify one
or more Import Classes, which map Toolbox tag/value pairs to lexical
classes defined on the Lexicon page.  The Toolbox Import
Configurations become part of your choices file when you click the
Submit or Import Lexicon buttons.</p><p> Once you have imported a
lexicon, you can check the entries that were imported for each class <a
href=\"matrix.cgi?subpage=ToolboxLexicon\">here</a>.
If you find errors, you can edit the Import Classes and
re-import.</p><p>In order to import information from a Toolbox lexicon
to your choices file, the Toolbox files must be transferred to our
servers.  We will NOT store these files permanently.  They will be
deleted immediately after being processed.</p>"

BeginIter toolboximportconfig{i} "a Toolbox Import Configuration" 1 1

  Text idtag "id tag" "Toolbox tag for lex entry ids: " "" 10

  Text glosstag "gloss tag" " Toolbox tag for glosses: " "" 10

  Text starttag "start tag" "<br /><br />Toolbox tag which starts lexical database entries: " "" 10

  Text stemtag "stem tag" "<br /><br />Toolbox tag for stem: " "" 10

  Text bistemtag "bistem tag" " (Optional) Toolbox tag for affix portion of bipartite stems: " "" 10

  BeginIter repeat{j} " a Toolbox tag which can repeat in a database entry"

    Text tag "repeatable tag" " Repeatable Tag {j}: " "" 10

  EndIter repeat

  Radio tbpredvalues "pred values" "<p>Every lexical entry requires a semantic predicate.  For entries imported from Toolbox, we can construct these predicates from the stem, from the gloss (which could be long), or from the first word of the gloss.  If either of the gloss options is chosen but some entries lack glosses, lexical entries will be constructed from the stem for those entries.  Predicates should be constructed from: <br />" ""
  . stem "Stem" "" " the stem value<br>"
  . gloss "Gloss" "" " the gloss (if available)<br>"
  . glossfw "Gloss first word" "" " the first word of the gloss (if available)"

  BeginIter toolboxfile{j} "a Toolbox File" 0 1

    File tbfilename "file name" "Toolbox file {j}: " ""

  EndIter toolboxfile

  BeginIter importclass{j} "an Import Class" 1 1

    Text importlextype "lexical type" "Lexical type for imported entries " "" 20

    BeginIter toolboxtag{k} "a Toolbox tag-value pair" 0 1

      Text tbtag "toolboxtag" "Toolbox tag (e.g., for part of speech): " "" 10

      Text tbvalue "toolboxvalue" " Value for the Toolbox tag: " "" 10

    EndIter toolboxtag

  EndIter importclass

EndIter toolboximportconfig

Button "Import Toolbox Lexicon" "<br /><br />" "" "import_toolbox_lexicon()"

Section test-sentences "Test Sentences"

Label "<p>In this section, you can provide example sentences that will
appear in the file <span class=\"tt\">test_sentences</span> in your grammar, as defaults
in the LKB's parse dialog, and in the [incr tsdb()] database skeleton
in the tsdb/skeletons directory of your grammar. Please use only the
vocabulary defined in the Lexicon section. If the sentence is
ungrammatical, please check the \"Starred\" checkbox</p>"

BeginIter sentence{i} "a Sentence"

  Text orth "Sentence {i}" "<b>Sentence {i}</b>: " "" 100
  Check star "Grammatical {i}" "Starred: " ""

EndIter sentence

Section gen-options "Test by Generation Options"

Label "<p>In this section, select the templates you wish to generate from,
and the features you which to specify on those templates</p>"

Separator

Label "<p>Select which templates you would like to use in generation.  If nothing is selected, the simple transitive and intransitive templates will be used, with no features specified</p>"

Check itv "Intransitive" "" "Simple intransitive verb phrase<br>"

Label "Features:"

BeginIter itv-feat{j} "a Feature"

    Select name "Feature {j} name" "Name: " " "
    fillnames c=verb

    Select value "Feature {j} value" "Value: " ""
    fillvalues p=itv-feat{j}_name

    Select location "Feature {j} location" "Specified on: " ""
    . NOUN1 "Subject" "the subject NP"
    . ITR-VERB1 "Verb" "the verb"

EndIter itv-feat

Separator

Check stv "Transitive" "" "Simple transitive verb phrase<br>"

Label "Features:"

BeginIter stv-feat{j} "a Feature"

    Select name "Feature {j} name" "Name: " " "
    fillnames c=verb

    Select value "Feature {j} value" "Value: " ""
    fillvalues p=stv-feat{j}_name

    Select location "Feature {j} location" "Specified on: " ""
    . NOUN1 "Subject" "the subject NP"
    . TR-VERB1 "Verb" "the verb"
    . NOUN2 "Object" "the object NP"

EndIter stv-feat

Section ToolboxLexicon "Toolbox Lexicon" 0

Label "<p> Imported Toolbox Lexical items are displayed here, if any of these are incorrect
we recommend changing your import configurations and reimporting your files instead of
directly correcing the entries.</p>"

Separator

BeginIter imported-entry{i} "an imported Entry"

    Text lextype "Imported-Entry {i} LexType" "Lexical Type:" "<br />" 20

    Text orth "Imported-Entry {i} Orthogrphy" "Spelling:" "<br />" 20

    Text pred "Imported-Entry {i} Predicate" "Predicate:" "<br />" 20

    Text aff "Imported-Entry {i} Affix" "Affix:" "<br />" 20

EndIter imported-entry
